<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Website Editor</title>
  <style>
    :root{
      --bg: #0f141b;
      --bg-soft: #141b24;
      --panel: #1b2430;
      --panel-2: #202b3a;
      --text: #e6edf3;
      --muted: #a6b4c3;
      --accent: #7bdcb5;
      --accent-2: #66a3ff;
      --danger: #ff7b7b;
      --border: rgba(255,255,255,0.08);
      --shadow: 0 20px 60px rgba(0,0,0,0.35);
      --radius: 14px;
      --mono: "Cascadia Mono", "SFMono-Regular", "Consolas", "Liberation Mono", monospace;
      --sans: "Space Grotesk", "Trebuchet MS", "Segoe UI", sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(102,163,255,0.25), transparent 60%),
        radial-gradient(1000px 600px at 90% 10%, rgba(123,220,181,0.2), transparent 65%),
        var(--bg);
    }

    .app{
      height:100vh;
      display:flex;
      flex-direction:column;
    }

    header{
      padding:22px 28px 16px;
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
      background: rgba(15,20,27,0.75);
      position: sticky;
      top:0;
      z-index:10;
    }

    .title{
      display:flex;
      align-items:center;
      gap:12px;
      font-size:22px;
      font-weight:600;
      letter-spacing:0.4px;
    }

    .title .badge{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:1px;
      padding:4px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
    }

    .layout{
      flex:1;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      padding:18px 22px 26px;
      min-height:0;
      overflow:hidden;
    }

    aside{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .layout.with-terminal-pane{
      grid-template-columns: 320px 1fr 320px;
    }

    .sidebar-body{
      display:flex;
      flex-direction:column;
      min-height:0;
      flex:1;
      overflow:hidden;
    }

    .dock-left .file-list{
      flex: 1 1 auto;
      max-height: 50%;
    }

    .dock-left .terminal{
      flex: 1 1 auto;
      max-height: 50%;
    }

    .terminal-pane{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .sidebar-head{
      padding:16px 16px 12px;
      border-bottom:1px solid var(--border);
    }

    .sidebar-head .label{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.9px;
      color: var(--muted);
      margin-bottom:8px;
    }

    .search{
      display:flex;
      align-items:center;
      gap:8px;
      background: var(--panel-2);
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
    }

    .search input{
      background: transparent;
      border: none;
      color: var(--text);
      width:100%;
      font-size:14px;
      outline:none;
    }

    .meta-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
      color: var(--muted);
      font-size:12px;
    }

    .pill{
      padding:3px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      background: rgba(255,255,255,0.03);
    }

    .file-list{
      overflow:auto;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
      min-height:0;
    }

    .file-item{
      border:1px solid transparent;
      border-radius:12px;
      padding:10px 12px;
      background: rgba(255,255,255,0.02);
      cursor:pointer;
      transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
    }

    .file-item:hover{
      border-color: rgba(123,220,181,0.4);
      transform: translateY(-1px);
      background: rgba(123,220,181,0.08);
    }

    .file-item.active{
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.15);
      box-shadow: inset 0 0 0 1px rgba(102,163,255,0.35);
    }

    .file-item .name{
      font-weight:600;
      font-size:12px;
      font-family: var(--mono);
      word-break: break-word;
    }

    .file-item .tag{
      margin-top:6px;
      display:inline-block;
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:0.6px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(255,205,123,0.5);
      color:#ffd27b;
      background: rgba(255,205,123,0.12);
    }

    main{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .preview-head{
      padding:18px 20px 12px;
      border-bottom:1px solid var(--border);
      background: rgba(32,43,58,0.5);
    }

    .preview-title{
      font-size:18px;
      font-weight:600;
    }

    .preview-meta{
      margin-top:8px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      color: var(--muted);
      font-size:12px;
    }

    .toolbar{
      margin-top:12px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }

    .top-actions{
      position: absolute;
      top: 18px;
      right: 22px;
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 12;
    }

    .command-bar{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      margin-top:16px;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.03);
    }

    .command-bar .input{
      min-width: 220px;
    }

    .terminal{
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(8,12,18,0.65);
      padding:10px;
      min-height:160px;
      height:100vh;
      display:flex;
      flex-direction:column;
      gap:8px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      overflow: hidden;
      min-height: 0;
    }

    .terminal-log{
      flex:1;
      overflow:auto;
      font-family: var(--mono);
      font-size:12px;
      color: var(--muted);
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:6px 4px 0;
      justify-content:flex-end;
      min-height: 0;
    }

    .terminal-line{
      display:flex;
      gap:6px;
      white-space:pre-wrap;
      max-width: 90%;
      padding:8px 10px;
      border-radius:12px;
      background: rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.08);
    }

    .terminal-line .tag{
      color: var(--accent-2);
    }

    .terminal-line.user{
      align-self:flex-end;
      background: rgba(102,163,255,0.2);
      border-color: rgba(102,163,255,0.45);
      color: #e6f0ff;
    }

    .terminal-line.ai{
      background: rgba(123,220,181,0.12);
      border-color: rgba(123,220,181,0.35);
      color: #e9fff4;
    }

    .terminal-line.error{
      background: rgba(255,120,120,0.12);
      border-color: rgba(255,120,120,0.4);
      color: #ffe3e3;
    }

    .terminal-input{
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px;
      border-radius:10px;
      background: rgba(10,16,24,0.8);
      border:1px solid rgba(255,255,255,0.06);
      position: sticky;
      bottom: 0;
    }

    .terminal-input .input{
      flex:1;
      min-width:0;
    }

    .form-tabs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-bottom:12px;
    }

    .form-tab{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding:6px 12px;
      border-radius:10px;
      font-size:12px;
      letter-spacing:0.4px;
      text-transform:uppercase;
      cursor:pointer;
      transition: all 0.12s ease;
    }

    .form-tab.active{
      color: var(--text);
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.18);
    }

    .form-panel{
      display:none;
    }

    .form-panel.active{
      display:block;
    }

    .section-tabs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-bottom:12px;
    }

    .section-tab{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding:5px 10px;
      border-radius:10px;
      font-size:11px;
      letter-spacing:0.4px;
      text-transform:uppercase;
      cursor:pointer;
      transition: all 0.12s ease;
    }

    .section-tab.active{
      color: var(--text);
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.18);
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    .section-tab.current{
      font-weight:700;
      box-shadow: 0 0 0 4px rgba(102,163,255,0.9);
      border-color: rgba(102,163,255,0.95);
      color: #e6f0ff;
    }

    .section-tab.visible{
      color: var(--accent);
      border-color: rgba(123,220,181,0.8);
      background: rgba(123,220,181,0.15);
    }

    .section-tab.hidden{
      color: #ffd27b;
      border-color: rgba(255,210,123,0.9);
      background: rgba(255,210,123,0.16);
    }

    .section-group{
      display:none;
    }

    .section-group.active{
      display:block;
    }

    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding:6px 12px;
      border-radius:10px;
      font-size:12px;
      letter-spacing:0.4px;
      text-transform:uppercase;
      cursor:pointer;
      transition: all 0.12s ease;
    }

    .btn:hover{
      border-color: rgba(102,163,255,0.6);
      background: rgba(102,163,255,0.15);
    }

    .btn.secondary{
      color: var(--muted);
    }

    .btn.save{
      border-color: rgba(123,220,181,0.6);
      color: var(--accent);
    }

    .btn.save.dirty{
      background: rgba(123,220,181,0.18);
      border-color: rgba(123,220,181,0.9);
      color: #dff7ee;
    }

    .preview{
      padding:18px 20px 22px;
      overflow:auto;
      min-height:0;
      flex:1;
    }

    .panel-card{
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.03);
      padding:12px;
      min-height:0;
    }

    .panel-title{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.8px;
      color: var(--muted);
      margin-bottom:10px;
    }

    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap:10px;
    }

    .form-stack{
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .section-card{
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      background: rgba(255,255,255,0.02);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .inline-row{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap:10px;
    }

    .row-actions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }

    .tiny{
      font-size:11px;
      color: var(--muted);
    }

    .badge-row{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }

    .badge-pill{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:0.6px;
      padding:3px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
    }

    .help{
      font-size:11px;
      color: var(--muted);
      line-height:1.4;
    }

    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:12px;
      color: var(--muted);
    }

    .input, textarea{
      width: 100%;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      font: inherit;
    }

    textarea{
      font-family: var(--mono);
      font-size:12px;
      min-height:300px;
      resize: vertical;
    }

    .panel-actions{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }

    .status{
      padding:8px 12px;
      border-radius:999px;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.8px;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }

    .status.ok{ background: rgba(123,220,181,0.12); color: var(--accent); border:1px solid rgba(123,220,181,0.35); }
    .status.warn{ background: rgba(255,205,123,0.12); color: #ffd27b; border:1px solid rgba(255,205,123,0.35); }
    .status.err{ background: rgba(255,123,123,0.12); color: var(--danger); border:1px solid rgba(255,123,123,0.35); }

    .empty{
      color: var(--muted);
      font-size:14px;
      padding:18px;
      border:1px dashed var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.02);
    }

    .modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 16px;
    }

    .modalBack.open{
      display:flex;
    }

    .modal{
      width: min(520px, 96vw);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 16px;
    }

    .modal h3{
      margin: 0 0 12px;
      font-size: 18px;
    }

    .modalGrid{
      display: grid;
      gap: 10px;
    }

    .modalActions{
      margin-top: 14px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .modalSmall{
      width: min(460px, 96vw);
    }

    .context-menu{
      position: fixed;
      z-index: 80;
      display: none;
      min-width: 140px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .context-menu button{
      width: 100%;
      border: none;
      background: transparent;
      color: var(--text);
      text-align: left;
      padding: 8px 10px;
      cursor: pointer;
    }

    .context-menu button:hover{
      background: rgba(102,163,255,0.15);
    }

    .table-editor{
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .table-editor th,
    .table-editor td{
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
    }

    .table-editor th{
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
      font-size: 11px;
      width: 1%;
      white-space: nowrap;
      position: relative;
    }

    .table-editor td{
      background: rgba(255,255,255,0.02);
      color: var(--text);
      min-width: 120px;
    }

    .col-resizer{
      position: absolute;
      top: 0;
      right: 0;
      width: 6px;
      height: 100%;
      cursor: col-resize;
      user-select: none;
    }

    .col-resizer::after{
      content: "";
      position: absolute;
      right: 2px;
      top: 20%;
      bottom: 20%;
      width: 2px;
      background: rgba(255,255,255,0.12);
    }

    .details-table{
      table-layout: auto;
      width: auto;
      display: inline-table;
    }

    .details-table td{
      min-width: 0;
    }

    .details-table td[data-col-key="label"]{
      width: 1%;
      white-space: nowrap;
      min-width: 0;
    }

    .description-table{
      table-layout: auto;
      width: auto;
      display: inline-table;
    }

    .description-table col.field-col{
      width: 1%;
    }

    .description-table col.value-col{
      width: auto;
    }

    .description-table th{
      width: 1%;
      white-space: nowrap;
    }

    .description-table td[data-col-key="seed"],
    .description-table td[data-col-key="generated"]{
      white-space: pre-wrap;
      min-height: 1.5in;
    }

    .meta-table{
      table-layout: auto;
      width: auto;
      display: inline-table;
    }

    .meta-table col.field-col{
      width: 1%;
    }

    .meta-table col.value-col{
      width: auto;
    }

    .meta-table tbody th{
      text-transform: none;
      letter-spacing: 0;
      font-size: 12px;
      width: 1%;
      white-space: nowrap;
      background: transparent;
      color: var(--text);
    }

    .meta-table td[contenteditable="true"]{
      background: transparent;
      padding: 6px 8px;
      min-height: 0;
      font-size: 12px;
      color: var(--text);
      outline: none;
    }

    .meta-table td{
      min-width: 0;
    }

    .meta-table td,
    .meta-table th{
      width: auto;
    }

    .nav-table input{
      background: transparent;
      border: none;
      padding: 0;
      min-height: 0;
      font-size: 12px;
      color: var(--text);
      width: 100%;
      outline: none;
    }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      aside{ order:2; }
      main{ order:1; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        Website Editor
        <span class="badge">Form + HTML</span>
      </div>
    </header>
    <div class="top-actions">
      <button class="btn secondary" id="helpBtn" type="button">Help</button>
      <button class="btn secondary" id="prefsBtn" type="button">Preferences</button>
    </div>

    <div class="layout" id="layoutRoot">
      <aside>
        <div class="sidebar-head">
          <div class="label">HTML Files</div>
          <div class="search">
            <input id="searchInput" type="search" placeholder="Filter by filename or title..." />
          </div>
          <div class="meta-row">
            <span class="pill" id="fileCount">Loading...</span>
            <span class="pill" id="dataStatus">Index: pending</span>
          </div>
        </div>
        <div class="sidebar-body">
          <div class="file-list" id="fileList"></div>
          <div id="terminalDockLeft"></div>
        </div>
      </aside>

      <main>
        <div class="preview-head">
          <div class="preview-title" id="previewTitle">Select an HTML file</div>
          <div class="preview-meta" id="previewMeta"></div>
        </div>
        <div class="preview">
          <div class="form-tabs" id="formTabs">
            <button class="form-tab active" data-tab="template" type="button">Template</button>
            <button class="form-tab" data-tab="page-meta" type="button">Page Meta</button>
            <button class="form-tab" data-tab="nav" type="button">Navigation Links</button>
            <button class="form-tab" data-tab="sections" type="button">Sections</button>
            <button class="form-tab" data-tab="collection" type="button">Collection</button>
            <button class="btn save" id="updateHtmlBtn" type="button">Update HTML</button>
          </div>
          <div class="form-panel active" id="panel-template"></div>
          <div class="form-panel" id="panel-page-meta"></div>
          <div class="form-panel" id="panel-nav"></div>
          <div class="form-panel" id="panel-sections"></div>
          <div class="form-panel" id="panel-collection"></div>
        </div>
      </main>
      <aside class="terminal-pane" id="terminalDockRight" aria-hidden="true"></aside>
    </div>
  </div>

  <div class="terminal" id="terminalPane">
    <div class="terminal-log" id="terminalLog"></div>
    <div class="terminal-input">
      <input class="input" id="terminalInput" type="text" placeholder="Ask the editor to draft or update a section..." />
      <button class="btn secondary" id="terminalSendBtn" type="button">Send</button>
    </div>
  </div>

  <div class="modalBack" id="prefsModal">
    <div class="modal">
      <h3>Preferences</h3>
      <div class="modalGrid">
        <label>
          HTML Folder
          <div class="row-actions">
            <button class="btn secondary" id="folderPickBtn" type="button">Choose Folder</button>
            <span class="tiny" id="folderLabel">No folder selected.</span>
          </div>
        </label>
        <label>
          Author
          <input class="input" id="authorInput" type="text" placeholder="Name" />
        </label>
        <label>
          Terminal Dock
          <select class="input" id="terminalDockInput">
            <option value="left-bottom">Left Pane (Lower Half)</option>
            <option value="right-pane">Right Pane</option>
          </select>
        </label>
        <div class="empty">
          Pick a folder to scan for HTML files. If none selected, defaults to draft/.
        </div>
      </div>
      <div class="modalActions">
        <button class="btn secondary" id="prefsCancel" type="button">Cancel</button>
        <button class="btn" id="prefsSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <div class="modalBack" id="sectionModal">
    <div class="modal modalSmall">
      <h3>Edit Section</h3>
      <div class="modalGrid">
        <label>
          Section ID
          <input class="input" id="sectionIdInput" type="text" />
        </label>
        <label>
          Tab Label
          <input class="input" id="sectionTabInput" type="text" />
        </label>
        <label>
          Section Title
          <input class="input" id="sectionTitleInput" type="text" />
        </label>
      </div>
      <div class="modalActions">
        <button class="btn secondary" id="sectionCancel" type="button">Cancel</button>
        <button class="btn" id="sectionSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <div class="context-menu" id="sectionContextMenu">
    <button type="button" id="sectionDeleteBtn">Delete Section</button>
  </div>

  <div class="context-menu" id="tableContextMenu">
    <button type="button" data-table-action="row-above">Add Row Above</button>
    <button type="button" data-table-action="row-below">Add Row Below</button>
    <button type="button" data-table-action="col-left">Add Column Left</button>
    <button type="button" data-table-action="col-right">Add Column Right</button>
    <button type="button" data-table-action="row-delete">Delete Row</button>
    <button type="button" data-table-action="col-delete">Delete Column</button>
    <button type="button" data-table-action="ai-suggest">AI Suggest</button>
  </div>

  <div class="context-menu" id="fileContextMenu">
    <button type="button" id="fileAddBtn">Add New File</button>
    <button type="button" id="fileDuplicateBtn">Duplicate File</button>
    <button type="button" id="fileAiLoadBtn">Load File in AI Context</button>
    <button type="button" id="fileDeleteBtn">Delete File</button>
  </div>

  <div class="modalBack" id="helpModal">
    <div class="modal">
      <h3>AI Command Help</h3>
      <div class="modalGrid">
        <div class="help">
          Use the terminal to run batch AI commands. Format:
          <div class="tiny" style="margin-top:6px;">@targets instruction</div>
        </div>
        <div class="help">Targets: @all, @current, @modified, @folder 00A, @match "probe", @list 1,3,7</div>
        <div class="help">Actions: rewrite Description Generated, update keywords, update slogan, update title, update h1, update description</div>
        <div class="help">Examples: @all rewrite Description Generated · @folder 00A update keywords · @match "probe" update slogan</div>
        <label>
          Command Builder
          <input class="input" id="helpCommandInput" type="text" placeholder='@folder 00A rewrite Description Generated' />
        </label>
      </div>
      <div class="modalActions">
        <button class="btn" id="helpClose" type="button">Close</button>
      </div>
    </div>
  </div>

  <script src="draft/html_index.js"></script>
  <script>
    const PREFS_KEY = "websiteEditorBaseDir";
    const TEMPLATE_KEY = "websiteEditorTemplate";
    const TERMINAL_DOCK_KEY = "websiteEditorTerminalDock";
    const AUTHOR_KEY = "websiteEditorAuthor";
    const LOCAL_PREFIX = "websiteEditorDraft::";
    const SAVE_DELAY = 600;
    const FS_DB = "websiteEditorFs";
    const FS_STORE = "handles";
    const VIEW_TAB_KEY = "websiteEditorViewTab";
    const VIEW_SECTION_TAB_KEY = "websiteEditorSectionSubtab";
    const COLUMN_WIDTH_KEY = "websiteEditorColumnWidths";
    const API_BASE_DEFAULT = "https://minipcb-github-io.vercel.app/api";
    const API_BASE_KEY = "websiteEditorApiBase";
    const AI_JOB_DELAY = 150;
    const AI_CANCEL_WORDS = ["stop", "cancel", "quit", "end now", "end", "abort", "halt"];

    const state = {
      entries: [],
      filtered: [],
      current: null,
      originalText: "",
      editorText: "",
      saveTimer: null,
      baseDir: "draft/",
      fileIndex: null,
      fsRootHandle: null,
      fsRootPath: "",
      aiContextPath: "",
      aiContextText: "",
      lastPartNo: "",
      aiQueue: [],
      aiRunning: false,
      aiCancelRequested: false,
      formState: null,
      template: null,
      editingSectionCard: null
    };

    let contextTargetTab = null;
    let contextTableCell = null;
    let contextTargetFile = null;

    const $ = (id) => document.getElementById(id);

    function normalizeSafeText(str){
      return String(str || "")
        .replace(/\u2013/g, "-")
        .replace(/\u2014/g, "--")
        .replace(/\u2018|\u2019/g, "'")
        .replace(/\u201C|\u201D/g, "\"")
        .replace(/\u2026/g, "...");
    }

    function escapeHtml(str){
      return normalizeSafeText(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    const defaultTemplate = () => {
      const scriptClose = "</" + "script>";
      return ({
        analyticsHtml:
`<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-9ZM2D6XGT2">${scriptClose}
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-9ZM2D6XGT2');
    ${scriptClose}`,
      defaultKeywords: "",
      defaultDescription: "",
      footerText: "© 2026 miniPCB. All rights reserved.",
      cssHrefBoard: "/styles.css",
      cssHrefCollection: "../styles.css",
      jsHrefBoard: "/js/minipcb.js",
      faviconHref: "/favicon.png",
      versionStamp: "v2",
      dateStamp: "2026-02-04"
      });
    };

    function loadTemplate(){
      try{
        const raw = localStorage.getItem(TEMPLATE_KEY);
        if(raw){
          return { ...defaultTemplate(), ...JSON.parse(raw) };
        }
      }catch(_){}
      return defaultTemplate();
    }

    function saveTemplate(next){
      state.template = { ...state.template, ...next };
      localStorage.setItem(TEMPLATE_KEY, JSON.stringify(state.template));
    }

    function getTerminalDock(){
      return localStorage.getItem(TERMINAL_DOCK_KEY) || "left-bottom";
    }

    function setTerminalDock(mode){
      localStorage.setItem(TERMINAL_DOCK_KEY, mode);
      applyTerminalDock(mode);
    }

    function applyTerminalDock(mode){
      const layout = $("layoutRoot");
      const leftDock = $("terminalDockLeft");
      const rightDock = $("terminalDockRight");
      const terminal = $("terminalPane");
      if(!layout || !leftDock || !rightDock || !terminal) return;

      if(mode === "right-pane"){
        layout.classList.add("with-terminal-pane");
        document.body.classList.remove("dock-left");
        rightDock.setAttribute("aria-hidden", "false");
        rightDock.appendChild(terminal);
      }else{
        layout.classList.remove("with-terminal-pane");
        document.body.classList.add("dock-left");
        rightDock.setAttribute("aria-hidden", "true");
        leftDock.appendChild(terminal);
      }
    }

    function setStatus(kind, message){
      const el = $("editStatus");
      if(!el) return;
      el.textContent = message;
      el.className = "status " + kind;
    }

    function setSaveDirty(_isDirty){}

    function setDataStatus(ok, message){
      const el = $("dataStatus");
      el.textContent = message;
      el.className = ok ? "pill status ok" : "pill status err";
    }

    function logTerminal(kind, message){
      const log = $("terminalLog");
      if(!log) return;
      const line = document.createElement("div");
      line.className = `terminal-line ${kind}`;
      const stamp = new Date().toLocaleTimeString();
      if(kind === "user"){
        line.innerHTML = `<span>${escapeHtml(message)}</span>`;
      }else{
        line.innerHTML = `<span class="tag">[${escapeHtml(kind)}]</span><span>${escapeHtml(stamp)} ${escapeHtml(message)}</span>`;
      }
      log.appendChild(line);
      log.scrollTop = log.scrollHeight;
    }

    function normalizeBaseDir(value){
      const trimmed = String(value || "").trim();
      if(!trimmed) return "";
      return trimmed.endsWith("/") ? trimmed : trimmed + "/";
    }

    function getAuthor(){
      return localStorage.getItem(AUTHOR_KEY) || "";
    }

    function setAuthor(value){
      localStorage.setItem(AUTHOR_KEY, String(value || ""));
    }

    function getApiBase(){
      return localStorage.getItem(API_BASE_KEY) || API_BASE_DEFAULT;
    }

    function getViewTab(){
      const stored = localStorage.getItem(VIEW_TAB_KEY) || "";
      if(stored === "content") return "page-meta";
      return stored || "template";
    }

    function setViewTab(value){
      localStorage.setItem(VIEW_TAB_KEY, String(value || "template"));
    }

    function getViewSectionTab(){
      return localStorage.getItem(VIEW_SECTION_TAB_KEY) || "";
    }

    function setViewSectionTab(value){
      localStorage.setItem(VIEW_SECTION_TAB_KEY, String(value || ""));
    }

    function getBaseDir(){
      const stored = localStorage.getItem(PREFS_KEY);
      return normalizeBaseDir(stored || state.baseDir);
    }

    function setBaseDir(next){
      const normalized = normalizeBaseDir(next);
      state.baseDir = normalized || "draft/";
      localStorage.setItem(PREFS_KEY, state.baseDir);
    }

    function idbOpen(){
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(FS_DB, 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(FS_STORE)) db.createObjectStore(FS_STORE);
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbGet(key){
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FS_STORE, "readonly");
        const store = tx.objectStore(FS_STORE);
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbSet(key, value){
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FS_STORE, "readwrite");
        const store = tx.objectStore(FS_STORE);
        const req = store.put(value, key);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function loadFolderRoot(){
      try{
        const handle = await idbGet("htmlRootHandle");
        if(handle) state.fsRootHandle = handle;
        const path = await idbGet("htmlRootPath");
        if(path) state.fsRootPath = String(path);
      }catch{}
    }

    function updateFolderLabel(){
      const label = $("folderLabel");
      if(!label) return;
      if(state.fsRootHandle){
        label.textContent = state.fsRootPath || state.fsRootHandle.name || "Folder selected.";
      }else{
        label.textContent = "No folder selected.";
      }
    }

    async function setFolderRoot(){
      if(!window.showDirectoryPicker){
        logTerminal("error", "Folder access not supported in this browser.");
        return;
      }
      try{
        const rootHandle = await window.showDirectoryPicker({ mode: "readwrite" });
        state.fsRootHandle = rootHandle;
        state.fsRootPath = rootHandle.name || "Selected folder";
        await idbSet("htmlRootHandle", rootHandle);
        await idbSet("htmlRootPath", state.fsRootPath);
        updateFolderLabel();
        await ensureIndexLoaded();
        state.entries = listFromIndex(state.baseDir);
        state.filtered = state.entries.slice();
        $("fileCount").textContent = `${state.filtered.length} files`;
        setDataStatus(true, "Index: folder");
        renderList();
        logTerminal("system", "Folder selected");
      }catch{
        logTerminal("warn", "Folder selection canceled");
      }
    }

    function useFileSystemStore(){
      return !!state.fsRootHandle && !!window.showDirectoryPicker;
    }

    async function ensureFolderHandle(mode){
      if(!state.fsRootHandle) return null;
      try{
        const perm = await state.fsRootHandle.queryPermission({ mode });
        if(perm === "granted") return state.fsRootHandle;
        const req = await state.fsRootHandle.requestPermission({ mode });
        return req === "granted" ? state.fsRootHandle : null;
      }catch{
        return null;
      }
    }

    async function ensureFolderHandleRead(){
      return ensureFolderHandle("read");
    }

    async function ensureFolderHandleWrite(){
      return ensureFolderHandle("readwrite");
    }

    function loadDraft(path){
      return localStorage.getItem(LOCAL_PREFIX + path);
    }

    function saveDraft(path, text){
      localStorage.setItem(LOCAL_PREFIX + path, text);
    }

    function clearDraft(path){
      localStorage.removeItem(LOCAL_PREFIX + path);
    }

    function listFromIndex(baseDir){
      if(state.fileIndex && state.fileIndex.length){
        return state.fileIndex.slice().sort((a, b) => a.rel.localeCompare(b.rel));
      }
      const src = Array.isArray(window.DRAFT_HTML_INDEX) ? window.DRAFT_HTML_INDEX : [];
      return src
        .filter(path => typeof path === "string" && path.toLowerCase().endsWith(".html"))
        .map(path => {
          const rel = path.replace(/^\.\//, "");
          return {
            rel,
            url: rel,
            path: baseDir + rel,
            title: rel
          };
        })
        .sort((a, b) => a.rel.localeCompare(b.rel));
    }

    async function ensureIndexLoaded(){
      if(state.fileIndex && state.fileIndex.length) return true;
      if(useFileSystemStore()){
        const ok = await loadFileIndexFromFs();
        return ok && state.fileIndex && state.fileIndex.length;
      }
      if(Array.isArray(window.DRAFT_HTML_INDEX) && window.DRAFT_HTML_INDEX.length) return true;
      const candidate = `${state.baseDir}html_index.js`;
      try{
        const res = await fetch(candidate, { cache: "no-store" });
        if(!res.ok) throw new Error(`Failed to fetch ${candidate}`);
        const text = await res.text();
        const loader = new Function(text + "\nreturn window.DRAFT_HTML_INDEX;");
        const list = loader();
        if(Array.isArray(list) && list.length){
          return true;
        }
      }catch(err){
        logTerminal("error", err?.message || "Failed to load html_index.js");
      }
      return false;
    }

    async function loadFileIndexFromFs(){
      const root = await ensureFolderHandleRead();
      if(!root) return false;
      const items = [];
      const walk = async (dirHandle, relBase) => {
        for await (const [name, handle] of dirHandle.entries()){
          if(handle.kind === "file"){
            if(name.toLowerCase().endsWith(".html")){
              const rel = relBase ? `${relBase}/${name}` : name;
              items.push({
                rel,
                url: rel,
                path: rel,
                title: rel,
                name,
                fileHandle: handle,
                dirHandle
              });
            }
          }else if(handle.kind === "directory"){
            const nextBase = relBase ? `${relBase}/${name}` : name;
            await walk(handle, nextBase);
          }
        }
      };
      await walk(root, "");
      state.fileIndex = items.sort((a, b) => a.rel.localeCompare(b.rel));
      return true;
    }

    function renderList(){
      const list = $("fileList");
      list.innerHTML = "";
      if(!state.filtered.length){
        list.innerHTML = '<div class="empty">No files match the filter.</div>';
        return;
      }

      state.filtered.forEach(entry => {
        const item = document.createElement("div");
        item.className = "file-item" + (state.current && state.current.url === entry.url ? " active" : "");
        const draft = loadDraft(entry.path);
        let isDirty = false;
        if(draft){
          if(state.current && state.current.path === entry.path){
            isDirty = state.editorText !== state.originalText;
          }else{
            isDirty = true;
          }
        }
        item.dataset.rel = entry.rel || entry.path || entry.url || "";
        item.innerHTML = `
          <div class="name">${escapeHtml(entry.rel || entry.path)}</div>
          ${isDirty ? `<div class="tag">Modified</div>` : ""}
        `;
        item.addEventListener("click", () => selectEntry(entry));
        list.appendChild(item);
      });
    }

    function filterList(query){
      const q = query.trim().toLowerCase();
      if(!q){
        state.filtered = state.entries.slice();
      }else{
        state.filtered = state.entries.filter(e => {
          return (e.rel || "").toLowerCase().includes(q);
        });
      }
      $("fileCount").textContent = `${state.filtered.length} files`;
      renderList();
    }

    function updatePreviewMeta(entry){
      const meta = $("previewMeta");
      if(!entry){
        meta.innerHTML = "";
        return;
      }
      const parts = [
        `<span class="pill">${escapeHtml(entry.path)}</span>`
      ];
      meta.innerHTML = parts.join("");
    }

    function generateBoardHtml(formData, template){
      const tpl = template || defaultTemplate();
      const scriptClose = "</" + "script>";
      const nav = formData.nav.map(item => `  <li><a href="${escapeHtml(item.href)}">${escapeHtml(item.text)}</a></li>`).join("\n");
      const tabs = formData.sections.filter(section => section.tabLabel && !section.hidden);
      const activeTab = formData.sections.find(section => section.active && section.tabLabel && !section.hidden);
      const firstTabId = activeTab
        ? activeTab.id
        : (tabs.length ? tabs[0].id : (formData.sections[0] ? formData.sections[0].id : ""));
      const tabButtons = tabs.map(section => {
        const active = section.id === firstTabId ? " active" : "";
        const selected = section.id === firstTabId ? "true" : "false";
        return `  <button aria-controls="${escapeHtml(section.id)}" aria-selected="${selected}" class="tab${active}" data-tab="${escapeHtml(section.id)}" role="tab" type="button">${escapeHtml(section.tabLabel)}</button>`;
      }).join("\n");

      const sectionsHtml = formData.sections.map(section => {
        const active = section.id === firstTabId ? " active" : "";
        const hiddenAttr = section.hidden ? ' data-hidden="true"' : "";
        if(section.type === "details"){
          const rows = (section.rows || [])
            .map(row => `<p><strong>${escapeHtml(row.label)}:</strong> ${escapeHtml(row.value)}</p>`)
            .join("\n");
          return `<div aria-hidden="${section.id === firstTabId ? "false" : "true"}" class="tab-content${active}"${hiddenAttr} id="${escapeHtml(section.id)}">\n<h2>${escapeHtml(section.title)}</h2>\n${rows}\n</div>`;
        }
        if(section.type === "images"){
          const images = (section.images || []).map(img => {
            const full = img.full ? ` data-full="${escapeHtml(img.full)}"` : "";
            return `<img alt="${escapeHtml(img.alt)}" class="zoomable" loading="lazy" src="${escapeHtml(img.src)}"${full} onclick="openLightbox(this)"/>`;
          }).join("\n");
          return `<div aria-hidden="${section.id === firstTabId ? "false" : "true"}" class="tab-content${active}"${hiddenAttr} id="${escapeHtml(section.id)}">\n<h2>${escapeHtml(section.title)}</h2>\n<div class="lightbox-container">\n${images}\n</div>\n</div>`;
        }
        if(section.type === "downloads"){
          const items = (section.items || []).map(item => {
            return `  <li><a href="${escapeHtml(item.href)}" rel="noopener noreferrer" target="_blank">${escapeHtml(item.label)}</a></li>`;
          }).join("\n");
          return `<div aria-hidden="${section.id === firstTabId ? "false" : "true"}" class="tab-content${active}"${hiddenAttr} id="${escapeHtml(section.id)}">\n<h2>${escapeHtml(section.title)}</h2>\n<ul class="download-list">\n${items}\n</ul>\n</div>`;
        }
        if(section.type === "videos"){
          const items = (section.videos || []).map(video => {
            return `<div class="video-wrapper">
    <iframe src="${escapeHtml(video.src)}" title="${escapeHtml(video.title || "YouTube video player")}" width="${escapeHtml(video.width || "560")}" height="${escapeHtml(video.height || "315")}" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen frameborder="0"></iframe>
  </div>`;
          }).join("\n");
          return `<div aria-hidden="${section.id === firstTabId ? "false" : "true"}" class="tab-content${active}"${hiddenAttr} id="${escapeHtml(section.id)}">\n<h2>${escapeHtml(section.title)}</h2>\n${items}\n</div>`;
        }
        if(section.type === "revisions"){
          const rows = (section.rows || []).map(row => {
            return `<tr>
<td>${escapeHtml(row.date)}</td>
<td>${escapeHtml(row.rev)}</td>
<td>${escapeHtml(row.desc)}</td>
<td>${escapeHtml(row.by)}</td>
</tr>`;
          }).join("\n");
          return `<div aria-hidden="${section.id === firstTabId ? "false" : "true"}" class="tab-content${active}"${hiddenAttr} id="${escapeHtml(section.id)}">\n<h2>${escapeHtml(section.title)}</h2>\n<table class="revisions-table"><thead><tr><th>Date</th><th>Revision</th><th>Description</th><th>By</th></tr></thead><tbody>\n${rows}\n</tbody></table>\n</div>`;
        }
        if(section.type === "ai-seeds"){
          const jsonText = section.jsonText || "{}";
          return `<div aria-hidden="true" class="tab-content" data-hidden="true" id="${escapeHtml(section.id)}">\n<script id="ai-seeds-json" type="application/json">${jsonText}${scriptClose}\n</div>`;
        }
        const body = section.bodyHtml || "";
        return `<div aria-hidden="${section.id === firstTabId ? "false" : "true"}" class="tab-content${active}"${hiddenAttr} id="${escapeHtml(section.id)}">\n<h2>${escapeHtml(section.title)}</h2>\n${body}\n</div>`;
      }).join("\n\n");

      const keywords = formData.meta.keywords || tpl.defaultKeywords || "";
      const description = formData.meta.description || tpl.defaultDescription || "";
      const headStamp = tpl.versionStamp || tpl.dateStamp ? `<!-- Generated: ${escapeHtml(tpl.dateStamp || "")} | Version: ${escapeHtml(tpl.versionStamp || "")} -->` : "";
      const analytics = tpl.analyticsHtml ? tpl.analyticsHtml + "\n" : "";
      const cssHref = tpl.cssHrefBoard || "/styles.css";
      const jsHref = tpl.jsHrefBoard || "";
      const faviconHref = tpl.faviconHref || "/favicon.png";
      const footerText = tpl.footerText || "© 2026 miniPCB. All rights reserved.";

      return `<!DOCTYPE html>
<html lang="en">
<head>
${analytics}${headStamp}
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>${escapeHtml(formData.meta.title || "")}</title>
<link href="${escapeHtml(cssHref)}" rel="stylesheet"/>
<link href="${escapeHtml(faviconHref)}" rel="icon" type="image/png"/>
<meta content="${escapeHtml(keywords)}" name="keywords"/>
<meta content="${escapeHtml(description)}" name="description"/>
</head>
<body>
<nav>
<div class="nav-container">
<ul class="nav-links">
${nav}
</ul>
</div>
</nav>
<header>
<h1>${escapeHtml(formData.meta.h1 || "")}</h1>
<p class="slogan">${escapeHtml(formData.meta.slogan || "")}</p>
</header>
<main>
<div class="tab-container">
<div aria-label="Sections" class="tabs" role="tablist">
${tabButtons}
</div>

${sectionsHtml}
</div>
</main>
<footer>
      ${escapeHtml(footerText)}
    </footer>
<div aria-hidden="true" aria-label="Image viewer" id="lightbox" role="dialog">
<img alt="Expanded image" id="lightbox-img"/>
</div>
${jsHref ? `<script src="${escapeHtml(jsHref)}">${scriptClose}` : ""}
</body>
</html>`;
    }

    function generateCollectionHtml(formData, template){
      const tpl = template || defaultTemplate();
      const nav = formData.nav.map(item => `  <li><a href="${escapeHtml(item.href)}">${escapeHtml(item.text)}</a></li>`).join("\n");
      const rows = (formData.rows || []).map(row => {
        return `<tr>
<td>${escapeHtml(row.partNo || "")}</td>
<td><a href="${escapeHtml(row.href || "")}">${escapeHtml(row.title || "")}</a></td>
<td>${escapeHtml(row.pieces || "")}</td>
</tr>`;
      }).join("\n");

      const keywords = formData.meta.keywords || tpl.defaultKeywords || "";
      const headStamp = tpl.versionStamp || tpl.dateStamp ? `<!-- Generated: ${escapeHtml(tpl.dateStamp || "")} | Version: ${escapeHtml(tpl.versionStamp || "")} -->` : "";
      const analytics = tpl.analyticsHtml ? tpl.analyticsHtml + "\n" : "";
      const cssHref = tpl.cssHrefCollection || "../styles.css";
      const faviconHref = tpl.faviconHref || "/favicon.png";
      const footerText = tpl.footerText || "© 2026 miniPCB. All rights reserved.";

      return `<!DOCTYPE html>
<html lang="en">
<head>
${analytics}${headStamp}
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>${escapeHtml(formData.meta.title || "")}</title>
<link href="${escapeHtml(cssHref)}" rel="stylesheet"/>
<link href="${escapeHtml(faviconHref)}" rel="icon" type="image/png"/>
<meta content="${escapeHtml(keywords)}" name="keywords"/>
</head>
<body>
<nav>
<div class="nav-container">
<ul class="nav-links">
${nav}
</ul>
</div>
</nav>
<header>
<h1>${escapeHtml(formData.meta.h1 || "")}</h1>
</header>
<main>
<section>
<table>
<thead>
<tr>
<th>Part No</th>
<th>Title</th>
<th>Pieces per Panel</th>
</tr>
</thead>
<tbody>
${rows}
</tbody>
</table>
</section>
</main>
<footer>
   ${escapeHtml(footerText)}
  </footer>
</body>
</html>`;
    }

    function extractBoardFromHtml(doc){
      const metaDesc = doc.querySelector('meta[name="description"]');
      const metaKeywords = doc.querySelector('meta[name="keywords"]');
      const h1 = doc.querySelector("header h1") || doc.querySelector("h1");
      const slogan = doc.querySelector("header .slogan") || doc.querySelector(".slogan");

      const navLinks = Array.from(doc.querySelectorAll(".nav-links a")).map(link => ({
        text: link.textContent.trim(),
        href: link.getAttribute("href") || ""
      }));

      const tabs = Array.from(doc.querySelectorAll(".tabs .tab")).map(btn => {
        const onclick = btn.getAttribute("onclick") || "";
        const match = onclick.match(/showTab\('([^']+)'/);
        return {
          id: match ? match[1] : btn.dataset.tab || "",
          label: btn.textContent.trim()
        };
      });
      const tabById = new Map(tabs.map(tab => [tab.id, tab.label]));
      let activeTabId = "";
      const activeTabBtn = doc.querySelector(".tabs .tab.active") || doc.querySelector('.tabs .tab[aria-selected="true"]');
      if(activeTabBtn){
        const onclick = activeTabBtn.getAttribute("onclick") || "";
        const match = onclick.match(/showTab\('([^']+)'/);
        activeTabId = match ? match[1] : activeTabBtn.dataset.tab || "";
      }
      if(!activeTabId){
        const activeContent = doc.querySelector(".tab-content.active");
        if(activeContent) activeTabId = activeContent.id || "";
      }

      const sections = Array.from(doc.querySelectorAll(".tab-content")).map((section, idx) => {
        const id = section.id || `section-${idx + 1}`;
        const hidden = section.getAttribute("data-hidden") === "true";
        const h2 = section.querySelector("h2");
        const title = h2 ? h2.textContent.trim() : id;
        const tabLabel = tabById.get(id) || "";
        const active = !!(activeTabId && id === activeTabId);
        if(id === "description"){
          const seedHeading = Array.from(section.querySelectorAll("h3")).find(h3 => /seed/i.test(h3.textContent || ""));
          const generatedHeading = Array.from(section.querySelectorAll("h3")).find(h3 => /generated/i.test(h3.textContent || ""));
          const seedPara = seedHeading ? seedHeading.nextElementSibling : null;
          const generatedBlock = generatedHeading ? (generatedHeading.nextElementSibling || null) : null;
          const seedText = seedPara ? seedPara.textContent.trim() : "";
          let generatedText = "";
          if(generatedBlock){
            generatedText = generatedBlock.textContent.trim();
          }else{
            const clone = section.cloneNode(true);
            const cloneH2 = clone.querySelector("h2");
            if(cloneH2) cloneH2.remove();
            generatedText = clone.textContent.trim();
          }
          return { id, hidden, title, tabLabel, active, type: "html", seedText, generatedText };
        }
        if(id === "details"){
          const rows = Array.from(section.querySelectorAll("p")).map(p => {
            const strong = p.querySelector("strong");
            if(!strong) return null;
            const label = strong.textContent.replace(/:$/, "").trim();
            const value = p.textContent.replace(strong.textContent, "").trim();
            return { label, value };
          }).filter(Boolean);
          return { id, hidden, title, tabLabel, active, type: "details", rows };
        }

        if(id === "downloads" || section.querySelector(".download-list")){
          const items = Array.from(section.querySelectorAll(".download-list a")).map(link => ({
            label: link.textContent.trim(),
            href: link.getAttribute("href") || ""
          }));
          return { id, hidden, title, tabLabel, active, type: "downloads", items };
        }

        if(id === "revisions" || section.querySelector(".revisions-table")){
          const rows = Array.from(section.querySelectorAll("tbody tr")).map(row => {
            const cells = row.querySelectorAll("td");
            return {
              date: cells[0] ? cells[0].textContent.trim() : "",
              rev: cells[1] ? cells[1].textContent.trim() : "",
              desc: cells[2] ? cells[2].textContent.trim() : "",
              by: cells[3] ? cells[3].textContent.trim() : ""
            };
          });
          return { id, hidden, title, tabLabel, active, type: "revisions", rows };
        }

        if(id === "ai-seeds" || section.querySelector("#ai-seeds-json")){
          const script = section.querySelector("#ai-seeds-json");
          const text = script ? script.textContent.trim() : "{}";
          return { id, hidden, title, tabLabel, active, type: "ai-seeds", jsonText: text || "{}" };
        }

        const videos = Array.from(section.querySelectorAll("iframe"));
        if(id === "videos" || id === "resources" || videos.length){
          return {
            id,
            hidden,
            title,
            tabLabel,
            active,
            type: "videos",
            videos: videos.map(frame => ({
              src: frame.getAttribute("src") || "",
              title: frame.getAttribute("title") || "",
              width: frame.getAttribute("width") || "560",
              height: frame.getAttribute("height") || "315"
            }))
          };
        }

        const images = Array.from(section.querySelectorAll("img"));
        if(images.length){
          return {
            id,
            hidden,
            title,
            tabLabel,
            active,
            type: "images",
            images: images.map(img => ({
              src: img.getAttribute("src") || "",
              alt: img.getAttribute("alt") || "",
              full: img.getAttribute("data-full") || ""
            }))
          };
        }

        const clone = section.cloneNode(true);
        const cloneH2 = clone.querySelector("h2");
        if(cloneH2) cloneH2.remove();
        return {
          id,
          hidden,
          title,
          tabLabel,
          active,
          type: "html",
          bodyHtml: clone.innerHTML.trim()
        };
      });

      return {
        type: "board",
        meta: {
          title: doc.title || "",
          description: metaDesc ? metaDesc.getAttribute("content") || "" : "",
          keywords: metaKeywords ? metaKeywords.getAttribute("content") || "" : "",
          h1: h1 ? h1.textContent.trim() : "",
          slogan: slogan ? slogan.textContent.trim() : ""
        },
        nav: navLinks,
        sections
      };
    }

    function extractCollectionFromHtml(doc){
      const metaKeywords = doc.querySelector('meta[name="keywords"]');
      const h1 = doc.querySelector("header h1") || doc.querySelector("h1");
      const navLinks = Array.from(doc.querySelectorAll(".nav-links a")).map(link => ({
        text: link.textContent.trim(),
        href: link.getAttribute("href") || ""
      }));

      const rows = Array.from(doc.querySelectorAll("tbody tr")).map(row => {
        const cells = row.querySelectorAll("td");
        const partNo = cells[0] ? cells[0].textContent.trim() : "";
        const titleLink = cells[1] ? cells[1].querySelector("a") : null;
        const title = titleLink ? titleLink.textContent.trim() : (cells[1] ? cells[1].textContent.trim() : "");
        const href = titleLink ? titleLink.getAttribute("href") || "" : "";
        const pieces = cells[2] ? cells[2].textContent.trim() : "";
        return { partNo, title, href, pieces };
      });

      return {
        type: "collection",
        meta: {
          title: doc.title || "",
          description: "",
          keywords: metaKeywords ? metaKeywords.getAttribute("content") || "" : "",
          h1: h1 ? h1.textContent.trim() : "",
          slogan: ""
        },
        nav: navLinks,
        rows
      };
    }

    function extractFormFromHtml(html){
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");
      const isBoard = !!doc.querySelector(".tab-container .tab-content");
      if(isBoard){
        return extractBoardFromHtml(doc);
      }
      return extractCollectionFromHtml(doc);
    }

    function extractTemplateFromHtml(html){
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");
      const headScripts = Array.from(doc.querySelectorAll("head script"));
      const analyticsScripts = headScripts.filter(script => {
        const src = script.getAttribute("src") || "";
        const text = script.textContent || "";
        return src.includes("googletagmanager.com/gtag/js") || text.includes("gtag('config'");
      });
      const analyticsHtml = analyticsScripts.map(s => s.outerHTML).join("\n");

      const stylesheet = doc.querySelector('link[rel="stylesheet"]');
      const cssHref = stylesheet ? stylesheet.getAttribute("href") || "" : "";
      const favicon = doc.querySelector('link[rel="icon"]');
      const faviconHref = favicon ? favicon.getAttribute("href") || "" : "";

      const scripts = Array.from(doc.querySelectorAll("script[src]"));
      const jsHref = scripts.length ? scripts[scripts.length - 1].getAttribute("src") || "" : "";

      const footer = doc.querySelector("footer");
      const footerText = footer ? footer.textContent.trim().replace(/\s+/g, " ") : "";

      const next = { ...defaultTemplate() };
      if(analyticsHtml) next.analyticsHtml = analyticsHtml;
      if(cssHref){
        if(cssHref.startsWith("../")) next.cssHrefCollection = cssHref;
        else next.cssHrefBoard = cssHref;
      }
      if(faviconHref) next.faviconHref = faviconHref;
      if(jsHref) next.jsHrefBoard = jsHref;
      if(footerText) next.footerText = footerText;
      return next;
    }

    function syncFormInputs(html){
      state.formState = extractFormFromHtml(html);
      renderForm(state.formState);
      state.lastPartNo = readPartNoFromForm();
    }

    function renderForm(data){
      const panelTemplate = $("panel-template");
      const panelPageMeta = $("panel-page-meta");
      const panelNav = $("panel-nav");
      const panelSections = $("panel-sections");
      const panelCollection = $("panel-collection");
      [panelTemplate, panelPageMeta, panelNav, panelSections, panelCollection].forEach(panel => {
        if(panel) panel.innerHTML = "";
      });

      const templateCard = document.createElement("div");
      templateCard.className = "panel-card";
      templateCard.innerHTML = `
        <div class="panel-title">Template Editor</div>
        <div class="help">Global defaults and includes used when Update generates full HTML.</div>
        <div class="form-grid">
          <label>Analytics HTML
            <textarea class="input" data-field="tpl-analytics" placeholder="Paste analytics script(s)..."></textarea>
          </label>
          <label>Default Keywords
            <input class="input" data-field="tpl-default-keywords" type="text" placeholder="Default keywords" />
          </label>
          <label>Default Description
            <input class="input" data-field="tpl-default-description" type="text" placeholder="Default description" />
          </label>
          <label>Footer Text
            <input class="input" data-field="tpl-footer" type="text" placeholder="© 2026 miniPCB. All rights reserved." />
          </label>
          <label>Stylesheet (Board)
            <input class="input" data-field="tpl-css-board" type="text" placeholder="/styles.css" />
          </label>
          <label>Stylesheet (Collection)
            <input class="input" data-field="tpl-css-collection" type="text" placeholder="../styles.css" />
          </label>
          <label>Script (Board)
            <input class="input" data-field="tpl-js-board" type="text" placeholder="/js/minipcb.js" />
          </label>
          <label>Favicon Href
            <input class="input" data-field="tpl-favicon" type="text" placeholder="/favicon.png" />
          </label>
          <label>Version Stamp
            <input class="input" data-field="tpl-version" type="text" placeholder="v2" />
          </label>
          <label>Date Stamp
            <input class="input" data-field="tpl-date" type="text" placeholder="2026-02-04" />
          </label>
        </div>
        <div class="row-actions">
          <button class="btn secondary" data-action="tpl-load" type="button">Load From File</button>
          <button class="btn" data-action="tpl-save" type="button">Save Template</button>
        </div>
      `;
      panelTemplate.appendChild(templateCard);

      const metaCard = document.createElement("div");
      metaCard.className = "panel-card";
      metaCard.innerHTML = `
        <div class="panel-title">Page Meta</div>
        <table class="table-editor meta-table" data-meta-table="true">
          <colgroup>
            <col class="field-col" />
            <col class="value-col" />
          </colgroup>
          <thead>
            <tr>
              <th>Field</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>1. Title</th>
          <td data-meta-key="title" data-col-key="title" contenteditable="true"></td>
            </tr>
            <tr>
              <th>2. Header H1</th>
          <td data-meta-key="h1" data-col-key="h1" contenteditable="true"></td>
            </tr>
            <tr>
              <th>3. Slogan</th>
          <td data-meta-key="slogan" data-col-key="slogan" contenteditable="true"></td>
            </tr>
            <tr>
              <th>4. Meta Keywords</th>
          <td data-meta-key="keywords" data-col-key="keywords" contenteditable="true"></td>
            </tr>
            <tr>
              <th>5. Meta Description</th>
          <td data-meta-key="description" data-col-key="description" contenteditable="true"></td>
            </tr>
          </tbody>
        </table>
      `;
      panelPageMeta.appendChild(metaCard);

      const navCard = document.createElement("div");
      navCard.className = "panel-card";
      navCard.innerHTML = `
        <div class="panel-title">Navigation Links</div>
        <table class="table-editor nav-table" data-nav-table="true">
          <thead>
            <tr>
              <th>Link Text</th>
              <th>Link Href</th>
            </tr>
          </thead>
          <tbody data-nav-list></tbody>
        </table>
        <div class="row-actions">
          <button class="btn secondary" data-action="add-nav" type="button">Add Link</button>
        </div>
      `;
      panelNav.appendChild(navCard);
      const navDatalist = document.createElement("datalist");
      navDatalist.id = "navHrefOptions";
      panelNav.appendChild(navDatalist);


      if(data.type === "board"){
        const sectionsWrap = document.createElement("div");
        sectionsWrap.className = "panel-card";
        sectionsWrap.innerHTML = `
          <div class="section-tabs" id="sectionTabs"></div>
        `;
        panelSections.appendChild(sectionsWrap);

        const sectionsStack = document.createElement("div");
        sectionsStack.className = "form-stack";
        sectionsWrap.appendChild(sectionsStack);

        const tabsRow = sectionsWrap.querySelector("#sectionTabs");
        const groups = new Map();

        const defaults = [
          { id: "details", title: "Details", tabLabel: "Details", hidden: false, type: "details", rows: [] },
          { id: "description", title: "Description", tabLabel: "Description", hidden: false, type: "html", bodyHtml: "<p>Describe this board.</p>" },
          { id: "schematic", title: "Schematic", tabLabel: "Schematic", hidden: false, type: "images", images: [] },
          { id: "layout", title: "Layout", tabLabel: "Layout", hidden: false, type: "images", images: [] },
          { id: "videos", title: "Videos", tabLabel: "Videos", hidden: false, type: "videos", videos: [] },
          { id: "downloads", title: "Downloads", tabLabel: "Downloads", hidden: false, type: "downloads", items: [] },
          { id: "resources", title: "Additional Resources", tabLabel: "Additional Resources", hidden: false, type: "videos", videos: [] },
          { id: "revisions", title: "Revision History", tabLabel: "Revision History", hidden: false, type: "revisions", rows: [] },
          { id: "ai-seeds", title: "ai-seeds", tabLabel: "ai-seeds", hidden: true, type: "ai-seeds", jsonText: "{}" }
        ];

        const existing = new Map((data.sections || []).map(section => [section.id, section]));
        data.sections = defaults.map(def => existing.get(def.id) || def).concat(
          (data.sections || []).filter(section => !defaults.find(def => def.id === section.id))
        );
        if(!(data.sections || []).some(section => section.active) && data.sections.length){
          data.sections[0].active = true;
        }
        const activeId = (data.sections || []).find(section => section.active)?.id || (data.sections[0] ? data.sections[0].id : "");

        (data.sections || []).forEach((section, idx) => {
          const tabLabel = section.tabLabel || section.title || section.id;
          const tabBtn = document.createElement("button");
          tabBtn.className = "section-tab" + (section.id === activeId ? " active" : "") + (section.active ? " current" : "");
          tabBtn.type = "button";
          tabBtn.dataset.subtab = section.id;
          tabBtn.textContent = tabLabel;
          tabsRow.appendChild(tabBtn);

          const group = document.createElement("div");
          group.className = "section-group" + (section.id === activeId ? " active" : "");
          group.dataset.subtab = section.id;
          group.dataset.visible = section.hidden ? "false" : "true";
          sectionsStack.appendChild(group);
          groups.set(section.id, group);

          const card = document.createElement("div");
          card.className = "section-card";
          card.dataset.sectionId = section.id;
          card.dataset.sectionType = section.type;
          card.dataset.sectionTitle = section.title || "";
          card.dataset.sectionTab = section.tabLabel || "";
          card.dataset.sectionActive = section.active ? "true" : "false";
          card.innerHTML = `
            <div class="badge-row">
              <span class="badge-pill">${escapeHtml(section.id)}</span>
              ${section.tabLabel ? `<span class="badge-pill">${escapeHtml(section.tabLabel)}</span>` : ""}
              ${section.title ? `<span class="badge-pill">${escapeHtml(section.title)}</span>` : ""}
            </div>
          `;

          if(section.type === "details"){
            const table = buildEditableTable([
              { key: "label", label: "Label" },
              { key: "value", label: "Value" }
            ], (section.rows || []).map(row => ({
              label: row.label || "",
              value: row.value || ""
            })));
            table.classList.add("details-table");
            table.dataset.tableType = "details";
            card.appendChild(table);
            const actions = document.createElement("div");
            actions.className = "row-actions";
            actions.innerHTML = `<button class="btn secondary" data-action="table-add-row" type="button">Add Row</button>`;
            card.appendChild(actions);
          }else if(section.type === "images"){
            const rows = document.createElement("div");
            rows.className = "form-stack";
            rows.dataset.imageList = "true";
            (section.images || []).forEach(img => {
              const rowEl = document.createElement("div");
              rowEl.className = "inline-row";
              rowEl.dataset.imageRow = "true";
              rowEl.innerHTML = `
                <label>Image Src<input class="input" data-field="image-src" type="text" value="${escapeHtml(img.src)}"></label>
                <label>Alt Text<input class="input" data-field="image-alt" type="text" value="${escapeHtml(img.alt)}"></label>
                <label>Full Src<input class="input" data-field="image-full" type="text" value="${escapeHtml(img.full || "")}"></label>
              `;
              rows.appendChild(rowEl);
            });
            card.appendChild(rows);
            const actions = document.createElement("div");
            actions.className = "row-actions";
            actions.innerHTML = `
              <button class="btn secondary" data-action="add-image" type="button">Add Image</button>
            `;
            card.appendChild(actions);
          }else if(section.type === "downloads"){
            const table = buildEditableTable([
              { key: "label", label: "Label" },
              { key: "href", label: "Href" }
            ], (section.items || []).map(item => ({
              label: item.label || "",
              href: item.href || ""
            })));
            table.dataset.tableType = "downloads";
            card.appendChild(table);
            const actions = document.createElement("div");
            actions.className = "row-actions";
            actions.innerHTML = `<button class="btn secondary" data-action="table-add-row" type="button">Add Row</button>`;
            card.appendChild(actions);
          }else if(section.type === "videos"){
            const table = buildEditableTable([
              { key: "src", label: "URL" },
              { key: "title", label: "Title" },
              { key: "width", label: "Width" },
              { key: "height", label: "Height" }
            ], (section.videos || []).map(video => ({
              src: video.src || "",
              title: video.title || "",
              width: video.width || "",
              height: video.height || ""
            })));
            table.dataset.tableType = "videos";
            card.appendChild(table);
            const actions = document.createElement("div");
            actions.className = "row-actions";
            actions.innerHTML = `<button class="btn secondary" data-action="table-add-row" type="button">Add Row</button>`;
            card.appendChild(actions);
          }else if(section.type === "revisions"){
            const table = buildEditableTable([
              { key: "date", label: "Date" },
              { key: "rev", label: "Revision" },
              { key: "desc", label: "Description" },
              { key: "by", label: "By" }
            ], (section.rows || []).map(row => ({
              date: row.date || "",
              rev: row.rev || "",
              desc: row.desc || "",
              by: row.by || ""
            })));
            table.dataset.tableType = "revisions";
            card.appendChild(table);
            const actions = document.createElement("div");
            actions.className = "row-actions";
            actions.innerHTML = `<button class="btn secondary" data-action="table-add-row" type="button">Add Row</button>`;
            card.appendChild(actions);
          }else if(section.type === "ai-seeds"){
            const label = document.createElement("label");
            label.innerHTML = `AI Seeds JSON<textarea class="input" data-field="ai-seeds">${escapeHtml(section.jsonText || "{}")}</textarea>`;
            card.appendChild(label);
          }else{
            if(section.id === "description"){
              const table = document.createElement("table");
              table.className = "table-editor description-table";
              table.dataset.tableType = "description";
              table.innerHTML = `
                <colgroup>
                  <col class="field-col" />
                  <col class="value-col" />
                </colgroup>
                <thead>
                  <tr>
                    <th data-col-key="field">Field</th>
                    <th data-col-key="value">Value</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th>1. Human-Written Seed</th>
                    <td data-col-key="seed" contenteditable="true">${escapeHtml(section.seedText || "")}</td>
                  </tr>
                  <tr>
                    <th>2. AI Generated Description</th>
                    <td data-col-key="generated" contenteditable="true">${escapeHtml(section.generatedText || "")}</td>
                  </tr>
                </tbody>
              `;
              card.appendChild(table);
            }else{
              const label = document.createElement("label");
              label.innerHTML = `Body HTML<textarea class="input" data-field="section-body">${escapeHtml(section.bodyHtml || "")}</textarea>`;
              card.appendChild(label);
            }
          }

          group.appendChild(card);
        });

        const addBtn = document.createElement("button");
        addBtn.className = "section-tab";
        addBtn.type = "button";
        addBtn.dataset.subtab = "add-new";
        addBtn.textContent = "Add New";
        tabsRow.appendChild(addBtn);

        const savedSubtab = getViewSectionTab();
        if(savedSubtab && groups.has(savedSubtab)){
          tabsRow.querySelectorAll(".section-tab").forEach(btn => {
            const key = btn.getAttribute("data-subtab");
            btn.classList.toggle("active", key === savedSubtab);
          });
          sectionsStack.querySelectorAll(".section-group").forEach(group => {
            group.classList.toggle("active", group.dataset.subtab === savedSubtab);
          });
        }

        tabsRow.querySelectorAll(".section-tab").forEach(btn => {
          const key = btn.getAttribute("data-subtab");
          if(key === "add-new") return;
          const isVisible = groups.get(key)?.dataset.visible !== "false";
          btn.classList.toggle("visible", isVisible);
          btn.classList.toggle("hidden", !isVisible);
        });
      }else if(data.type === "collection"){
        const rowsWrap = document.createElement("div");
        rowsWrap.className = "panel-card";
        rowsWrap.innerHTML = `<div class="panel-title">Collection Table</div>`;
        const rowsStack = document.createElement("div");
        rowsStack.className = "form-stack";
        rowsStack.dataset.collectionList = "true";
        rowsWrap.appendChild(rowsStack);

        (data.rows || []).forEach(row => {
          const rowEl = document.createElement("div");
          rowEl.className = "inline-row";
          rowEl.dataset.collectionRow = "true";
          rowEl.innerHTML = `
            <label>Part No<input class="input" data-field="row-part" type="text" value="${escapeHtml(row.partNo || "")}"></label>
            <label>Title<input class="input" data-field="row-title" type="text" value="${escapeHtml(row.title || "")}"></label>
            <label>Link Href<input class="input" data-field="row-href" type="text" value="${escapeHtml(row.href || "")}"></label>
            <label>Pieces/Panel<input class="input" data-field="row-pieces" type="text" value="${escapeHtml(row.pieces || "")}"></label>
          `;
          rowsStack.appendChild(rowEl);
        });

        const actions = document.createElement("div");
        actions.className = "row-actions";
        actions.innerHTML = `
          <button class="btn secondary" data-action="add-collection-row" type="button">Add Row</button>
        `;
        rowsWrap.appendChild(actions);
        panelCollection.appendChild(rowsWrap);
      }

      const tpl = state.template || defaultTemplate();
      panelTemplate.querySelector('[data-field="tpl-analytics"]').value = tpl.analyticsHtml || "";
      panelTemplate.querySelector('[data-field="tpl-default-keywords"]').value = tpl.defaultKeywords || "";
      panelTemplate.querySelector('[data-field="tpl-default-description"]').value = tpl.defaultDescription || "";
      panelTemplate.querySelector('[data-field="tpl-footer"]').value = tpl.footerText || "";
      panelTemplate.querySelector('[data-field="tpl-css-board"]').value = tpl.cssHrefBoard || "";
      panelTemplate.querySelector('[data-field="tpl-css-collection"]').value = tpl.cssHrefCollection || "";
      panelTemplate.querySelector('[data-field="tpl-js-board"]').value = tpl.jsHrefBoard || "";
      panelTemplate.querySelector('[data-field="tpl-favicon"]').value = tpl.faviconHref || "";
      panelTemplate.querySelector('[data-field="tpl-version"]').value = tpl.versionStamp || "";
      panelTemplate.querySelector('[data-field="tpl-date"]').value = tpl.dateStamp || "";

      const metaTable = panelPageMeta.querySelector('[data-meta-table="true"]');
      if(metaTable){
        metaTable.querySelector('[data-meta-key="title"]').textContent = data.meta.title || "";
        metaTable.querySelector('[data-meta-key="description"]').textContent = data.meta.description || "";
        metaTable.querySelector('[data-meta-key="keywords"]').textContent = data.meta.keywords || "";
        metaTable.querySelector('[data-meta-key="h1"]').textContent = data.meta.h1 || "";
        metaTable.querySelector('[data-meta-key="slogan"]').textContent = data.meta.slogan || "";
      }
      if(data.type !== "board"){
        if(metaTable){
          const sloganRow = metaTable.querySelector('[data-meta-key="slogan"]')?.closest("tr");
          const descRow = metaTable.querySelector('[data-meta-key="description"]')?.closest("tr");
          if(sloganRow) sloganRow.style.display = "none";
          if(descRow) descRow.style.display = "none";
        }
      }

      const navList = panelNav.querySelector("[data-nav-list]");
      (data.nav || []).forEach(item => {
        const row = document.createElement("tr");
        row.dataset.navItem = "true";
        row.innerHTML = `
          <td data-col-key="text"><input class="input" data-field="nav-text" type="text" value="${escapeHtml(item.text)}"></td>
          <td data-col-key="href"><input class="input" data-field="nav-href" type="text" list="navHrefOptions" value="${escapeHtml(item.href)}"></td>
        `;
        navList.appendChild(row);
      });

      // AI Assist panel removed.

      const tabs = $("formTabs");
      if(data.type === "collection"){
        tabs.querySelector('[data-tab="sections"]').style.display = "none";
        tabs.querySelector('[data-tab="collection"]').style.display = "inline-flex";
      }else{
        tabs.querySelector('[data-tab="sections"]').style.display = "inline-flex";
        tabs.querySelector('[data-tab="collection"]').style.display = "none";
      }

      updateNavHrefOptions();
      document.querySelectorAll("table.table-editor").forEach(enableColumnResize);
    }

    function collectFormState(){
      const panelTemplate = $("panel-template");
      const panelPageMeta = $("panel-page-meta");
      const panelNav = $("panel-nav");
      const panelSections = $("panel-sections");
      const panelCollection = $("panel-collection");
      const panelAssist = $("panel-assist");
      const metaTable = panelPageMeta.querySelector('[data-meta-table="true"]');
      const meta = {
        title: metaTable?.querySelector('[data-meta-key="title"]')?.textContent.trim() || "",
        description: metaTable?.querySelector('[data-meta-key="description"]')?.textContent.trim() || "",
        keywords: metaTable?.querySelector('[data-meta-key="keywords"]')?.textContent.trim() || "",
        h1: metaTable?.querySelector('[data-meta-key="h1"]')?.textContent.trim() || "",
        slogan: metaTable?.querySelector('[data-meta-key="slogan"]')?.textContent.trim() || ""
      };

      const nav = Array.from(panelNav.querySelectorAll("[data-nav-item]")).map(row => ({
        text: row.querySelector('[data-field="nav-text"]').value.trim(),
        href: row.querySelector('[data-field="nav-href"]').value.trim()
      })).filter(item => item.text || item.href);

      if(state.formState?.type === "collection"){
        const rows = Array.from(panelCollection.querySelectorAll("[data-collection-row]")).map(row => ({
          partNo: row.querySelector('[data-field="row-part"]').value.trim(),
          title: row.querySelector('[data-field="row-title"]').value.trim(),
          href: row.querySelector('[data-field="row-href"]').value.trim(),
          pieces: row.querySelector('[data-field="row-pieces"]').value.trim()
        })).filter(row => row.partNo || row.title || row.href || row.pieces);
        return { type: "collection", meta, nav, rows };
      }

      const sections = Array.from(panelSections.querySelectorAll(".section-card")).map(card => {
        const id = card.dataset.sectionId || "";
        const title = card.dataset.sectionTitle || "";
        const tabLabel = card.dataset.sectionTab || "";
        const active = card.dataset.sectionActive === "true";
        const group = card.closest(".section-group");
        const visible = group ? group.dataset.visible !== "false" : true;
        const type = card.dataset.sectionType;
        if(type === "details"){
          const table = card.querySelector("table.table-editor");
          const rows = table ? Array.from(table.querySelectorAll("tbody tr")).map(tr => ({
            label: (tr.querySelector('td[data-col-key="label"]')?.textContent || "").trim(),
            value: (tr.querySelector('td[data-col-key="value"]')?.textContent || "").trim()
          })).filter(row => row.label || row.value) : [];
          return { id, title, tabLabel, active, hidden: !visible, type, rows };
        }
        if(type === "images"){
          const images = Array.from(card.querySelectorAll("[data-image-row]")).map(row => ({
            src: row.querySelector('[data-field="image-src"]').value.trim(),
            alt: row.querySelector('[data-field="image-alt"]').value.trim(),
            full: row.querySelector('[data-field="image-full"]').value.trim()
          })).filter(img => img.src || img.alt || img.full);
          return { id, title, tabLabel, active, hidden: !visible, type, images };
        }
        if(type === "downloads"){
          const table = card.querySelector("table.table-editor");
          const items = table ? Array.from(table.querySelectorAll("tbody tr")).map(tr => ({
            label: (tr.querySelector('td[data-col-key="label"]')?.textContent || "").trim(),
            href: (tr.querySelector('td[data-col-key="href"]')?.textContent || "").trim()
          })).filter(item => item.label || item.href) : [];
          return { id, title, tabLabel, active, hidden: !visible, type, items };
        }
        if(type === "videos"){
          const table = card.querySelector("table.table-editor");
          const videos = table ? Array.from(table.querySelectorAll("tbody tr")).map(tr => ({
            src: (tr.querySelector('td[data-col-key="src"]')?.textContent || "").trim(),
            title: (tr.querySelector('td[data-col-key="title"]')?.textContent || "").trim(),
            width: (tr.querySelector('td[data-col-key="width"]')?.textContent || "").trim(),
            height: (tr.querySelector('td[data-col-key="height"]')?.textContent || "").trim()
          })).filter(video => video.src || video.title) : [];
          return { id, title, tabLabel, active, hidden: !visible, type, videos };
        }
        if(type === "revisions"){
          const table = card.querySelector("table.table-editor");
          const rows = table ? Array.from(table.querySelectorAll("tbody tr")).map(tr => ({
            date: (tr.querySelector('td[data-col-key="date"]')?.textContent || "").trim(),
            rev: (tr.querySelector('td[data-col-key="rev"]')?.textContent || "").trim(),
            desc: (tr.querySelector('td[data-col-key="desc"]')?.textContent || "").trim(),
            by: (tr.querySelector('td[data-col-key="by"]')?.textContent || "").trim()
          })).filter(row => row.date || row.rev || row.desc || row.by) : [];
          return { id, title, tabLabel, active, hidden: !visible, type, rows };
        }
        if(type === "ai-seeds"){
          const jsonText = card.querySelector('[data-field="ai-seeds"]').value.trim() || "{}";
          return { id, title, tabLabel, active, hidden: true, type, jsonText };
        }
        if(id === "description"){
          const table = card.querySelector('table.table-editor[data-table-type="description"]');
          const seedCell = table?.querySelector('td[data-col-key="seed"]');
          const genCell = table?.querySelector('td[data-col-key="generated"]');
          const seedText = (seedCell?.textContent || seedCell?.innerText || "").trim();
          const generatedText = (genCell?.textContent || genCell?.innerText || "").trim();
          const bodyHtml = buildDescriptionBody(seedText, generatedText);
          return { id, title, tabLabel, active, hidden: !visible, type, bodyHtml, seedText, generatedText };
        }
        const bodyHtml = card.querySelector('[data-field="section-body"]').value;
        return { id, title, tabLabel, active, hidden: !visible, type, bodyHtml };
      });

      return { type: "board", meta, nav, sections };
    }

    function collectTemplateState(){
      const panelTemplate = $("panel-template");
      return {
        analyticsHtml: panelTemplate.querySelector('[data-field="tpl-analytics"]').value.trim(),
        defaultKeywords: panelTemplate.querySelector('[data-field="tpl-default-keywords"]').value.trim(),
        defaultDescription: panelTemplate.querySelector('[data-field="tpl-default-description"]').value.trim(),
        footerText: panelTemplate.querySelector('[data-field="tpl-footer"]').value.trim(),
        cssHrefBoard: panelTemplate.querySelector('[data-field="tpl-css-board"]').value.trim(),
        cssHrefCollection: panelTemplate.querySelector('[data-field="tpl-css-collection"]').value.trim(),
        jsHrefBoard: panelTemplate.querySelector('[data-field="tpl-js-board"]').value.trim(),
        faviconHref: panelTemplate.querySelector('[data-field="tpl-favicon"]').value.trim(),
        versionStamp: panelTemplate.querySelector('[data-field="tpl-version"]').value.trim(),
        dateStamp: panelTemplate.querySelector('[data-field="tpl-date"]').value.trim()
      };
    }

    function buildEditableTable(columns, rows){
      const table = document.createElement("table");
      table.className = "table-editor";
      const thead = document.createElement("thead");
      const headRow = document.createElement("tr");
      columns.forEach(col => {
        const th = document.createElement("th");
        th.textContent = col.label;
        th.dataset.colKey = col.key;
        headRow.appendChild(th);
      });
      thead.appendChild(headRow);
      table.appendChild(thead);
      const tbody = document.createElement("tbody");
      (rows || []).forEach(row => {
        const tr = document.createElement("tr");
        columns.forEach(col => {
          const td = document.createElement("td");
          td.contentEditable = "true";
          td.dataset.colKey = col.key;
          td.textContent = row[col.key] || "";
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      return table;
    }

    function updateModifiedState(){
      const current = state.current?.path;
      if(!current){
        setStatus("ok", "CLEAN");
        return;
      }
      const draft = loadDraft(current);
      if(state.editorText !== state.originalText){
        setStatus(draft ? "warn" : "warn", draft ? "Draft saved" : "Modified");
        setSaveDirty(true);
      }else{
        setStatus("ok", "CLEAN");
        setSaveDirty(false);
      }
      renderList();
    }

    function buildDescriptionBody(seedText, generatedText){
      const seed = String(seedText || "").trim();
      const generated = String(generatedText || "").trim();
      const seedHtml = seed ? `<p>${escapeHtml(seed)}</p>` : "<p></p>";
      const genHtml = generated
        ? escapeHtml(generated).split(/\n+/).map(line => `<p>${line}</p>`).join("\n")
        : "<p><br></p>";
      return `<h3>Human-Written Seed</h3>\n${seedHtml}\n<h3>AI Generated Description</h3>\n<div class="generated">\n${genHtml}\n</div>`;
    }

    function setDefaultSectionTab(container, targetId){
      if(!container || !targetId) return;
      container.querySelectorAll(".section-tab").forEach(tab => {
        const isTarget = tab.getAttribute("data-subtab") === targetId;
        tab.classList.toggle("current", isTarget);
      });
      container.querySelectorAll(".section-card").forEach(card => {
        card.dataset.sectionActive = card.dataset.sectionId === targetId ? "true" : "false";
      });
    }

    function queueDraftUpdate(){
      if(!state.current) return;
      if(state.saveTimer) clearTimeout(state.saveTimer);
      state.saveTimer = setTimeout(() => {
        saveDraftNow();
      }, SAVE_DELAY);
    }

    function saveDraftNow(){
      if(!state.current) return;
      const data = collectFormState();
      const template = collectTemplateState();
      saveTemplate(template);
      const updated = data.type === "collection"
        ? generateCollectionHtml(data, template)
        : generateBoardHtml(data, template);
      state.editorText = updated;
      saveDraft(state.current.path, state.editorText);
      updateModifiedState();
    }

    function queueSaveAll(){
      if(state.saveTimer) clearTimeout(state.saveTimer);
      saveDraftNow();
      setTimeout(() => {
        runSaveAll();
      }, SAVE_DELAY + 50);
    }

    function normalizeLabelKey(label){
      return String(label || "").toLowerCase().replace(/[^a-z0-9]+/g, "");
    }

    function readPartNoFromForm(){
      const panelSections = $("panel-sections");
      if(!panelSections) return "";
      const detailsCard = panelSections.querySelector('.section-card[data-section-id="details"]');
      const table = detailsCard ? detailsCard.querySelector("table.table-editor") : null;
      if(!table) return "";
      const rows = table.querySelectorAll("tbody tr");
      for(const row of rows){
        const labelCell = row.querySelector('td[data-col-key="label"]');
        if(labelCell && normalizeLabelKey(labelCell.textContent) === "partno"){
          const valueCell = row.querySelector('td[data-col-key="value"]');
          return valueCell ? valueCell.textContent.trim() : "";
        }
      }
      return "";
    }

    function updateNavHrefOptions(){
      const list = $("navHrefOptions");
      if(!list) return;
      list.innerHTML = "";
      const entries = Array.isArray(state.entries) ? state.entries : [];
      entries.forEach(entry => {
        const full = entry.path || entry.rel || "";
        if(!full) return;
        const opt = document.createElement("option");
        opt.value = full.startsWith("../") ? full : `../${full}`;
        list.appendChild(opt);
      });
    }

    function suggestHrefFromText(text){
      const value = String(text || "").toLowerCase().trim();
      if(!value) return "";
      const tokens = value.split(/[^a-z0-9]+/).filter(Boolean);
      if(!tokens.length) return "";
      let best = "";
      let bestScore = 0;
      for(const entry of (state.entries || [])){
        const fullRaw = entry.path || entry.rel || "";
        const full = fullRaw.toLowerCase();
        if(!full) continue;
        let score = 0;
        tokens.forEach(token => { if(full.includes(token)) score += 1; });
        if(score > bestScore){
          bestScore = score;
          best = fullRaw.startsWith("../") ? fullRaw : `../${fullRaw}`;
        }
      }
      return bestScore ? best : "";
    }

    function updateLinkedPartNo(newPartNo){
      const next = (newPartNo || "").trim();
      const prev = (state.lastPartNo || "").trim();
      if(!next || next === prev) return;

      const panelSections = $("panel-sections");
      if(!panelSections) return;

      const schematicCard = panelSections.querySelector('.section-card[data-section-id="schematic"]');
      const layoutCard = panelSections.querySelector('.section-card[data-section-id="layout"]');
      const downloadsCard = panelSections.querySelector('.section-card[data-section-id="downloads"]');

      const updateImageSection = (card, type) => {
        if(!card) return;
        const rows = card.querySelectorAll("[data-image-row]");
        rows.forEach(row => {
          const srcInput = row.querySelector('[data-field="image-src"]');
          const altInput = row.querySelector('[data-field="image-alt"]');
          if(srcInput){
            const src = srcInput.value.trim();
            const isPattern = type === "schematic"
              ? /_schematic_01\.png$/i.test(src)
              : /_components_top\.png$/i.test(src);
            if(!src || src.includes(prev) || isPattern){
              srcInput.value = type === "schematic"
                ? `../images/${next}_schematic_01.png`
                : `../images/${next}_components_top.png`;
            }
          }
          if(altInput){
            const alt = altInput.value.trim();
            if(!alt || alt.includes(prev)){
              altInput.value = type === "schematic"
                ? `Schematic for miniPCB ${next}`
                : `Top view of miniPCB ${next}`;
            }
          }
        });
      };

      updateImageSection(schematicCard, "schematic");
      updateImageSection(layoutCard, "layout");

      if(downloadsCard){
        const hrefCells = downloadsCard.querySelectorAll('td[data-col-key="href"]');
        hrefCells.forEach(cell => {
          const text = (cell.textContent || "").trim();
          if(!text) return;
          if(prev && text.includes(prev)){
            cell.textContent = text.replaceAll(prev, next);
          }else if(/\/datasheets\/[^\/]+\.pdf$/i.test(text)){
            cell.textContent = text.replace(/\/datasheets\/[^\/]+\.pdf$/i, `/datasheets/${next}.pdf`);
          }else if(/\/ltspice\/[^\/]+\.asc$/i.test(text)){
            cell.textContent = text.replace(/\/ltspice\/[^\/]+\.asc$/i, `/ltspice/${next}.asc`);
          }
        });
      }

      state.lastPartNo = next;
      queueDraftUpdate();
    }

    function loadColumnWidths(){
      try{
        const raw = localStorage.getItem(COLUMN_WIDTH_KEY);
        return raw ? JSON.parse(raw) : {};
      }catch{
        return {};
      }
    }

    function saveColumnWidths(map){
      try{
        localStorage.setItem(COLUMN_WIDTH_KEY, JSON.stringify(map || {}));
      }catch{}
    }

    function tableStorageKey(table){
      const type = table?.dataset.tableType || "table";
      const panel = table?.closest(".form-panel");
      const panelId = panel ? panel.id : "panel";
      const sectionId = table?.closest(".section-card")?.dataset.sectionId || "section";
      return `${panelId}:${sectionId}:${type}`;
    }

    function enableColumnResize(table){
      if(!table) return;
      const widths = loadColumnWidths();
      const key = tableStorageKey(table);
      const saved = widths[key];
      if(saved){
        Object.keys(saved).forEach(index => {
          const width = saved[index];
          const idx = Number(index);
          const th = table.querySelectorAll("thead th")[idx];
          if(th) th.style.width = `${width}px`;
          table.querySelectorAll("tr").forEach(row => {
            const cell = row.children[idx];
            if(cell) cell.style.width = `${width}px`;
          });
        });
      }
      const headers = table.querySelectorAll("thead th");
      headers.forEach((th, index) => {
        if(th.querySelector(".col-resizer")) return;
        const resizer = document.createElement("span");
        resizer.className = "col-resizer";
        th.appendChild(resizer);
        resizer.addEventListener("mousedown", (e) => {
          if(e.button !== 0) return;
          e.preventDefault();
          const startX = e.clientX;
          const startWidth = th.offsetWidth;
          const onMove = (evt) => {
            const delta = evt.clientX - startX;
            const nextWidth = Math.max(60, startWidth + delta);
            th.style.width = `${nextWidth}px`;
            table.querySelectorAll("tr").forEach(row => {
              const cell = row.children[index];
              if(cell) cell.style.width = `${nextWidth}px`;
            });
          };
          const onUp = () => {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onUp);
            const next = loadColumnWidths();
            if(!next[key]) next[key] = {};
            next[key][index] = th.offsetWidth;
            saveColumnWidths(next);
          };
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onUp);
        });
      });
    }

    function getMetaValue(key){
      const table = $("panel-page-meta")?.querySelector('[data-meta-table="true"]');
      return (table?.querySelector(`[data-meta-key="${key}"]`)?.textContent || "").trim();
    }

    function suggestCellValue(cell, tableType){
      const partNo = readPartNoFromForm();
      const colKey = cell.dataset.colKey || "";
      const table = cell.closest("table");
      const isMeta = table?.dataset.metaTable === "true";
      const isNav = table?.dataset.navTable === "true";
      const metaTitle = getMetaValue("title");
      const metaH1 = getMetaValue("h1");
      const metaSlogan = getMetaValue("slogan");
      if(tableType === "details"){
        if(colKey === "label") return "Detail";
        if(colKey === "value"){
          const row = cell.closest("tr");
          const labelCell = row ? row.querySelector('td[data-col-key="label"]') : null;
          const labelKey = normalizeLabelKey(labelCell ? labelCell.textContent : "");
          if(labelKey === "partno") return partNo || (state.current?.rel || "").replace(/\.html$/i, "");
          if(labelKey === "title") return getMetaValue("title");
          if(labelKey === "boardsize") return "TBD";
          if(labelKey === "piecesperpanel") return "TBD";
          if(labelKey === "panelsize") return "TBD";
          return "TBD";
        }
      }
      if(tableType === "downloads"){
        if(colKey === "label") return partNo ? `${partNo} Datasheet (PDF)` : "Datasheet (PDF)";
        if(colKey === "href") return partNo ? `../datasheets/${partNo}.pdf` : "../datasheets/FILE.pdf";
      }
      if(tableType === "videos"){
        if(colKey === "src") return "https://www.youtube.com/embed/VIDEO_ID";
        if(colKey === "title") return "YouTube video player";
        if(colKey === "width") return "560";
        if(colKey === "height") return "315";
      }
      if(tableType === "revisions"){
        if(colKey === "date") return new Date().toISOString().slice(0, 10);
        if(colKey === "rev") return "A1-01";
        if(colKey === "desc") return "Initial release";
        if(colKey === "by") return getAuthor();
      }
      if(tableType === "description"){
        if(colKey === "seed") return metaTitle || metaH1 || partNo || "Describe the board in one or two sentences.";
        if(colKey === "generated"){
          const row = cell.closest("tr");
          const seedCell = row ? row.querySelector('td[data-col-key="seed"]') : null;
          const seed = (seedCell?.textContent || "").trim();
          const base = seed || metaTitle || metaH1 || partNo || "This miniPCB board";
          const extra = partNo
            ? ` It includes the ${partNo} board assets and documentation.`
            : " It includes schematics, layout, and downloads for quick reference.";
          return `${base} is a compact miniPCB design.${extra}`;
        }
      }
      if(isMeta){
        if(colKey === "title") return metaTitle || partNo || "miniPCB Board";
        if(colKey === "h1") return metaH1 || metaTitle || partNo || "miniPCB Board";
        if(colKey === "slogan") return metaSlogan || "A miniPCB project board.";
        if(colKey === "keywords"){
          const tokens = [partNo, metaTitle, metaH1, "miniPCB", "Schematic", "Board Layout", "Downloads"]
            .map(v => String(v || "").trim())
            .filter(Boolean);
          const unique = Array.from(new Set(tokens));
          return unique.join(", ");
        }
        if(colKey === "description"){
          const base = metaTitle || metaH1 || partNo || "miniPCB board";
          const extra = metaSlogan ? ` ${metaSlogan}` : "";
          return `${base} is a miniPCB board.${extra}`.trim();
        }
      }
      if(isNav){
        if(colKey === "text") return "New link";
        if(colKey === "href") return suggestHrefFromText("index") || "../index.html";
      }
      return "AI suggestion";
    }

    function parseAiTargets(text){
      const targets = [];
      const remaining = [];
      const tokens = text.split(/\s+/).filter(Boolean);
      for(let i = 0; i < tokens.length; i++){
        const token = tokens[i];
        if(token === "@all" || token === "@current" || token === "@modified"){
          targets.push({ type: token.slice(1) });
          continue;
        }
        if(token === "@folder" && tokens[i + 1]){
          targets.push({ type: "folder", value: tokens[i + 1] });
          i++;
          continue;
        }
        if(token === "@match" && tokens[i + 1]){
          targets.push({ type: "match", value: tokens[i + 1].replace(/^\"|\"$/g, "") });
          i++;
          continue;
        }
        if(token === "@list" && tokens[i + 1]){
          targets.push({ type: "list", value: tokens[i + 1] });
          i++;
          continue;
        }
        remaining.push(token);
      }
      return { targets, query: remaining.join(" ").trim() };
    }

    function parseAiActions(text){
      const t = text.toLowerCase();
      const actions = [];
      if(t.includes("rewrite description") || t.includes("description generated")){
        actions.push("description_generated");
      }
      if(t.includes("update keywords") || t.includes("keywords")){
        actions.push("meta_keywords");
      }
      if(t.includes("update slogan") || t.includes("slogan")){
        actions.push("meta_slogan");
      }
      if(t.includes("update title") || t.includes("title")){
        actions.push("meta_title");
      }
      if(t.includes("update h1") || t.includes("header h1") || t.includes("h1")){
        actions.push("meta_h1");
      }
      if(t.includes("update description") && !actions.includes("description_generated")){
        actions.push("meta_description");
      }
      if(!actions.length) actions.push("auto");
      return actions;
    }

    function getModifiedEntries(){
      const modified = [];
      state.entries.forEach(entry => {
        const draft = loadDraft(entry.path);
        if(draft) return modified.push(entry);
        if(state.current && state.current.path === entry.path && state.editorText !== state.originalText){
          modified.push(entry);
        }
      });
      return modified;
    }

    function resolveAiTargets(targets){
      if(!targets.length) return state.current ? [state.current] : [];
      const seen = new Set();
      const list = [];
      const add = (entry) => {
        if(!entry || seen.has(entry.path)) return;
        seen.add(entry.path);
        list.push(entry);
      };
      targets.forEach(target => {
        if(target.type === "all"){
          state.entries.forEach(add);
        }else if(target.type === "current"){
          add(state.current);
        }else if(target.type === "modified"){
          getModifiedEntries().forEach(add);
        }else if(target.type === "folder"){
          const prefix = `${target.value}/`;
          state.entries.filter(e => (e.rel || e.path || "").startsWith(prefix)).forEach(add);
        }else if(target.type === "match"){
          const q = target.value.toLowerCase();
          state.entries.filter(e => (e.rel || e.path || "").toLowerCase().includes(q)).forEach(add);
        }else if(target.type === "list"){
          const indexes = target.value.split(",").map(v => parseInt(v.trim(), 10)).filter(v => !isNaN(v));
          indexes.forEach(i => {
            const entry = state.filtered[i - 1];
            add(entry);
          });
        }
      });
      return list;
    }

    function buildAiPromptForFile(entry, data, actions, instruction){
      const partNo = (data.sections || []).find(s => s.id === "details")?.rows?.find(r => normalizeLabelKey(r.label) === "partno")?.value || "";
      const descSection = (data.sections || []).find(s => s.id === "description");
      const seed = descSection?.seedText || "";
      const generated = descSection?.generatedText || "";
      return [
        "You are editing a miniPCB HTML file.",
        "Return JSON only with the keys you are asked to update.",
        "Use the Human-Written Seed as gospel; add at least one additive detail.",
        "",
        `File: ${entry.rel || entry.path || ""}`,
        `Part No: ${partNo}`,
        `Title: ${data.meta?.title || ""}`,
        `Header H1: ${data.meta?.h1 || ""}`,
        `Slogan: ${data.meta?.slogan || ""}`,
        `Meta Keywords: ${data.meta?.keywords || ""}`,
        `Meta Description: ${data.meta?.description || ""}`,
        `Human-Written Seed: ${seed}`,
        `Current Generated Description: ${generated}`,
        "",
        `Requested Updates: ${actions.join(", ")}`,
        `User Instruction: ${instruction || ""}`,
        "",
        "Allowed JSON keys:",
        "description_generated, meta_keywords, meta_slogan, meta_title, meta_h1, meta_description"
      ].join("\n");
    }

    async function callAi(prompt){
      const base = getApiBase().replace(/\/+$/, "");
      const res = await fetch(`${base}/suggest`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          input: prompt
        })
      });
      if(!res.ok) throw new Error(`AI request failed (${res.status})`);
      const data = await res.json();
      const text = extractResponseText(data);
      if(!text) throw new Error("AI returned empty response");
      return text.trim();
    }

    function applyAiEdits(data, edits){
      if(edits.meta_title != null) data.meta.title = String(edits.meta_title);
      if(edits.meta_h1 != null) data.meta.h1 = String(edits.meta_h1);
      if(edits.meta_slogan != null) data.meta.slogan = String(edits.meta_slogan);
      if(edits.meta_keywords != null) data.meta.keywords = String(edits.meta_keywords);
      if(edits.meta_description != null) data.meta.description = String(edits.meta_description);
      if(edits.description_generated != null){
        const desc = data.sections.find(s => s.id === "description");
        if(desc){
          desc.generatedText = String(edits.description_generated);
          desc.bodyHtml = buildDescriptionBody(desc.seedText || "", desc.generatedText);
        }
      }
      return data;
    }

    async function runAiOnEntry(entry, actions, instruction){
      logTerminal("ai", `Working on ${entry.rel || entry.path || "file"}`);
      const html = await fetchFile(entry);
      const data = extractFormFromHtml(html);
      const prompt = buildAiPromptForFile(entry, data, actions, instruction);
      const response = await callAi(prompt);
      let edits = {};
      try{
        edits = JSON.parse(response);
      }catch{
        edits = {};
      }
      const updatedData = applyAiEdits(data, edits);
      const template = state.template || loadTemplate();
      const updatedHtml = updatedData.type === "collection"
        ? generateCollectionHtml(updatedData, template)
        : generateBoardHtml(updatedData, template);
      if(useFileSystemStore() && entry.fileHandle){
        await writeEntryToDisk(entry, updatedHtml);
      }else{
        saveDraft(entry.path, updatedHtml);
      }
      if(state.current && state.current.path === entry.path){
        state.editorText = updatedHtml;
        state.originalText = updatedHtml;
        syncFormInputs(updatedHtml);
      }
      logTerminal("ai", `Finished ${entry.rel || entry.path || "file"}`);
    }

    async function runAiBatch(message){
      const lower = message.toLowerCase().trim();
      if(AI_CANCEL_WORDS.some(word => lower.includes(word))){
        if(state.aiRunning){
          state.aiCancelRequested = true;
          logTerminal("ai", "Cancel requested. Stopping after current file.");
        }else{
          logTerminal("ai", "No AI job running.");
        }
        return;
      }
      const { targets, query } = parseAiTargets(message);
      const actions = parseAiActions(query);
      const entries = resolveAiTargets(targets);
      if(!entries.length){
        logTerminal("error", "No files matched for AI job.");
        return;
      }
      if(state.aiRunning){
        logTerminal("ai", "AI job already running.");
        return;
      }
      state.aiRunning = true;
      state.aiCancelRequested = false;
      for(const entry of entries){
        if(state.aiCancelRequested) break;
        try{
          await runAiOnEntry(entry, actions, query);
        }catch(err){
          logTerminal("error", err?.message || "AI job failed");
        }
        await new Promise(resolve => setTimeout(resolve, AI_JOB_DELAY));
      }
      state.aiRunning = false;
      state.aiCancelRequested = false;
      logTerminal("ai", "AI job complete.");
    }

    function extractResponseText(payload){
      if(!payload) return "";
      if(typeof payload.output_text === "string") return payload.output_text;
      if(Array.isArray(payload.output)){
        const parts = [];
        payload.output.forEach(item => {
          if(item?.type === "message" && Array.isArray(item.content)){
            item.content.forEach(chunk => {
              if(chunk?.type === "output_text" && typeof chunk.text === "string"){
                parts.push(chunk.text);
              }
            });
          }
        });
        return parts.join("\n").trim();
      }
      return "";
    }

    async function aiSuggestDescription(cell){
      if(!cell) return;
      const table = cell.closest("table");
      const seedCell = table ? table.querySelector('td[data-col-key="seed"]') : null;
      const seed = (seedCell?.textContent || "").trim();
      const partNo = readPartNoFromForm();
      const metaTitle = getMetaValue("title");
      const metaH1 = getMetaValue("h1");
      const metaSlogan = getMetaValue("slogan");
      const metaKeywords = getMetaValue("keywords");
      const metaDescription = getMetaValue("description");
      const current = cell.textContent.trim();

      const prompt = [
        "Write a professional product description (5-10 sentences).",
        "The Human-Written Seed is required content. Every concrete detail in the seed must be reflected in the output (do not omit any named components or test points).",
        "Do not use bullet points or lists.",
        "Add at least one new, additive detail that is consistent with the seed (do not contradict it).",
        "",
        `Human-Written Seed: ${seed || "(none)"}`,
        `Part No: ${partNo || "(unknown)"}`,
        `Title: ${metaTitle || "(empty)"}`,
        `Header H1: ${metaH1 || "(empty)"}`,
        `Slogan: ${metaSlogan || "(empty)"}`,
        `Meta Keywords: ${metaKeywords || "(empty)"}`,
        `Existing Meta Description: ${metaDescription || "(empty)"}`,
        `Current Generated Description: ${current || "(empty)"}`
      ].join("\n");

      const base = getApiBase().replace(/\/+$/, "");
      cell.textContent = "Generating…";
      try{
        const res = await fetch(`${base}/suggest`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            input: prompt
          })
        });
        if(!res.ok){
          throw new Error(`AI request failed (${res.status})`);
        }
        const data = await res.json();
        const text = extractResponseText(data) || "";
        cell.textContent = text || current || "";
        logTerminal("ai", "Generated description");
        saveDraftNow();
        await runSaveAll();
      }catch(err){
        cell.textContent = current || "";
        logTerminal("error", err?.message || "AI request failed");
      }
    }

    function editDetailLabel(span){
      if(!span) return;
      const current = span.textContent.trim();
      const input = document.createElement("input");
      input.className = "input";
      input.type = "text";
      input.value = current;
      span.replaceWith(input);
      input.focus();
      input.select();
      const commit = () => {
        const next = input.value.trim() || "Label";
        const newSpan = document.createElement("span");
        newSpan.className = "detail-label";
        newSpan.dataset.field = "detail-label";
        newSpan.textContent = next;
        input.replaceWith(newSpan);
        queueDraftUpdate();
      };
      input.addEventListener("blur", commit, { once: true });
      input.addEventListener("keydown", (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          input.blur();
        }
        if(e.key === "Escape"){
          e.preventDefault();
          const newSpan = document.createElement("span");
          newSpan.className = "detail-label";
          newSpan.dataset.field = "detail-label";
          newSpan.textContent = current || "Label";
          input.replaceWith(newSpan);
        }
      });
    }

    function runUpdate(){
      if(!state.current) return;
      const template = collectTemplateState();
      saveTemplate(template);
      const data = collectFormState();
      const updated = data.type === "collection"
        ? generateCollectionHtml(data, template)
        : generateBoardHtml(data, template);
      state.editorText = updated;
      saveDraft(state.current.path, state.editorText);
      updateModifiedState();
      logTerminal("update", `Updated ${state.current.path}`);
    }

    async function writeEntryToDisk(entry, text){
      if(!entry?.fileHandle) return false;
      const root = await ensureFolderHandleWrite();
      if(!root) return false;
      const writable = await entry.fileHandle.createWritable();
      await writable.write(text);
      await writable.close();
      return true;
    }

    async function createFileInFolder(relPath){
      const root = await ensureFolderHandleWrite();
      if(!root) return null;
      const cleaned = relPath.replace(/^[./\\]+/, "").replace(/\\/g, "/");
      const parts = cleaned.split("/").filter(Boolean);
      if(!parts.length) return null;
      const fileName = parts.pop();
      let dir = root;
      for(const part of parts){
        dir = await dir.getDirectoryHandle(part, { create: true });
      }
      const fileHandle = await dir.getFileHandle(fileName, { create: true });
      return { dirHandle: dir, fileHandle, rel: cleaned, name: fileName };
    }

    async function renameEntryFile(entry, newRel){
      if(!useFileSystemStore() || !entry?.fileHandle) return false;
      const cleaned = newRel.replace(/^[./\\]+/, "").replace(/\\/g, "/");
      if(!cleaned) return false;
      if(cleaned === entry.rel) return true;
      const newEntry = await createFileInFolder(cleaned);
      if(!newEntry) return false;
      const text = state.editorText || (await fetchFile(entry));
      await writeEntryToDisk({ ...entry, fileHandle: newEntry.fileHandle }, text);
      await entry.dirHandle.removeEntry(entry.name, { recursive: true });
      const oldPath = entry.path;
      entry.rel = newEntry.rel;
      entry.url = newEntry.rel;
      entry.path = newEntry.rel;
      entry.title = newEntry.rel;
      entry.name = newEntry.name;
      entry.fileHandle = newEntry.fileHandle;
      entry.dirHandle = newEntry.dirHandle;
      if(oldPath){
        const draft = loadDraft(oldPath);
        if(draft){
          saveDraft(entry.path, draft);
          clearDraft(oldPath);
        }
      }
      if(state.aiContextPath === oldPath || state.aiContextPath === entry.rel){
        state.aiContextPath = entry.rel;
      }
      return true;
    }

    function suggestDuplicateName(rel){
      const cleaned = rel.replace(/\\/g, "/");
      const parts = cleaned.split("/");
      const fileName = parts.pop() || "copy.html";
      const dot = fileName.lastIndexOf(".");
      const base = dot > 0 ? fileName.slice(0, dot) : fileName;
      const ext = dot > 0 ? fileName.slice(dot) : ".html";
      const nextBase = base.endsWith("-copy") ? `${base}` : `${base}-copy`;
      parts.push(`${nextBase}${ext}`);
      return parts.join("/");
    }

    async function runSave(){
      if(!state.current) return;
      runUpdate();
      if(useFileSystemStore() && state.current.fileHandle){
        try{
          await writeEntryToDisk(state.current, state.editorText);
          clearDraft(state.current.path);
          state.originalText = state.editorText;
          updateModifiedState();
          logTerminal("save", `Saved ${state.current.path}`);
        }catch(err){
          logTerminal("error", `Save failed for ${state.current.path}`);
        }
      }
    }

    async function runSaveAll(){
      const template = collectTemplateState();
      saveTemplate(template);
      if(state.current){
        saveDraftNow();
      }
      if(!useFileSystemStore()){
        logTerminal("error", "Select a folder to save to disk.");
        updateModifiedState();
        return;
      }
      const currentPath = state.current?.path || "";
      for(const entry of state.entries){
        const draft = loadDraft(entry.path);
        if(!draft && entry.path !== currentPath) continue;
        const savedCurrent = state.current;
        const savedOriginal = state.originalText;
        const savedEditor = state.editorText;
        try{
          let updated = draft || "";
          if(entry.path === currentPath && state.editorText){
            updated = state.editorText;
          }else{
            const data = extractFormFromHtml(updated);
            updated = data.type === "collection"
              ? generateCollectionHtml(data, template)
              : generateBoardHtml(data, template);
          }
          if(useFileSystemStore() && entry.fileHandle){
            await writeEntryToDisk(entry, updated);
          }
          clearDraft(entry.path);
          if(savedCurrent && savedCurrent.path === entry.path){
            state.editorText = updated;
            state.originalText = updated;
          }
        }catch(err){
          logTerminal("error", `Save all failed for ${entry.path}`);
        }finally{
          state.current = savedCurrent;
          state.originalText = savedOriginal;
          state.editorText = savedEditor;
        }
      }
      updateModifiedState();
      logTerminal("save", "Saved all files");
    }

    function runCommand(input){
      const raw = (input || "").trim();
      if(!raw) return;
      const [cmd, ...rest] = raw.split(" ");
      const arg = rest.join(" ").trim();
      switch(cmd.toLowerCase()){
        case "save":
          runSave();
          break;
        case "ai":
          runAiBatch(arg);
          break;
        case "help":
          logTerminal("help", "Commands: save, ai <targets> <instruction>");
          break;
        default:
          if(raw.startsWith("@")){
            runAiBatch(raw);
          }else{
            logTerminal("error", `Unknown command: ${cmd}`);
          }
      }
    }

    async function fetchFile(entry){
      if(entry.fileHandle){
        const root = await ensureFolderHandleRead();
        if(!root) throw new Error("Folder access denied");
        const file = await entry.fileHandle.getFile();
        return file.text();
      }
      if(entry.file){
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(String(reader.result || ""));
          reader.onerror = () => reject(new Error("Failed to read file"));
          reader.readAsText(entry.file);
        });
      }
      const url = entry.path + "?v=" + Date.now();
      const res = await fetch(url, { cache: "no-store" });
      if(!res.ok){
        throw new Error(`Failed to load ${entry.path} (${res.status})`);
      }
      return res.text();
    }

    async function selectEntry(entry){
      try{
        state.current = entry;
        $("previewTitle").textContent = entry.title || entry.url;
        updatePreviewMeta(entry);
        setStatus("ok", "Loading...");
        const text = await fetchFile(entry);
        state.originalText = text;
        const draft = loadDraft(entry.path);
        state.editorText = draft && draft !== text ? draft : text;
        syncFormInputs(state.editorText);
        updateModifiedState();
        renderList();
        const viewTab = getViewTab();
        const tabs = $("formTabs");
        const btn = tabs ? tabs.querySelector(`[data-tab="${viewTab}"]`) : null;
        if(btn && btn.style.display !== "none"){
          btn.click();
        }
      }catch(err){
        setStatus("err", err?.message || "Load error");
      }
    }

    function downloadCurrent(){
      if(!state.current) return;
      const blob = new Blob([state.editorText], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = state.current.url.split("/").pop() || "page.html";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function setupEditor(){
      const tabs = $("formTabs");
      if(tabs){
        tabs.addEventListener("click", (e) => {
          const btn = e.target.closest(".form-tab");
          if(!btn) return;
          const target = btn.getAttribute("data-tab");
          tabs.querySelectorAll(".form-tab").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          document.querySelectorAll(".form-panel").forEach(panel => {
            panel.classList.toggle("active", panel.id === `panel-${target}`);
          });
          setViewTab(target);
        });
      }

      document.addEventListener("click", (e) => {
        const tabBtn = e.target.closest(".section-tab");
        if(!tabBtn) return;
        const container = tabBtn.closest(".panel-card");
        if(!container) return;
        if(e.shiftKey && tabBtn.getAttribute("data-subtab") !== "add-new"){
          const group = container.querySelector(`.section-group[data-subtab="${tabBtn.getAttribute("data-subtab")}"]`);
          if(!group) return;
          const card = group.querySelector(".section-card");
          if(!card) return;
          state.editingSectionCard = card;
          $("sectionIdInput").value = card.dataset.sectionId || "";
          $("sectionTabInput").value = card.dataset.sectionTab || "";
          $("sectionTitleInput").value = card.dataset.sectionTitle || "";
          $("sectionModal").classList.add("open");
          return;
        }
        if(tabBtn.getAttribute("data-subtab") === "add-new"){
          const groups = container.querySelectorAll(".section-group");
          const count = groups.length + 1;
          const newId = `section-${Date.now().toString(36)}-${count}`;
          const tabsRow = container.querySelector("#sectionTabs");
          const newTab = document.createElement("button");
          newTab.className = "section-tab active visible";
          newTab.type = "button";
          newTab.dataset.subtab = newId;
          newTab.textContent = "New Section";
          const addNew = container.querySelector('.section-tab[data-subtab="add-new"]');
          if(addNew && tabsRow){
            tabsRow.insertBefore(newTab, addNew.nextSibling);
          }

          const newGroup = document.createElement("div");
          newGroup.className = "section-group active";
          newGroup.dataset.subtab = newId;
          newGroup.dataset.visible = "true";
          const stack = container.querySelector(".form-stack");
          if(stack) stack.appendChild(newGroup);

          const card = document.createElement("div");
          card.className = "section-card";
          card.dataset.sectionId = newId;
          card.dataset.sectionType = "html";
          card.dataset.sectionTitle = "New Section";
          card.dataset.sectionTab = "New Section";
          card.dataset.sectionActive = "false";
          card.innerHTML = `
            <div class="badge-row">
              <span class="badge-pill">${escapeHtml(newId)}</span>
              <span class="badge-pill">New Section</span>
              <span class="badge-pill">New Section</span>
            </div>
          `;
          const label = document.createElement("label");
          label.innerHTML = `Body HTML<textarea class="input" data-field="section-body"><p>New section content.</p></textarea>`;
          card.appendChild(label);
          newGroup.appendChild(card);
          container.querySelectorAll(".section-tab").forEach(b => b.classList.remove("active"));
          newTab.classList.add("active");
          groups.forEach(group => {
            group.classList.toggle("active", group.dataset.subtab === newId);
          });
          newGroup.classList.add("active");
          return;
        }
        const target = tabBtn.getAttribute("data-subtab");
        if(e.ctrlKey){
          setDefaultSectionTab(container, target);
          queueDraftUpdate();
        }
        if(target !== "add-new"){
          setViewSectionTab(target);
        }
        container.querySelectorAll(".section-tab").forEach(b => b.classList.remove("active"));
        tabBtn.classList.add("active");
        container.querySelectorAll(".section-group").forEach(group => {
          group.classList.toggle("active", group.dataset.subtab === target);
        });
      });

      document.addEventListener("dblclick", (e) => {
        const tabBtn = e.target.closest(".section-tab");
        if(!tabBtn) return;
        const container = tabBtn.closest(".panel-card");
        if(!container) return;
        const target = tabBtn.getAttribute("data-subtab");
        const group = container.querySelector(`.section-group[data-subtab="${target}"]`);
        if(!group) return;
        const nextVisible = group.dataset.visible === "false";
        group.dataset.visible = nextVisible ? "true" : "false";
        tabBtn.classList.toggle("visible", nextVisible);
        tabBtn.classList.toggle("hidden", !nextVisible);
        queueDraftUpdate();
      });

      document.addEventListener("dblclick", (e) => {
        const label = e.target.closest(".detail-label");
        if(!label) return;
        editDetailLabel(label);
      });

      document.addEventListener("contextmenu", (e) => {
        const tabBtn = e.target.closest(".section-tab");
        if(!tabBtn) return;
        const target = tabBtn.getAttribute("data-subtab");
        if(target === "add-new") return;
        e.preventDefault();
        contextTargetTab = tabBtn;
        const menu = $("sectionContextMenu");
        menu.style.display = "block";
        menu.style.left = `${e.clientX}px`;
        menu.style.top = `${e.clientY}px`;
      });

      document.addEventListener("click", (e) => {
        const menu = $("sectionContextMenu");
        if(menu && menu.style.display === "block" && !menu.contains(e.target)){
          menu.style.display = "none";
        }
        const tableMenu = $("tableContextMenu");
        if(tableMenu && tableMenu.style.display === "block" && !tableMenu.contains(e.target)){
          tableMenu.style.display = "none";
        }
        const fileMenu = $("fileContextMenu");
        if(fileMenu && fileMenu.style.display === "block" && !fileMenu.contains(e.target)){
          fileMenu.style.display = "none";
        }
      });

      $("sectionDeleteBtn").addEventListener("click", () => {
        if(!contextTargetTab) return;
        const tabBtn = contextTargetTab;
        const target = tabBtn.getAttribute("data-subtab");
        const container = tabBtn.closest(".panel-card");
        if(!container) return;
        const wasCurrent = tabBtn.classList.contains("current");
        const group = container.querySelector(`.section-group[data-subtab="${target}"]`);
        if(group) group.remove();
        tabBtn.remove();
        contextTargetTab = null;
        const menu = $("sectionContextMenu");
        if(menu) menu.style.display = "none";
        const nextTab = container.querySelector(".section-tab");
        if(nextTab){
          nextTab.classList.add("active");
          const nextTarget = nextTab.getAttribute("data-subtab");
          container.querySelectorAll(".section-group").forEach(el => {
            el.classList.toggle("active", el.dataset.subtab === nextTarget);
          });
          if(wasCurrent){
            setDefaultSectionTab(container, nextTarget);
          }
        }
      });

      document.addEventListener("contextmenu", (e) => {
        const cell = e.target.closest("table.table-editor td");
        if(!cell) return;
        e.preventDefault();
        contextTableCell = cell;
        const menu = $("tableContextMenu");
        menu.style.display = "block";
        menu.style.left = `${e.clientX}px`;
        menu.style.top = `${e.clientY}px`;
      });

      $("tableContextMenu").addEventListener("click", (e) => {
        const btn = e.target.closest("[data-table-action]");
        if(!btn || !contextTableCell) return;
        const action = btn.getAttribute("data-table-action");
        const cell = contextTableCell;
        const table = cell.closest("table");
        const row = cell.parentElement;
        const colIndex = Array.from(row.children).indexOf(cell);
        const rows = Array.from(table.querySelectorAll("tbody tr"));

        if(action === "row-above" || action === "row-below"){
          const newRow = document.createElement("tr");
          Array.from(row.children).forEach(td => {
            const newTd = document.createElement("td");
            newTd.contentEditable = "true";
            newTd.dataset.colKey = td.dataset.colKey || "";
            newRow.appendChild(newTd);
          });
          if(action === "row-above"){
            row.parentElement.insertBefore(newRow, row);
          }else{
            row.parentElement.insertBefore(newRow, row.nextSibling);
          }
        }

        if(action === "col-left" || action === "col-right"){
          const allRows = table.querySelectorAll("tr");
          allRows.forEach(tr => {
            const ref = tr.children[colIndex];
            const el = document.createElement(tr.parentElement.tagName === "THEAD" ? "th" : "td");
            if(el.tagName === "TD"){
              el.contentEditable = "true";
            }
            el.dataset.colKey = "";
            el.textContent = el.tagName === "TH" ? "New" : "";
            if(action === "col-left"){
              tr.insertBefore(el, ref);
            }else{
              tr.insertBefore(el, ref ? ref.nextSibling : null);
            }
          });
        }

        if(action === "row-delete"){
          if(rows.length > 1){
            row.remove();
          }
        }

        if(action === "col-delete"){
          const allRows = table.querySelectorAll("tr");
          allRows.forEach(tr => {
            if(tr.children[colIndex]) tr.children[colIndex].remove();
          });
        }

        if(action === "ai-suggest"){
          const tableType = table?.dataset.tableType || "";
          if(tableType === "description" && cell.dataset.colKey === "generated"){
            aiSuggestDescription(cell);
          }else{
            const suggestion = suggestCellValue(cell, tableType);
            const input = cell.querySelector("input");
            if(input){
              input.value = suggestion;
            }else{
              cell.textContent = suggestion;
            }
            logTerminal("ai", `Suggested ${cell.dataset.colKey || "cell"} content`);
            queueSaveAll();
          }
        }

        const menu = $("tableContextMenu");
        menu.style.display = "none";
        contextTableCell = null;
      });
      document.addEventListener("contextmenu", (e) => {
        const item = e.target.closest(".file-item");
        if(!item) return;
        e.preventDefault();
        const rel = item.dataset.rel || "";
        contextTargetFile = state.entries.find(entry => (entry.rel || entry.path) === rel) || null;
        const menu = $("fileContextMenu");
        if(menu){
          menu.style.display = "block";
          menu.style.left = `${e.clientX}px`;
          menu.style.top = `${e.clientY}px`;
        }
      });

      $("fileAddBtn").addEventListener("click", async () => {
        const menu = $("fileContextMenu");
        if(menu) menu.style.display = "none";
        if(!useFileSystemStore()){
          logTerminal("error", "Select a folder to add files.");
          return;
        }
        const relPath = window.prompt("New HTML file path (relative to folder):", "new-page.html");
        if(!relPath) return;
        const nextPath = relPath.toLowerCase().endsWith(".html") ? relPath : `${relPath}.html`;
        try{
          const created = await createFileInFolder(nextPath);
          if(!created) throw new Error("Failed to create file");
          const entry = {
            rel: created.rel,
            url: created.rel,
            path: created.rel,
            title: created.rel,
            name: created.name,
            fileHandle: created.fileHandle,
            dirHandle: created.dirHandle
          };
          const initial = generateBoardHtml({
            type: "board",
            meta: { title: "", description: "", keywords: "", h1: "", slogan: "" },
            nav: [],
            sections: []
          }, loadTemplate());
          await writeEntryToDisk(entry, initial);
          state.entries.push(entry);
          state.entries.sort((a, b) => (a.rel || "").localeCompare(b.rel || ""));
          state.filtered = state.entries.slice();
          $("fileCount").textContent = `${state.filtered.length} files`;
          renderList();
          logTerminal("create", `Added ${entry.rel}`);
        }catch(err){
          logTerminal("error", "Failed to add file");
        }
      });

      $("fileDuplicateBtn").addEventListener("click", async () => {
        const entry = contextTargetFile;
        const menu = $("fileContextMenu");
        if(menu) menu.style.display = "none";
        contextTargetFile = null;
        if(!entry){
          logTerminal("error", "No file selected.");
          return;
        }
        if(!useFileSystemStore()){
          logTerminal("error", "Select a folder to duplicate files.");
          return;
        }
        try{
          const text = await fetchFile(entry);
          const suggested = suggestDuplicateName(entry.rel || entry.path || "copy.html");
          const next = window.prompt("Duplicate file as:", suggested);
          if(!next) return;
          const nextPath = next.toLowerCase().endsWith(".html") ? next : `${next}.html`;
          const created = await createFileInFolder(nextPath);
          if(!created) throw new Error("Failed to create file");
          const newEntry = {
            rel: created.rel,
            url: created.rel,
            path: created.rel,
            title: created.rel,
            name: created.name,
            fileHandle: created.fileHandle,
            dirHandle: created.dirHandle
          };
          await writeEntryToDisk(newEntry, text);
          state.entries.push(newEntry);
          state.entries.sort((a, b) => (a.rel || "").localeCompare(b.rel || ""));
          state.filtered = state.entries.slice();
          $("fileCount").textContent = `${state.filtered.length} files`;
          renderList();
          logTerminal("duplicate", `Duplicated to ${newEntry.rel}`);
        }catch(err){
          logTerminal("error", "Duplicate failed");
        }
      });

      $("fileAiLoadBtn").addEventListener("click", async () => {
        const entry = contextTargetFile;
        const menu = $("fileContextMenu");
        if(menu) menu.style.display = "none";
        contextTargetFile = null;
        if(!entry){
          logTerminal("error", "No file selected.");
          return;
        }
        try{
          const text = await fetchFile(entry);
          state.aiContextPath = entry.rel || entry.path || "";
          state.aiContextText = text;
          logTerminal("ai", `Loaded ${state.aiContextPath} into AI context`);
        }catch(err){
          logTerminal("error", `Failed to load ${entry.rel}`);
        }
      });

      $("fileDeleteBtn").addEventListener("click", async () => {
        const entry = contextTargetFile;
        if(!entry) return;
        const menu = $("fileContextMenu");
        if(menu) menu.style.display = "none";
        contextTargetFile = null;
        if(!useFileSystemStore() || !entry.dirHandle){
          logTerminal("error", "Delete requires folder access.");
          return;
        }
        const root = await ensureFolderHandleWrite();
        if(!root){
          logTerminal("error", "Folder access denied.");
          return;
        }
        try{
          await entry.dirHandle.removeEntry(entry.name, { recursive: true });
          clearDraft(entry.path);
          state.entries = state.entries.filter(item => item !== entry);
          state.filtered = state.filtered.filter(item => item !== entry);
          $("fileCount").textContent = `${state.filtered.length} files`;
          if(state.current && state.current.path === entry.path){
            state.current = null;
            state.originalText = "";
            state.editorText = "";
            $("previewTitle").textContent = "Select an HTML file";
            updatePreviewMeta(null);
            ["panel-template", "panel-page-meta", "panel-nav", "panel-sections", "panel-collection"].forEach(id => {
              const panel = $(id);
              if(panel) panel.innerHTML = "";
            });
            setStatus("ok", "CLEAN");
            setSaveDirty(false);
          }
          renderList();
          logTerminal("delete", `Deleted ${entry.rel}`);
        }catch(err){
          logTerminal("error", `Delete failed for ${entry.rel}`);
        }
      });
      $("searchInput").addEventListener("input", (e) => filterList(e.target.value));
      const updateBtn = $("updateHtmlBtn");
      if(updateBtn) updateBtn.addEventListener("click", runSave);

      const formRoot = $("panel-template");
      document.addEventListener("input", (e) => {
        const target = e.target;
        if(!target) return;
        if(!document.querySelector(".preview")?.contains(target)) return;
        if(target.matches('table.table-editor td')){
          const table = target.closest("table.table-editor");
          if(table && table.dataset.tableType === "details"){
            const row = target.closest("tr");
            const labelCell = row ? row.querySelector('td[data-col-key="label"]') : null;
            if(labelCell && normalizeLabelKey(labelCell.textContent) === "partno"){
              const valueCell = row.querySelector('td[data-col-key="value"]');
              updateLinkedPartNo(valueCell ? valueCell.textContent : "");
            }
          }
        }
        queueDraftUpdate();
      });

      document.addEventListener("blur", (e) => {
        const target = e.target;
        if(!target || !target.matches('[data-field="nav-href"]')) return;
        if(target.value.trim()) return;
        const row = target.closest("[data-nav-item]");
        const textInput = row ? row.querySelector('[data-field="nav-text"]') : null;
        const suggestion = suggestHrefFromText(textInput ? textInput.value : "");
        if(suggestion){
          target.value = suggestion;
          queueDraftUpdate();
        }
      }, true);

      $("previewTitle").addEventListener("dblclick", async () => {
        if(!state.current) return;
        if(!useFileSystemStore()){
          logTerminal("error", "Select a folder to rename files.");
          return;
        }
        const currentName = state.current.rel || state.current.path || "";
        const next = window.prompt("Rename HTML file (relative to folder):", currentName);
        if(!next || next === currentName) return;
        try{
          const nextPath = next.toLowerCase().endsWith(".html") ? next : `${next}.html`;
          const ok = await renameEntryFile(state.current, nextPath);
          if(!ok) throw new Error("Rename failed");
          $("previewTitle").textContent = state.current.title || state.current.url;
          updatePreviewMeta(state.current);
          state.entries.sort((a, b) => (a.rel || "").localeCompare(b.rel || ""));
          state.filtered = state.entries.slice();
          $("fileCount").textContent = `${state.filtered.length} files`;
          renderList();
          logTerminal("rename", `Renamed to ${state.current.rel}`);
        }catch(err){
          logTerminal("error", "Rename failed");
        }
      });

      document.addEventListener("keydown", (e) => {
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s"){
          e.preventDefault();
          runSaveAll();
        }
      });

      document.addEventListener("click", (e) => {
        const target = e.target.closest("[data-action]");
        if(!target) return;
        const action = target.getAttribute("data-action");
        if(action === "add-nav"){
          const list = $("panel-nav").querySelector("[data-nav-list]");
          const row = document.createElement("tr");
          row.dataset.navItem = "true";
          row.innerHTML = `
            <td data-col-key="text"><input class="input" data-field="nav-text" type="text"></td>
            <td data-col-key="href"><input class="input" data-field="nav-href" type="text" list="navHrefOptions"></td>
          `;
          list.appendChild(row);
        }
        if(action === "add-image"){
          const card = target.closest(".section-card");
          const list = card.querySelector("[data-image-list]");
          const row = document.createElement("div");
          row.className = "inline-row";
          row.dataset.imageRow = "true";
          row.innerHTML = `
            <label>Image Src<input class="input" data-field="image-src" type="text"></label>
            <label>Alt Text<input class="input" data-field="image-alt" type="text"></label>
            <label>Full Src<input class="input" data-field="image-full" type="text"></label>
          `;
          list.appendChild(row);
        }
        if(action === "add-download"){
          const card = target.closest(".section-card");
          const list = card.querySelector("[data-download-list]");
          const row = document.createElement("div");
          row.className = "inline-row";
          row.dataset.downloadRow = "true";
          row.innerHTML = `
            <label>Label<input class="input" data-field="download-label" type="text"></label>
            <label>Href<input class="input" data-field="download-href" type="text"></label>
          `;
          list.appendChild(row);
        }
        if(action === "add-video"){
          const card = target.closest(".section-card");
          const list = card.querySelector("[data-video-list]");
          const row = document.createElement("div");
          row.className = "inline-row";
          row.dataset.videoRow = "true";
          row.innerHTML = `
            <label>Video URL<input class="input" data-field="video-src" type="text"></label>
            <label>Title<input class="input" data-field="video-title" type="text"></label>
            <label>Width<input class="input" data-field="video-width" type="text" value="560"></label>
            <label>Height<input class="input" data-field="video-height" type="text" value="315"></label>
          `;
          list.appendChild(row);
        }
        if(action === "add-revision"){
          const card = target.closest(".section-card");
          const list = card.querySelector("[data-revision-list]");
          const row = document.createElement("div");
          row.className = "inline-row";
          row.dataset.revisionRow = "true";
          row.innerHTML = `
            <label>Date<input class="input" data-field="rev-date" type="text" placeholder="YYYY-MM-DD"></label>
            <label>Revision<input class="input" data-field="rev-id" type="text"></label>
            <label>Description<input class="input" data-field="rev-desc" type="text"></label>
            <label>By<input class="input" data-field="rev-by" type="text"></label>
          `;
          list.appendChild(row);
        }
        if(action === "table-add-row"){
          const card = target.closest(".section-card");
          const table = card ? card.querySelector("table.table-editor") : null;
          if(!table) return;
          const headCells = Array.from(table.querySelectorAll("thead th"));
          const tbody = table.querySelector("tbody");
          const isFirstRow = !tbody || !tbody.children.length;
          const tr = document.createElement("tr");
          headCells.forEach(th => {
            const td = document.createElement("td");
            td.contentEditable = "true";
            td.dataset.colKey = th.dataset.colKey || "";
            if(table.dataset.tableType === "videos"){
              if(td.dataset.colKey === "title") td.textContent = "YouTube video player";
              if(td.dataset.colKey === "width") td.textContent = "560";
              if(td.dataset.colKey === "height") td.textContent = "315";
            }
            if(table.dataset.tableType === "revisions"){
              if(td.dataset.colKey === "date") td.textContent = new Date().toISOString().slice(0, 10);
              if(isFirstRow && td.dataset.colKey === "rev") td.textContent = "A1-01";
              if(isFirstRow && td.dataset.colKey === "desc") td.textContent = "Initial release";
              if(td.dataset.colKey === "by") td.textContent = getAuthor();
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        }
        if(action === "add-collection-row"){
          const list = $("panel-collection").querySelector("[data-collection-list]");
          if(!list) return;
          const row = document.createElement("div");
          row.className = "inline-row";
          row.dataset.collectionRow = "true";
          row.innerHTML = `
            <label>Part No<input class="input" data-field="row-part" type="text"></label>
            <label>Title<input class="input" data-field="row-title" type="text"></label>
            <label>Link Href<input class="input" data-field="row-href" type="text"></label>
            <label>Pieces/Panel<input class="input" data-field="row-pieces" type="text"></label>
          `;
          list.appendChild(row);
        }
        if(action === "tpl-save"){
          const next = collectTemplateState();
          saveTemplate(next);
          logTerminal("template", "Template saved");
        }
        if(action === "tpl-load"){
          if(!state.current) return;
          const next = extractTemplateFromHtml(state.editorText);
          saveTemplate(next);
          renderForm(state.formState);
          logTerminal("template", "Template loaded from file");
        }
        // AI Assist actions removed.
      });

      const commandBtn = $("commandRunBtn");
      const commandInput = $("commandInput");
      if(commandBtn && commandInput){
        commandBtn.addEventListener("click", () => {
          runCommand(commandInput.value);
          commandInput.value = "";
        });

        commandInput.addEventListener("keydown", (e) => {
          if(e.key === "Enter"){
            e.preventDefault();
            runCommand(commandInput.value);
            commandInput.value = "";
          }
        });
      }

      $("terminalSendBtn").addEventListener("click", () => {
        const input = $("terminalInput");
        const value = input.value.trim();
        if(value){
          logTerminal("user", value);
          runCommand(value.startsWith("@") ? value : `ai ${value}`);
        }
        input.value = "";
      });

      $("terminalInput").addEventListener("keydown", (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          const input = e.target;
          const value = input.value.trim();
          if(value){
            logTerminal("user", value);
            runCommand(value.startsWith("@") ? value : `ai ${value}`);
          }
          input.value = "";
        }
      });

      $("prefsBtn").addEventListener("click", () => {
        updateFolderLabel();
        $("authorInput").value = getAuthor();
        $("terminalDockInput").value = getTerminalDock();
        $("prefsModal").classList.add("open");
      });

      $("helpBtn").addEventListener("click", () => {
        $("helpModal").classList.add("open");
      });

      $("helpClose").addEventListener("click", () => {
        $("helpModal").classList.remove("open");
      });

      const folderPickBtn = $("folderPickBtn");
      if(folderPickBtn){
        folderPickBtn.addEventListener("click", async () => {
          await setFolderRoot();
        });
      }

      $("prefsCancel").addEventListener("click", () => {
        $("prefsModal").classList.remove("open");
      });

      $("prefsSave").addEventListener("click", () => {
        setBaseDir("draft/");
        setAuthor($("authorInput").value);
        setTerminalDock($("terminalDockInput").value);
        $("prefsModal").classList.remove("open");
        init();
      });

      $("sectionCancel").addEventListener("click", () => {
        state.editingSectionCard = null;
        $("sectionModal").classList.remove("open");
      });

      $("sectionSave").addEventListener("click", () => {
        const card = state.editingSectionCard;
        if(!card) return;
        card.dataset.sectionId = $("sectionIdInput").value.trim() || card.dataset.sectionId;
        card.dataset.sectionTab = $("sectionTabInput").value.trim();
        card.dataset.sectionTitle = $("sectionTitleInput").value.trim();
        const pills = [];
        if(card.dataset.sectionId) pills.push(`<span class="badge-pill">${escapeHtml(card.dataset.sectionId)}</span>`);
        if(card.dataset.sectionTab) pills.push(`<span class="badge-pill">${escapeHtml(card.dataset.sectionTab)}</span>`);
        if(card.dataset.sectionTitle) pills.push(`<span class="badge-pill">${escapeHtml(card.dataset.sectionTitle)}</span>`);
        const badgeRow = card.querySelector(".badge-row");
        if(badgeRow) badgeRow.innerHTML = pills.join("");
        $("sectionModal").classList.remove("open");
        state.editingSectionCard = null;
      });
    }

    async function init(){
      try{
        state.template = loadTemplate();
        state.baseDir = getBaseDir();
        await loadFolderRoot();
        updateFolderLabel();
        const ok = await ensureIndexLoaded();
        state.entries = listFromIndex(state.baseDir);
        state.filtered = state.entries.slice();
        $("fileCount").textContent = `${state.filtered.length} files`;
        if(ok && state.entries.length){
          setDataStatus(true, useFileSystemStore() ? "Index: folder" : "Index: draft");
        }else{
          setDataStatus(false, "Index: missing");
        }
        renderList();
        applyTerminalDock(getTerminalDock());
        logTerminal("system", "Ready");
      }catch(err){
        setDataStatus(false, "Index: missing");
      }
    }

    setupEditor();
    init();
  </script>
</body>
</html>
