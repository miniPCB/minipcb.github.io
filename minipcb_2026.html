<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Catalog Reader</title>
  <style>
    :root{
      --bg: #0f141b;
      --bg-soft: #141b24;
      --panel: #1b2430;
      --panel-2: #202b3a;
      --text: #e6edf3;
      --muted: #a6b4c3;
      --accent: #7bdcb5;
      --accent-2: #66a3ff;
      --danger: #ff7b7b;
      --border: rgba(255,255,255,0.08);
      --shadow: 0 20px 60px rgba(0,0,0,0.35);
      --radius: 14px;
      --mono: "Cascadia Mono", "SFMono-Regular", "Consolas", "Liberation Mono", monospace;
      --sans: "Space Grotesk", "Trebuchet MS", "Segoe UI", sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(102,163,255,0.25), transparent 60%),
        radial-gradient(1000px 600px at 90% 10%, rgba(123,220,181,0.2), transparent 65%),
        var(--bg);
    }

    .app{
      height:100vh;
      display:flex;
      flex-direction:column;
    }

    header{
      padding:22px 28px 16px;
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
      background: rgba(15,20,27,0.75);
      position: sticky;
      top:0;
      z-index:10;
    }

    .title{
      display:flex;
      align-items:center;
      gap:12px;
      font-size:22px;
      font-weight:600;
      letter-spacing:0.4px;
    }

    .title .badge{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:1px;
      padding:4px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
    }

    .layout{
      flex:1;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      padding:18px 22px 26px;
      min-height:0;
      overflow:hidden;
    }

    aside{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .sidebar-head{
      padding:16px 16px 12px;
      border-bottom:1px solid var(--border);
    }

    .sidebar-head .label{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.9px;
      color: var(--muted);
      margin-bottom:8px;
    }

    .search{
      display:flex;
      align-items:center;
      gap:8px;
      background: var(--panel-2);
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
    }

    .search input{
      background: transparent;
      border: none;
      color: var(--text);
      width:100%;
      font-size:14px;
      outline:none;
    }

    .meta-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
      color: var(--muted);
      font-size:12px;
    }

    .pill{
      padding:3px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      background: rgba(255,255,255,0.03);
    }

    .file-list{
      overflow:auto;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
      min-height:0;
    }

    .file-item{
      border:1px solid transparent;
      border-radius:12px;
      padding:10px 12px;
      background: rgba(255,255,255,0.02);
      cursor:pointer;
      transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
    }

    .file-item:hover{
      border-color: rgba(123,220,181,0.4);
      transform: translateY(-1px);
      background: rgba(123,220,181,0.08);
    }

    .file-item.active{
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.15);
      box-shadow: inset 0 0 0 1px rgba(102,163,255,0.35);
    }

    .file-item .name{
      font-weight:600;
      font-size:14px;
    }

    .file-item .sub{
      margin-top:6px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size:11px;
    }

    main{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .preview-head{
      padding:18px 20px 12px;
      border-bottom:1px solid var(--border);
      background: rgba(32,43,58,0.5);
    }

    .preview-title{
      font-size:18px;
      font-weight:600;
    }

    .preview-meta{
      margin-top:8px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      color: var(--muted);
      font-size:12px;
    }

    .preview{
      padding:18px 20px 32px;
      overflow:auto;
      min-height:0;
      flex:1;
    }

    .tabBar{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      margin-top:12px;
    }

    .tabBtn{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding:6px 10px;
      border-radius:10px;
      font-size:12px;
      letter-spacing:0.4px;
      text-transform:uppercase;
      cursor:pointer;
      transition: all 0.12s ease;
    }

    .tabBtn.active{
      color: var(--text);
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.18);
    }

    .tabPanel{
      display:none;
    }

    .tabPanel.active{
      display:block;
    }

    .imageGrid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap:12px;
    }

    .imageCard{
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.03);
      padding:10px;
    }

    .imageCard img{
      width:100%;
      border-radius:8px;
      display:block;
    }

    .imageCard .caption{
      margin-top:8px;
      font-size:12px;
      color: var(--muted);
    }

    .imageViewport{
      position: relative;
      height: auto;
      max-height: 70vh;
      overflow: auto;
      border-radius: 10px;
      background: rgba(8, 12, 18, 0.65);
      border: 1px solid var(--border);
      cursor: grab;
      width: 100%;
    }

    .imageViewport:active{
      cursor: grabbing;
    }

    .imageLayer{
      position: relative;
      display: inline-block;
    }

    .imageOverlay{
      position: absolute;
      inset: 0;
      background: rgba(120, 120, 120, 0.45);
      pointer-events: none;
    }

    .pageTabs{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-bottom:10px;
    }

    .pageBtn{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding:4px 8px;
      border-radius:8px;
      font-size:11px;
      letter-spacing:0.4px;
      text-transform:uppercase;
      cursor:pointer;
    }

    .pageBtn.active{
      color: var(--text);
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.18);
    }


    .imageViewport img{
      width: 100%;
      height: auto;
      display: block;
    }


    .empty{
      color: var(--muted);
      font-size:14px;
      padding:18px;
      border:1px dashed var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.02);
    }

    .md h1, .md h2, .md h3, .md h4{
      margin:1.3em 0 0.6em;
      line-height:1.2;
    }

    .md h1{ font-size:28px; }
    .md h2{ font-size:22px; }
    .md h3{ font-size:18px; }
    .md h4{ font-size:16px; }

    .md p{ line-height:1.6; margin:0.6em 0; }
    .md code{ font-family: var(--mono); font-size:0.92em; background: rgba(255,255,255,0.08); padding:2px 6px; border-radius:6px; }
    .md pre{ background: #0b1118; border:1px solid var(--border); border-radius:12px; padding:14px; overflow:auto; }
    .md pre code{ background: transparent; padding:0; }
    .md blockquote{ border-left:3px solid var(--accent-2); margin:1em 0; padding:0.4em 0.8em; color: var(--muted); background: rgba(102,163,255,0.08); }
    .md ul, .md ol{ padding-left:1.2em; margin:0.6em 0; }
    .md hr{ border:none; border-top:1px solid var(--border); margin:1.4em 0; }
    .md a{ color: var(--accent-2); text-decoration:none; }
    .md a:hover{ text-decoration:underline; }

    .md table{
      width:100%;
      border-collapse:collapse;
      margin:1em 0 1.4em;
      font-size:14px;
    }

    .md th, .md td{
      border:1px solid var(--border);
      padding:8px 10px;
      text-align:left;
      vertical-align:top;
    }

    .md th{
      background: rgba(255,255,255,0.05);
      font-weight:600;
    }

    .status{
      padding:8px 12px;
      border-radius:999px;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.8px;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }

    .status.ok{ background: rgba(123,220,181,0.12); color: var(--accent); border:1px solid rgba(123,220,181,0.35); }
    .status.err{ background: rgba(255,123,123,0.12); color: var(--danger); border:1px solid rgba(255,123,123,0.35); }

    .modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 16px;
    }

    .modal{
      width: min(560px, 96vw);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .modal h3{
      margin: 0 0 10px;
      font-size: 18px;
    }

    .modalGrid{
      display: grid;
      gap: 10px;
    }

    .modalActions{
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .input{
      width: 100%;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      font: inherit;
    }

    .contextMenu{
      position: fixed;
      display: none;
      z-index: 60;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--shadow);
      min-width: 160px;
      overflow: hidden;
    }

    .contextMenu button{
      width: 100%;
      border: none;
      background: transparent;
      color: var(--text);
      text-align: left;
      padding: 8px 10px;
      cursor: pointer;
    }

    .contextMenu button:hover{
      background: rgba(102,163,255,0.15);
    }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      aside{ order:2; }
      main{ order:1; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        Catalog Reader
      </div>
    </header>

    <div class="layout">
      <aside>
        <div class="sidebar-head">
          <div class="label">Files</div>
          <div class="search">
            <input id="searchInput" type="search" placeholder="Filter by filename or PN..." />
          </div>
          <div class="meta-row">
            <span class="pill" id="fileCount">Loading...</span>
            <span class="pill" id="dataStatus">Index: pending</span>
            <button class="tabBtn" id="btnOpenPrefs" type="button">Preferences</button>
          </div>
        </div>
        <div class="file-list" id="fileList"></div>
      </aside>

      <main>
        <div class="preview-head">
          <div class="preview-title" id="previewTitle">Select a markdown file</div>
          <div class="preview-meta" id="previewMeta"></div>
          <div class="tabBar" id="previewTabs">
            <button class="tabBtn active" data-tab="markdown">Markdown</button>
            <button class="tabBtn" data-tab="schematic">Schematic</button>
            <button class="tabBtn" data-tab="layout">Layout</button>
            <button class="tabBtn" data-tab="assembly">Assembly</button>
            <button class="tabBtn" data-tab="testing">Testing</button>
            <button class="tabBtn" data-tab="description">Description</button>
          </div>
        </div>
        <div class="preview" id="previewPane">
          <div class="tabPanel active" data-panel="markdown">
            <div class="empty" id="emptyState">Pick a file from the left to render its markdown.</div>
          </div>
          <div class="tabPanel" data-panel="schematic">
            <div class="empty">Schematic view placeholder. Add images or SVGs here.</div>
          </div>
          <div class="tabPanel" data-panel="layout">
            <div class="empty">Layout view placeholder. Add board renders or layout images here.</div>
          </div>
          <div class="tabPanel" data-panel="assembly">
            <div class="empty">Assembly view placeholder. Add assembly drawings or BOM links here.</div>
          </div>
          <div class="tabPanel" data-panel="testing">
            <div class="empty">Testing view placeholder. Add procedures or test results here.</div>
          </div>
          <div class="tabPanel" data-panel="description">
            <div class="empty">Description view placeholder. Select a file to generate a circuit summary.</div>
          </div>
        </div>
      </main>
    </div>
  </div>

  <div class="modalBack" id="prefsModal">
    <div class="modal">
      <h3>Catalog Reader Preferences</h3>
      <div class="modalGrid">
        <label>
          <div class="label">API Base URL</div>
          <input class="input" id="prefApiBaseInput" placeholder="https://your-vercel-project.vercel.app/api" />
        </label>
        <label>
          <div class="label">Model</div>
          <input class="input" id="prefModelInput" placeholder="gpt-4.1-mini" />
        </label>
        <label>
          <div class="label">Proxy Key (optional)</div>
          <input class="input" id="prefProxyKeyInput" placeholder="X-Proxy-Key value" />
        </label>
      </div>
      <div class="modalActions">
        <button class="btn" id="btnClosePrefs" type="button">Cancel</button>
        <button class="btn primary" id="btnSavePrefs" type="button">Save</button>
      </div>
    </div>
  </div>
  <div class="modalBack" id="aiProgressModal">
    <div class="modal">
      <h3>Generating Description</h3>
      <div class="modalGrid">
        <div class="label">Progress</div>
        <div class="input" id="aiProgressCounter">0</div>
        <div class="label">Log</div>
        <div class="input" id="aiProgressLog" style="height:140px; overflow:auto; white-space:pre-wrap;"></div>
      </div>
      <div class="modalActions">
        <button class="btn" id="btnCloseAiProgress" type="button">Hide</button>
      </div>
    </div>
  </div>
  <div class="contextMenu" id="descContextMenu">
    <button id="btnDescAiRephrase" type="button">AI rephrase</button>
  </div>

    <script src="schematics-data.js"></script>
<script>
    const state = {
      entries: [],
      filtered: [],
      current: null,
      requestId: 0,
      currentFetch: null,
      mdIndex: [],
      currentMarkdownText: "",
      descData: {}
    };

    const $ = (id) => document.getElementById(id);

    function parsePnFromTitle(title){
      const raw = (title || "").split("|")[0].trim();
      return raw || "";
    }

    function getHashPath(){
      const raw = decodeURIComponent(location.hash.replace(/^#/, ""));
      return raw.split("|")[0];
    }

    function setHashPath(path){
      const stamp = Date.now().toString(36);
      const next = encodeURIComponent(path || "") + "|" + stamp;
      history.replaceState(null, "", "#" + next);
    }

    function safeSetHashPath(path){
      try{
        setHashPath(path);
      }catch(err){
        const next = encodeURIComponent(path || "");
        location.hash = next;
      }
    }

    function escapeHtml(str){
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function formatInline(text){
      let out = escapeHtml(text);
      out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
      out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      out = out.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      out = out.replace(/_([^_]+)_/g, '<em>$1</em>');
      out = out.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
      return out;
    }

    function parseTable(lines, startIdx){
      const header = lines[startIdx];
      const divider = lines[startIdx + 1] || "";
      if(!/^\s*\|?\s*[-:| ]+\|?\s*$/.test(divider)) return null;

      const rows = [];
      let i = startIdx;
      while(i < lines.length && /\|/.test(lines[i])){
        rows.push(lines[i]);
        i += 1;
      }

      const parseRow = (row) => {
        const trimmed = row.trim();
        const strip = trimmed.startsWith("|") ? trimmed.slice(1) : trimmed;
        const strip2 = strip.endsWith("|") ? strip.slice(0, -1) : strip;
        return strip2.split("|").map(cell => formatInline(cell.trim()));
      };

      const headCells = parseRow(rows[0]);
      const bodyRows = rows.slice(2).map(parseRow);

      let html = '<table><thead><tr>';
      html += headCells.map(cell => `<th>${cell}</th>`).join("");
      html += '</tr></thead><tbody>';
      html += bodyRows.map(cells => `<tr>${cells.map(c => `<td>${c}</td>`).join("")}</tr>`).join("");
      html += '</tbody></table>';

      return { html, nextIndex: i };
    }

    function markdownToHtml(md){
      const lines = md.replace(/\r\n?/g, "\n").split("\n");
      const blocks = [];
      let i = 0;

      while(i < lines.length){
        const line = lines[i];

        if(line.trim() === ""){
          i += 1;
          continue;
        }

        if(line.startsWith("```")){
          const lang = line.slice(3).trim();
          let code = "";
          i += 1;
          while(i < lines.length && !lines[i].startsWith("```")){
            code += lines[i] + "\n";
            i += 1;
          }
          i += 1;
          blocks.push(`<pre><code data-lang="${escapeHtml(lang)}">${escapeHtml(code)}</code></pre>`);
          continue;
        }

        const table = parseTable(lines, i);
        if(table){
          blocks.push(table.html);
          i = table.nextIndex;
          continue;
        }

        if(/^#{1,6}\s/.test(line)){
          const level = line.match(/^#{1,6}/)[0].length;
          const content = line.replace(/^#{1,6}\s*/, "");
          blocks.push(`<h${level}>${formatInline(content)}</h${level}>`);
          i += 1;
          continue;
        }

        if(/^>\s?/.test(line)){
          let quote = line.replace(/^>\s?/, "");
          i += 1;
          while(i < lines.length && /^>\s?/.test(lines[i])){
            quote += "\n" + lines[i].replace(/^>\s?/, "");
            i += 1;
          }
          blocks.push(`<blockquote>${formatInline(quote)}</blockquote>`);
          continue;
        }

        if(/^(-{3,}|\*{3,})$/.test(line.trim())){
          blocks.push("<hr />");
          i += 1;
          continue;
        }

        if(/^\s*([-*+]\s+)/.test(line)){
          const items = [];
          while(i < lines.length && /^\s*([-*+]\s+)/.test(lines[i])){
            items.push(lines[i].replace(/^\s*([-*+]\s+)/, ""));
            i += 1;
          }
          blocks.push(`<ul>${items.map(item => `<li>${formatInline(item)}</li>`).join("")}</ul>`);
          continue;
        }

        if(/^\s*\d+\.\s+/.test(line)){
          const items = [];
          while(i < lines.length && /^\s*\d+\.\s+/.test(lines[i])){
            items.push(lines[i].replace(/^\s*\d+\.\s+/, ""));
            i += 1;
          }
          blocks.push(`<ol>${items.map(item => `<li>${formatInline(item)}</li>`).join("")}</ol>`);
          continue;
        }

        let para = line;
        i += 1;
        while(i < lines.length && lines[i].trim() !== "" &&
          !/^#{1,6}\s/.test(lines[i]) &&
          !/^>\s?/.test(lines[i]) &&
          !/^\s*([-*+]\s+)/.test(lines[i]) &&
          !/^\s*\d+\.\s+/.test(lines[i]) &&
          !/^(-{3,}|\*{3,})$/.test(lines[i].trim()) &&
          !/^\s*\|/.test(lines[i])
        ){
          para += " " + lines[i].trim();
          i += 1;
        }
        blocks.push(`<p>${formatInline(para)}</p>`);
      }

      return blocks.join("\n");
    }

    function extractPartlistRows(mdText){
      const lines = String(mdText || "").replace(/\r\n?/g, "\n").split("\n");
      let start = -1;
      for(let i = 0; i < lines.length; i += 1){
        if(/^\s*\|\s*REF DES\s*\|/i.test(lines[i])){
          start = i;
          break;
        }
      }
      if(start === -1) return [];
      const rows = [];
      for(let i = start + 2; i < lines.length; i += 1){
        const line = lines[i].trim();
        if(!line.startsWith("|")) break;
        const raw = line.replace(/^\|/, "").replace(/\|$/, "");
        const cols = raw.split("|").map(x => x.trim());
        if(cols.length < 3) continue;
        rows.push({ refdes: cols[0], partType: cols[1], value: cols[2] });
      }
      return rows;
    }

    function valueRangeHint(partType, value){
      const t = String(partType || "").toLowerCase();
      if(t.includes("resistor")) return "Typical range: 100 ohm to 1 Mohm. Lower values draw more current; higher values reduce current but increase noise and sensitivity to leakage.";
      if(t.includes("capacitor")) return "Typical range: 10 pF to 100 uF. Small values preserve bandwidth; large values improve filtering but increase startup/settling time.";
      if(t.includes("inductor")) return "Typical range: 1 uH to 1 mH. Higher inductance smooths current better but increases size and transient response time.";
      if(t.includes("diode")) return "Typical selection tradeoff: fast switching vs. lower forward drop. Schottky parts reduce drop but often leak more at temperature.";
      if(t.includes("transistor")) return "Typical tradeoff: gain, bandwidth, and power handling. Higher-gain devices simplify biasing but may reduce stability margins.";
      if(t.includes("integrated circuit") || t.includes("ic")) return "Typical tradeoff: precision, noise, bandwidth, and supply current. Better performance usually increases cost and power.";
      if(t.includes("connector")) return "Typical tradeoff: pin count, current rating, and mechanical robustness. Higher-current connectors are larger and cost more.";
      if(value) return `Value noted: ${value}. Pick this based on target bias point, gain/filter response, and tolerance margin.`;
      return "Choose value/rating based on operating point, tolerance stack-up, thermal limits, and manufacturability.";
    }

    function componentRoleHint(refdes, partType){
      const ref = String(refdes || "").toUpperCase();
      const t = String(partType || "").toLowerCase();
      if(ref.startsWith("R")) return "Biasing, gain setting, pull-up/down, or current limiting.";
      if(ref.startsWith("C")) return "Decoupling, filtering, AC coupling, or timing stabilization.";
      if(ref.startsWith("L")) return "Energy storage/filtering in supply or switching paths.";
      if(ref.startsWith("D")) return "Protection, steering, clamping, or rectification.";
      if(ref.startsWith("U")) return "Active control/processing function (amplifier, comparator, regulator, logic).";
      if(ref.startsWith("Q")) return "Active gain/switch element in analog or power stage.";
      if(ref.startsWith("TP")) return "Measurement access for bring-up and debugging.";
      if(ref.startsWith("P") || t.includes("connector")) return "External interface for signals, power, or I/O.";
      return "Supports signal integrity, biasing, protection, or interconnect behavior.";
    }

    function getApiConfig(){
      const baseRaw = (localStorage.getItem("prefApiBase") || "").trim();
      if(!baseRaw) return null;
      const base = baseRaw.replace(/\/+$/, "");
      return {
        chatUrl: `${base}/chat`,
        model: (localStorage.getItem("prefModel") || "gpt-4.1-mini").trim() || "gpt-4.1-mini",
        proxyKey: (localStorage.getItem("prefProxyKey") || "").trim()
      };
    }

    function loadDescData(){
      try{
        const raw = localStorage.getItem("circuit_descriptions");
        state.descData = raw ? JSON.parse(raw) : {};
      }catch(_){
        state.descData = {};
      }
    }

    function saveDescData(){
      localStorage.setItem("circuit_descriptions", JSON.stringify(state.descData || {}));
    }

    function getDescKey(entry){
      const pn = entry?.pn || "unknown";
      const rev = entry?.rev || "";
      return rev ? `${pn}__${rev}` : pn;
    }

    function getDescRecord(entry){
      const key = getDescKey(entry);
      return state.descData[key] || { intro: "", maturity: "M0", updated: "" };
    }

    function setDescRecord(entry, next){
      const key = getDescKey(entry);
      state.descData[key] = { ...getDescRecord(entry), ...next, updated: new Date().toISOString() };
      saveDescData();
    }

    function downloadDescJson(){
      const blob = new Blob([JSON.stringify(state.descData || {}, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "circuit_descriptions.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function promptImportDescJson(){
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "application/json";
      input.addEventListener("change", async () => {
        const file = input.files && input.files[0];
        if(!file) return;
        try{
          const text = await file.text();
          const parsed = JSON.parse(text);
          state.descData = parsed || {};
          saveDescData();
          renderDescriptionTab(state.current, state.currentMarkdownText || "", null);
        }catch(_){}
      });
      input.click();
    }

    async function aiRephraseIntro(entry, mdText, current){
      const api = getApiConfig();
      if(!api) throw new Error("API Base URL is not set.");
      const prompt = `Rephrase and improve the following circuit description into 3-5 concise sentences. Include function, performance characteristics (if available), and ideal applications. Be direct and technical.\n\n${current || mdText || ""}`;
      const payload = {
        model: api.model,
        input: [
          { role: "system", content: [{ type: "input_text", text: "Return plain text only. 3-5 sentences." }] },
          { role: "user", content: [{ type: "input_text", text: prompt }] }
        ]
      };
      const headers = { "Content-Type": "application/json" };
      if(api.proxyKey) headers["X-Proxy-Key"] = api.proxyKey;
      const resp = await fetch(api.chatUrl, { method: "POST", headers, body: JSON.stringify(payload) });
      if(!resp.ok){
        const txt = await resp.text();
        throw new Error(`AI request failed (${resp.status}): ${txt.slice(0, 120)}`);
      }
      const data = await resp.json();
      const text = extractResponseText(data);
      if(!text) throw new Error("AI returned empty response.");
      return text.trim();
    }

    function openPreferencesDialog(){
      const modal = $("prefsModal");
      if(!modal) return;
      $("prefApiBaseInput").value = localStorage.getItem("prefApiBase") || "";
      $("prefModelInput").value = localStorage.getItem("prefModel") || "gpt-4.1-mini";
      $("prefProxyKeyInput").value = localStorage.getItem("prefProxyKey") || "";
      modal.style.display = "flex";
    }

    function closePreferencesDialog(){
      const modal = $("prefsModal");
      if(modal) modal.style.display = "none";
    }

    function savePreferencesDialog(){
      const apiBase = ($("prefApiBaseInput")?.value || "").trim();
      const model = ($("prefModelInput")?.value || "gpt-4.1-mini").trim() || "gpt-4.1-mini";
      const proxyKey = ($("prefProxyKeyInput")?.value || "").trim();
      localStorage.setItem("prefApiBase", apiBase);
      localStorage.setItem("prefModel", model);
      localStorage.setItem("prefProxyKey", proxyKey);
      closePreferencesDialog();
    }

    function openAiProgressDialog(){
      const modal = $("aiProgressModal");
      if(!modal) return;
      $("aiProgressCounter").textContent = "0";
      $("aiProgressLog").textContent = "Starting AI request...";
      modal.style.display = "flex";
    }

    function closeAiProgressDialog(){
      const modal = $("aiProgressModal");
      if(modal) modal.style.display = "none";
    }

    function appendAiProgressLog(msg){
      const log = $("aiProgressLog");
      if(!log) return;
      log.textContent = `${log.textContent}\n${msg}`.trim();
      log.scrollTop = log.scrollHeight;
    }

    function extractResponseText(resp){
      if(!resp || typeof resp !== "object") return "";
      if(typeof resp.output_text === "string" && resp.output_text.trim()) return resp.output_text.trim();
      const out = [];
      const output = Array.isArray(resp.output) ? resp.output : [];
      for(const item of output){
        const content = Array.isArray(item?.content) ? item.content : [];
        for(const c of content){
          if(typeof c?.text === "string" && c.text.trim()) out.push(c.text.trim());
        }
      }
      return out.join("\n").trim();
    }

    async function findSchematicImageUrls(pn){
      const urls = [];
      if(!pn) return urls;
      for(let i = 1; i <= 12; i += 1){
        const page = String(i).padStart(2, "0");
        const rel = `images/${pn}_schematic_${page}.png`;
        try{
          const head = await fetch(rel, { method: "HEAD", cache: "no-store" });
          if(head.ok){
            urls.push(new URL(rel, location.origin).toString());
          }
        }catch(_){}
      }
      return urls.slice(0, 6);
    }

    async function generateAiDescriptionData(entry, mdText){
      const api = getApiConfig();
      if(!api) throw new Error("API Base URL is not set. Configure prefApiBase first.");
      const rows = extractPartlistRows(mdText);
      if(!rows.length) throw new Error("Partlist table not found in markdown.");
      const pn = entry?.pn || "Unknown PN";
      const imageUrls = await findSchematicImageUrls(pn);
      const cacheKey = `desc_ai_${pn}_${entry?.rev || ""}`;
      const cached = localStorage.getItem(cacheKey);
      if(cached){
        try{ return JSON.parse(cached); }catch(_){}
      }

      const refList = rows.map(r => `${r.refdes}|${r.partType}|${r.value || ""}`).join("\n");
      const userBlocks = [
        {
          type: "input_text",
          text:
            `Part number: ${pn}\n` +
            `Revision: ${entry?.rev || "unknown"}\n\n` +
            `Partlist rows (refdes|type|value):\n${refList}\n\n` +
            `Markdown source:\n${mdText}`
        }
      ];
      for(const url of imageUrls){
        userBlocks.push({ type: "input_image", image_url: url });
      }

      const payload = {
        model: api.model,
        input: [
          {
            role: "system",
            content: [
              {
                type: "input_text",
                text:
                  "You analyze circuits. Return strict JSON only. " +
                  "Schema: {\"summary\":\"...\",\"components\":[{\"refdes\":\"R1\",\"likely_function\":\"...\",\"confidence\":\"high|medium|low\",\"tradeoffs\":\"...\"}]}. " +
                  "Use markdown netlist/partlist/testpoints and schematic images to infer each component's role and value tradeoffs."
              }
            ]
          },
          { role: "user", content: userBlocks }
        ]
      };

      const headers = { "Content-Type": "application/json" };
      if(api.proxyKey) headers["X-Proxy-Key"] = api.proxyKey;
      const resp = await fetch(api.chatUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      });
      if(!resp.ok){
        const txt = await resp.text();
        throw new Error(`AI request failed (${resp.status}): ${txt.slice(0, 180)}`);
      }
      const data = await resp.json();
      const text = extractResponseText(data);
      if(!text) throw new Error("AI returned an empty response.");
      let parsed = null;
      try{
        parsed = JSON.parse(text);
      }catch(_){
        const m = text.match(/\{[\s\S]*\}/);
        if(m) parsed = JSON.parse(m[0]);
      }
      if(!parsed || !Array.isArray(parsed.components)){
        throw new Error("AI response JSON did not match expected schema.");
      }
      localStorage.setItem(cacheKey, JSON.stringify(parsed));
      return parsed;
    }

    function generateDescriptionMarkdown(entry, mdText, aiData, introOverride){
      const pn = entry?.pn || "Unknown PN";
      const rows = extractPartlistRows(mdText);
      const aiMap = new Map(
        (Array.isArray(aiData?.components) ? aiData.components : [])
          .map(c => [String(c.refdes || "").toUpperCase(), c])
      );
      const lines = [];
      lines.push(`# ${pn} Circuit Description`);
      lines.push("");
      const intro = (introOverride || "").trim() || (aiData?.summary || "This AI-generated overview summarizes likely circuit intent, component roles, and practical value-selection tradeoffs.");
      lines.push(intro);
      lines.push("");
      if(!rows.length){
        lines.push("No partlist table was found in this markdown, so a component-level description could not be generated.");
        return lines.join("\n");
      }

      const groups = new Map();
      for(const row of rows){
        const key = (row.partType || "Other").trim();
        if(!groups.has(key)) groups.set(key, []);
        groups.get(key).push(row);
      }

      lines.push("## Quick Summary");
      lines.push("");
      lines.push(`- Total listed parts: **${rows.length}**`);
      lines.push(`- Distinct part categories: **${groups.size}**`);
      lines.push("- Use the table and grouped sections below to find reference-specific tradeoffs quickly.");
      lines.push("");

      lines.push("## Components by Reference Designator");
      lines.push("");
      lines.push("| RefDes | Type | Nominal | Likely Function | Confidence |");
      lines.push("| --- | --- | --- | --- | --- |");
      for(const row of rows){
        const ref = row.refdes || "(unknown)";
        const kind = row.partType || "Component";
        const val = row.value || "not specified";
        const ai = aiMap.get(String(ref).toUpperCase());
        const fn = ai?.likely_function || componentRoleHint(ref, kind);
        const conf = ai?.confidence || "-";
        lines.push(`| ${ref} | ${kind} | ${val} | ${fn} | ${conf} |`);
      }
      lines.push("");

      lines.push("## Value Ranges and Tradeoffs by Component Type");
      lines.push("");
      for(const [kind, items] of groups.entries()){
        const groupedRefs = items.map(x => String(x.refdes || "").toUpperCase());
        const aiNotes = groupedRefs
          .map(r => aiMap.get(r)?.tradeoffs)
          .filter(Boolean);
        const tradeoffText = aiNotes.length ? aiNotes[0] : valueRangeHint(kind, items[0]?.value || "");
        lines.push(`### ${kind}`);
        lines.push("");
        lines.push(`- Reference designators: ${items.map(x => x.refdes || "?").join(", ")}`);
        lines.push(`- Typical range guidance: ${tradeoffText}`);
        lines.push("");
      }

      lines.push("## Cross-Cutting Selection Notes");
      lines.push("");
      lines.push("- Tighter tolerances improve repeatability but increase BOM cost.");
      lines.push("- Higher bandwidth choices improve response speed but may increase noise/EMI sensitivity.");
      lines.push("- Larger safety margins improve robustness but can reduce efficiency or dynamic performance.");
      lines.push("- Derating and temperature margins usually improve reliability at the expense of size/cost.");
      return lines.join("\n");
    }

    function renderDescriptionTab(entry, mdText, aiData){
      const panel = document.querySelector('.tabPanel[data-panel="description"]');
      if(!panel) return;
      const rec = getDescRecord(entry);
      const doc = generateDescriptionMarkdown(entry, mdText, aiData || null, rec.intro || "");
      panel.innerHTML = `
        <div style="margin-bottom:12px;">
          <div class="label">Circuit Description (3-5 sentences)</div>
          <textarea class="input" id="descIntro" rows="5" spellcheck="true" placeholder="Describe circuit function, performance characteristics, and ideal applications.">${escapeHtml(rec.intro || "")}</textarea>
        </div>
        <div class="md">${markdownToHtml(doc)}</div>`;
      const introEl = panel.querySelector("#descIntro");
      if(introEl){
        introEl.addEventListener("input", () => {
          setDescRecord(state.current, { intro: introEl.value });
        });
        introEl.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          const menu = $("descContextMenu");
          if(!menu) return;
          menu.style.display = "block";
          menu.style.left = `${e.clientX}px`;
          menu.style.top = `${e.clientY}px`;
          menu.setAttribute("data-field", "descIntro");
        });
      }
    }

    function renderImages(entry){
      const schematicPanel = document.querySelector('.tabPanel[data-panel="schematic"]');
      const layoutPanel = document.querySelector('.tabPanel[data-panel="layout"]');
      if(!schematicPanel || !layoutPanel) return;

      const pn = entry && entry.pn ? entry.pn : '';
      if(!pn){
        schematicPanel.innerHTML = '<div class="empty">No PN found for this file.</div>';
        layoutPanel.innerHTML = '<div class="empty">No PN found for this file.</div>';
        return;
      }

      schematicPanel.innerHTML = '<div class="empty">Loading schematics...</div>';
      layoutPanel.innerHTML = '<div class="empty">Loading layout...</div>';

      const found = [];
      const maxPages = 12;
      let checked = 0;

      const tryFinishSchematics = () => {
        checked += 1;
        if(checked < maxPages) return;
        if(found.length){
          found.sort((a, b) => a.order - b.order);
          const buttons = found.map((it, idx) =>
            `<button class="pageBtn${idx == 0 ? ' active' : ''}" data-src="${it.src}" data-label="${it.label}">${it.label}</button>`
          ).join('');
          const first = found[0];
          schematicPanel.innerHTML = `
            <div class="pageTabs" data-pages="schematic">${buttons}</div>
            <div class="imageCard">
              <div class="imageViewport" data-zoom="1">
                <div class="imageLayer">
                  <img src="${first.src}" alt="${first.label}" />
                  <div class="imageOverlay"></div>
                </div>
              </div>
              <div class="caption" id="schematicCaption">${first.label}</div>
            </div>`;

          const tabs = schematicPanel.querySelector('.pageTabs');
          tabs.addEventListener('click', (e) => {
            const btn = e.target.closest('.pageBtn');
            if(!btn) return;
            tabs.querySelectorAll('.pageBtn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const img = schematicPanel.querySelector('img');
            const cap = schematicPanel.querySelector('#schematicCaption');
            if(img) img.src = btn.getAttribute('data-src') || '';
            if(cap) cap.textContent = btn.getAttribute('data-label') || '';
            const vp = schematicPanel.querySelector('.imageViewport');
            if(vp) vp.setAttribute('data-ready', 'false');
            setupImageInteractions(schematicPanel);
          });

          setupImageInteractions(schematicPanel);
        }else{
          schematicPanel.innerHTML = '<div class="empty">No schematic images found for this PN.</div>';
        }
      };

      for(let i = 1; i <= maxPages; i += 1){
        const page = String(i).padStart(2, '0');
        const src = `images/${pn}_schematic_${page}.png`;
        const img = new Image();
        img.onload = () => {
          found.push({
            src,
            label: `${pn} schematic ${page}`,
            order: Number(page)
          });
          tryFinishSchematics();
        };
        img.onerror = () => {
          tryFinishSchematics();
        };
        img.src = src;
      }

      const layoutSrc = `images/${pn}_components_top.png`;
      const layoutImg = new Image();
      layoutImg.onload = () => {
        layoutPanel.innerHTML = `
          <div class="imageGrid">
            <div class="imageCard">
              <div class="imageViewport" data-zoom="1">
                <div class="imageLayer">
                  <img src="${layoutSrc}" alt="${pn} components top" />
                  <div class="imageOverlay"></div>
                </div>
              </div>
              <div class="caption">${pn} components top</div>
            </div>
          </div>`;
        setupImageInteractions(layoutPanel);
      };
      layoutImg.onerror = () => {
        layoutPanel.innerHTML = '<div class="empty">No layout image found for this PN.</div>';
      };
      layoutImg.src = layoutSrc;
    }

    function setStatus(ok, message){
      const el = $("dataStatus");
      el.textContent = message;
      el.className = ok ? "pill status ok" : "pill status err";
    }

    function renderList(){
      const list = $("fileList");
      list.innerHTML = "";
      if(!state.filtered.length){
        list.innerHTML = '<div class="empty">No files match the filter.</div>';
        return;
      }

      for(const entry of state.filtered){
        const item = document.createElement("div");
        item.className = "file-item" + (state.current && state.current.pn === entry.pn ? " active" : "");
        item.dataset.pn = entry.pn || "";
        item.innerHTML = `
          <div class="name">${escapeHtml(entry.title || entry.pn || entry.filename || "")}</div>
          <div class="sub">
            ${entry.pn ? `<span class="pill">${escapeHtml(entry.pn)}</span>` : ""}
            ${entry.rev ? `<span class="pill">${escapeHtml(entry.rev)}</span>` : ""}
            ${entry.kind ? `<span class="pill">${escapeHtml(entry.kind)}</span>` : ""}
            ${entry.hasMarkdown ? `<span class="pill">md</span>` : `<span class="pill">no md</span>`}
          </div>
        `;
        item.addEventListener("click", () => selectEntry(entry));
        list.appendChild(item);
      }
    }

    function updateMeta(entry){
      const meta = $("previewMeta");
      meta.innerHTML = "";
      if(!entry){
        return;
      }
      const parts = [];
      if(entry.pn) parts.push(`PN: ${escapeHtml(entry.pn)}`);
      if(entry.rev) parts.push(`REV: ${escapeHtml(entry.rev)}`);
      if(entry.kind) parts.push(`KIND: ${escapeHtml(entry.kind)}`);
      if(entry.mtime) parts.push(`Updated: ${escapeHtml(entry.mtime)}`);
      meta.innerHTML = parts.map(p => `<span class="pill">${p}</span>`).join("");
    }

    function compareRevDesc(a, b){
      const parse = (rev) => {
        const m = String(rev || "").match(/^([A-Z]+)(\d+)-(\d+)$/i);
        if(!m) return { stage: "", major: -1, minor: -1 };
        return { stage: m[1].toUpperCase(), major: Number(m[2]), minor: Number(m[3]) };
      };
      const ra = parse(a);
      const rb = parse(b);
      if(ra.stage !== rb.stage) return ra.stage < rb.stage ? 1 : -1;
      if(ra.major !== rb.major) return rb.major - ra.major;
      return rb.minor - ra.minor;
    }

    async function resolveMdPathForEntry(entry){
      if(entry?.mdPath) return entry.mdPath;
      const pn = entry?.pn || "";
      if(!pn) return "";

      const existing = (state.mdIndex || []).filter(x => x && x.pn === pn);
      if(existing.length){
        existing.sort((a, b) => compareRevDesc(a.rev, b.rev));
        const best = existing[0];
        if(best?.path){
          entry.mdPath = best.path;
          entry.filename = best.filename || entry.filename || "";
          entry.rev = best.rev || entry.rev || "";
          entry.kind = best.kind || entry.kind || "";
          entry.hasMarkdown = true;
          return best.path;
        }
      }

      // Fallback probe when index.json is stale: try common A1-XX schematic names.
      for(let i = 30; i >= 1; i -= 1){
        const rev = String(i).padStart(2, "0");
        const candidate = `md/${pn}_A1-${rev}_sch.md`;
        try{
          const res = await fetch(candidate, { method: "HEAD", cache: "no-store" });
          if(res.ok){
            entry.mdPath = candidate;
            entry.filename = `${pn}_A1-${rev}_sch.md`;
            entry.rev = `A1-${rev}`;
            entry.kind = "sch";
            entry.hasMarkdown = true;
            return candidate;
          }
        }catch(_){}
      }

      return "";
    }

    function setupImageInteractions(scope){
      const viewports = (scope || document).querySelectorAll(".imageViewport");
      const storedZoom = parseFloat(localStorage.getItem("imageZoom") || "1");

      const applyZoom = (vp, layer, img, zoom) => {
        if(!layer || !img) return;
        const naturalW = img.naturalWidth || img.width || 0;
        const naturalH = img.naturalHeight || img.height || 0;
        if(!naturalW || !naturalH) return;
        layer.style.width = `${naturalW * zoom}px`;
        layer.style.height = `${naturalH * zoom}px`;
        vp.setAttribute("data-zoom", String(zoom));
      };

      viewports.forEach(vp => {
        const layer = vp.querySelector(".imageLayer");
        const img = vp.querySelector("img");
        if(!layer || !img) return;

        const initZoom = storedZoom || 1;
        if(vp.getAttribute("data-ready") == "true"){
          applyZoom(vp, layer, img, initZoom);
          return;
        }
        vp.setAttribute("data-ready", "true");
        if(!img.complete){
          img.addEventListener("load", () => applyZoom(vp, layer, img, initZoom), { once: true });
        }
        applyZoom(vp, layer, img, initZoom);

        let isPanning = false;
        let startX = 0;
        let startY = 0;
        let scrollLeft = 0;
        let scrollTop = 0;

        vp.addEventListener("pointerdown", (e) => {
          if(e.button !== 0) return;
          isPanning = true;
          vp.setPointerCapture(e.pointerId);
          const rect = vp.getBoundingClientRect();
          startX = e.clientX - rect.left;
          startY = e.clientY - rect.top;
          scrollLeft = vp.scrollLeft;
          scrollTop = vp.scrollTop;
        });

        vp.addEventListener("pointerup", (e) => {
          isPanning = false;
          try{ vp.releasePointerCapture(e.pointerId); }catch(_){}
        });

        vp.addEventListener("pointerleave", () => { isPanning = false; });

        vp.addEventListener("pointermove", (e) => {
          if(!isPanning) return;
          e.preventDefault();
          const rect = vp.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          vp.scrollLeft = scrollLeft - (x - startX);
          vp.scrollTop = scrollTop - (y - startY);
        });

        vp.addEventListener("wheel", (e) => {
          e.preventDefault();
          const current = parseFloat(vp.getAttribute("data-zoom") || "1");
          const delta = e.deltaY < 0 ? 0.05 : -0.05;
          const next = Math.min(4, Math.max(0.1, current + delta));
          localStorage.setItem("imageZoom", String(next));
          applyZoom(vp, layer, img, next);
        }, { passive: false });

        vp.addEventListener("dblclick", (e) => {
          e.preventDefault();
          const reset = 1;
          localStorage.setItem("imageZoom", String(reset));
          applyZoom(vp, layer, img, reset);
        });
      });
    }

    async function selectEntry(entry){
      let path = entry && entry.mdPath ? entry.mdPath : "";
      try{
        state.current = entry;
        const requestId = ++state.requestId;
        $("previewTitle").textContent = entry?.title || entry?.pn || entry?.filename || "";
        updateMeta(entry);
        renderImages(entry);
        const emptyState = $("emptyState");
        if(emptyState) emptyState.style.display = "none";
        const mdPanel = document.querySelector(".tabPanel[data-panel=\"markdown\"]");
        path = await resolveMdPathForEntry(entry);
        const hashTarget = path || entry?.pn || entry?.filename || "";
        safeSetHashPath(hashTarget);
      if(!path){
        if(mdPanel) mdPanel.innerHTML = `<div class="empty">No markdown found for this miniPCB. Open schematic page: <a href="${escapeHtml(entry?.href || "#")}" target="_blank" rel="noopener">${escapeHtml(entry?.href || "link")}</a>.</div>`;
        state.currentMarkdownText = "";
        renderDescriptionTab(entry, "", null);
        return;
      }
        if(mdPanel) mdPanel.innerHTML = '<div class="empty">Loading...</div>';

        if(state.currentFetch && typeof state.currentFetch.abort === "function"){
          state.currentFetch.abort();
        }
        const controller = typeof AbortController !== "undefined" ? new AbortController() : null;
        state.currentFetch = controller;

        const url = path + "?v=" + Date.now();

        const timeoutMs = 6000;
        const timeout = new Promise((_, reject) =>
          setTimeout(() => {
            if(controller) controller.abort();
            reject(new Error("Request timed out"));
          }, timeoutMs)
        );

        const res = await Promise.race([
          fetch(url, { cache: "no-store", signal: controller ? controller.signal : undefined }),
          timeout
        ]);
        if(requestId !== state.requestId) return;
        if(!res.ok) throw new Error(`Failed to load ${path} (${res.status})`);
        const text = await res.text();
        if(requestId !== state.requestId) return;
        const html = markdownToHtml(text);
        if(mdPanel) mdPanel.innerHTML = `<div class="md" data-path="${escapeHtml(path)}">${html}</div>`;
        state.currentMarkdownText = text;
        renderDescriptionTab(entry, text, null);
      }catch(err){
        const msg = err?.message || "Unknown error";
        const mdPanel = document.querySelector(".tabPanel[data-panel=\"markdown\"]");
        if(!path){
          if(mdPanel) mdPanel.innerHTML = `<div class="empty">No markdown found for this miniPCB. Open schematic page: <a href="${escapeHtml(entry?.href || "#")}" target="_blank" rel="noopener">${escapeHtml(entry?.href || "link")}</a>.</div>`;
          state.currentMarkdownText = "";
          renderDescriptionTab(entry, "", null);
          return;
        }
        if(mdPanel) mdPanel.innerHTML = `<div class="empty">${escapeHtml(msg)}</div>`;
        state.currentMarkdownText = "";
        renderDescriptionTab(entry, "", null);
      }

      renderList();
    }

    function filterList(query){
      const q = query.trim().toLowerCase();
      if(!q){
        state.filtered = state.entries.slice();
      }else{
        state.filtered = state.entries.filter(e => {
          return [e.title, e.pn, e.rev, e.kind].some(v => (v || "").toLowerCase().includes(q));
        });
      }
      $("fileCount").textContent = `${state.filtered.length} items`;
      renderList();
    }

    async function loadIndex(){
      let mdEntries = [];
      try{
        const res = await fetch("md/index.json");
        if(!res.ok) throw new Error("Index not found");
        const data = await res.json();
        mdEntries = Array.isArray(data.entries) ? data.entries.slice() : [];
        setStatus(true, "Index: loaded");
      }catch(err){
        setStatus(false, "Index: missing");
      }

      state.mdIndex = mdEntries;
      const mdByPn = new Map();
      mdEntries.forEach(entry => {
        if(entry.pn) mdByPn.set(entry.pn, entry);
      });

      const catalog = Array.isArray(window.SCHEMATICS) ? window.SCHEMATICS : [];
      const merged = catalog.map(item => {
        const pn = parsePnFromTitle(item.title);
        const md = mdByPn.get(pn);
        return {
          title: item.title,
          href: item.href,
          pn,
          mdPath: md ? md.path : "",
          filename: md ? md.filename : "",
          rev: md ? md.rev : "",
          kind: md ? md.kind : "",
          mtime: md ? md.mtime : "",
          hasMarkdown: !!md
        };
      });

      mdEntries.forEach(md => {
        if(!md.pn) return;
        if(!merged.find(e => e.pn === md.pn)){
          merged.push({
            title: md.filename,
            href: "",
            pn: md.pn,
            mdPath: md.path,
            filename: md.filename,
            rev: md.rev,
            kind: md.kind,
            mtime: md.mtime,
            hasMarkdown: true
          });
        }
      });

      merged.sort((a, b) => (a.pn || "").localeCompare(b.pn || ""));
      state.entries = merged;
      state.filtered = merged.slice();
      $("fileCount").textContent = `${state.filtered.length} items`;
      renderList();

      const hashPath = getHashPath();
      const target = state.entries.find(e => e.mdPath === hashPath || e.filename === hashPath || e.pn === hashPath);
      if(target){
        selectEntry(target);
      }
    }

    $("searchInput").addEventListener("input", (e) => filterList(e.target.value));
    const openPrefsBtn = $("btnOpenPrefs");
    if(openPrefsBtn) openPrefsBtn.addEventListener("click", openPreferencesDialog);
    const closePrefsBtn = $("btnClosePrefs");
    if(closePrefsBtn) closePrefsBtn.addEventListener("click", closePreferencesDialog);
    const savePrefsBtn = $("btnSavePrefs");
    if(savePrefsBtn) savePrefsBtn.addEventListener("click", savePreferencesDialog);
    const prefsModal = $("prefsModal");
    if(prefsModal){
      prefsModal.addEventListener("click", (e) => {
        if(e.target === prefsModal) closePreferencesDialog();
      });
    }
    const aiProgressModal = $("aiProgressModal");
    if(aiProgressModal){
      aiProgressModal.addEventListener("click", (e) => {
        if(e.target === aiProgressModal) closeAiProgressDialog();
      });
    }
    const closeAiBtn = $("btnCloseAiProgress");
    if(closeAiBtn) closeAiBtn.addEventListener("click", closeAiProgressDialog);
    loadDescData();
    const descMenu = $("descContextMenu");
    document.addEventListener("click", (e) => {
      if(descMenu && e.target !== descMenu) descMenu.style.display = "none";
    });
    const rephraseBtn = $("btnDescAiRephrase");
    if(rephraseBtn){
      rephraseBtn.addEventListener("click", async () => {
        if(descMenu) descMenu.style.display = "none";
        const introEl = $("descIntro");
        if(!introEl) return;
        if(!getApiConfig()){
          openPreferencesDialog();
          return;
        }
        try{
          rephraseBtn.disabled = true;
          const text = await aiRephraseIntro(state.current, state.currentMarkdownText || "", introEl.value);
          introEl.value = text;
          setDescRecord(state.current, { intro: text });
        }catch(_){}
        rephraseBtn.disabled = false;
      });
    }
    function setupTabs(){
      const tabs = document.querySelectorAll("#previewTabs .tabBtn");
      const panels = document.querySelectorAll(".tabPanel");
      tabs.forEach(btn => {
        btn.addEventListener("click", () => {
          tabs.forEach(t => t.classList.remove("active"));
          btn.classList.add("active");
          const id = btn.getAttribute("data-tab");
          panels.forEach(p => {
            p.classList.toggle("active", p.getAttribute("data-panel") === id);
          });
        });
      });
    }

    window.addEventListener("hashchange", () => {
      const hashPath = getHashPath();
      const target = state.entries.find(e => e.path === hashPath || e.filename === hashPath);
      if(target && (!state.current || target.path !== state.current.path)) selectEntry(target);
    });

    setupTabs();
    loadIndex();
    if(!getApiConfig()){
      setTimeout(openPreferencesDialog, 150);
    }
  </script>
  </body>
</html>
