<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Catalog Reader</title>
  <style>
    :root{
      --bg: #0f141b;
      --bg-soft: #141b24;
      --panel: #1b2430;
      --panel-2: #202b3a;
      --text: #e6edf3;
      --muted: #a6b4c3;
      --accent: #7bdcb5;
      --accent-2: #66a3ff;
      --danger: #ff7b7b;
      --border: rgba(255,255,255,0.08);
      --shadow: 0 20px 60px rgba(0,0,0,0.35);
      --radius: 14px;
      --mono: "Cascadia Mono", "SFMono-Regular", "Consolas", "Liberation Mono", monospace;
      --sans: "Space Grotesk", "Trebuchet MS", "Segoe UI", sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(102,163,255,0.25), transparent 60%),
        radial-gradient(1000px 600px at 90% 10%, rgba(123,220,181,0.2), transparent 65%),
        var(--bg);
    }

    .app{
      height:100vh;
      display:flex;
      flex-direction:column;
    }

    header{
      padding:22px 28px 16px;
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
      background: rgba(15,20,27,0.75);
      position: sticky;
      top:0;
      z-index:10;
    }

    .title{
      display:flex;
      align-items:center;
      gap:12px;
      font-size:22px;
      font-weight:600;
      letter-spacing:0.4px;
    }

    .title .badge{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:1px;
      padding:4px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
    }

    .layout{
      flex:1;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      padding:18px 22px 26px;
      min-height:0;
      overflow:hidden;
    }

    aside{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .sidebar-head{
      padding:16px 16px 12px;
      border-bottom:1px solid var(--border);
    }

    .sidebar-head .label{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.9px;
      color: var(--muted);
      margin-bottom:8px;
    }

    .search{
      display:flex;
      align-items:center;
      gap:8px;
      background: var(--panel-2);
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
    }

    .search input{
      background: transparent;
      border: none;
      color: var(--text);
      width:100%;
      font-size:14px;
      outline:none;
    }

    .meta-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
      color: var(--muted);
      font-size:12px;
    }

    .pill{
      padding:3px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      background: rgba(255,255,255,0.03);
    }

    .file-list{
      overflow:auto;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
      min-height:0;
    }

    .file-item{
      border:1px solid transparent;
      border-radius:12px;
      padding:10px 12px;
      background: rgba(255,255,255,0.02);
      cursor:pointer;
      transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
    }

    .file-item:hover{
      border-color: rgba(123,220,181,0.4);
      transform: translateY(-1px);
      background: rgba(123,220,181,0.08);
    }

    .file-item.active{
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.15);
      box-shadow: inset 0 0 0 1px rgba(102,163,255,0.35);
    }

    .file-item .name{
      font-weight:600;
      font-size:14px;
    }

    .file-item .sub{
      margin-top:6px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size:11px;
    }

    main{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .preview-head{
      padding:18px 20px 12px;
      border-bottom:1px solid var(--border);
      background: rgba(32,43,58,0.5);
    }

    .preview-title{
      font-size:18px;
      font-weight:600;
    }

    .preview-meta{
      margin-top:8px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      color: var(--muted);
      font-size:12px;
    }

    .preview{
      padding:18px 20px 32px;
      overflow:auto;
      min-height:0;
      flex:1;
    }

    .tabBar{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      margin-top:12px;
    }

    .tabBtn{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding:6px 10px;
      border-radius:10px;
      font-size:12px;
      letter-spacing:0.4px;
      text-transform:uppercase;
      cursor:pointer;
      transition: all 0.12s ease;
    }

    .tabBtn.active{
      color: var(--text);
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.18);
    }

    .tabPanel{
      display:none;
    }

    .tabPanel.active{
      display:block;
    }

    .imageGrid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap:12px;
    }

    .imageCard{
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.03);
      padding:10px;
    }

    .imageCard img{
      width:100%;
      border-radius:8px;
      display:block;
    }

    .imageCard .caption{
      margin-top:8px;
      font-size:12px;
      color: var(--muted);
    }

    .imageViewport{
      position: relative;
      height: auto;
      max-height: 70vh;
      overflow: auto;
      border-radius: 10px;
      background: rgba(8, 12, 18, 0.65);
      border: 1px solid var(--border);
      cursor: grab;
      width: 100%;
    }

    .imageViewport:active{
      cursor: grabbing;
    }

    .imageLayer{
      position: relative;
      display: inline-block;
    }

    .imageOverlay{
      position: absolute;
      inset: 0;
      background: rgba(120, 120, 120, 0.45);
      pointer-events: none;
    }

    .pageTabs{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-bottom:10px;
    }

    .pageBtn{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding:4px 8px;
      border-radius:8px;
      font-size:11px;
      letter-spacing:0.4px;
      text-transform:uppercase;
      cursor:pointer;
    }

    .pageBtn.active{
      color: var(--text);
      border-color: rgba(102,163,255,0.8);
      background: rgba(102,163,255,0.18);
    }


    .imageViewport img{
      width: 100%;
      height: auto;
      display: block;
    }


    .empty{
      color: var(--muted);
      font-size:14px;
      padding:18px;
      border:1px dashed var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.02);
    }

    .md h1, .md h2, .md h3, .md h4{
      margin:1.3em 0 0.6em;
      line-height:1.2;
    }

    .md h1{ font-size:28px; }
    .md h2{ font-size:22px; }
    .md h3{ font-size:18px; }
    .md h4{ font-size:16px; }

    .md p{ line-height:1.6; margin:0.6em 0; }
    .md code{ font-family: var(--mono); font-size:0.92em; background: rgba(255,255,255,0.08); padding:2px 6px; border-radius:6px; }
    .md pre{ background: #0b1118; border:1px solid var(--border); border-radius:12px; padding:14px; overflow:auto; }
    .md pre code{ background: transparent; padding:0; }
    .md blockquote{ border-left:3px solid var(--accent-2); margin:1em 0; padding:0.4em 0.8em; color: var(--muted); background: rgba(102,163,255,0.08); }
    .md ul, .md ol{ padding-left:1.2em; margin:0.6em 0; }
    .md hr{ border:none; border-top:1px solid var(--border); margin:1.4em 0; }
    .md a{ color: var(--accent-2); text-decoration:none; }
    .md a:hover{ text-decoration:underline; }

    .md table{
      width:100%;
      border-collapse:collapse;
      margin:1em 0 1.4em;
      font-size:14px;
    }

    .md th, .md td{
      border:1px solid var(--border);
      padding:8px 10px;
      text-align:left;
      vertical-align:top;
    }

    .md th{
      background: rgba(255,255,255,0.05);
      font-weight:600;
    }

    .jsonWrap{
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.02);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:280px;
    }

    .jsonToolbar{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }

    .jsonUrl{
      flex:1;
      min-width:240px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 10px;
      font-size:12px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
      font-family: var(--mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .jsonBtn{
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 10px;
      font-size:12px;
      color: var(--text);
      background: rgba(255,255,255,0.05);
      cursor:pointer;
    }

    .jsonBtn:hover{
      border-color: rgba(102,163,255,0.7);
      background: rgba(102,163,255,0.15);
    }

    .jsonStatus{
      font-size:12px;
      color: var(--muted);
    }

    .jsonViewport{
      border:1px solid rgba(42,52,71,0.6);
      border-radius:10px;
      background: rgba(15,20,30,0.45);
      overflow:auto;
      min-height:260px;
      flex:1;
      padding:10px;
    }

    .jsonTree{
      display:flex;
      flex-direction:column;
      gap:8px;
      font-family: var(--mono);
      font-size:12px;
    }

    .jsonEntry{
      display:flex;
      align-items:flex-start;
      gap:6px;
      flex-wrap:wrap;
    }

    .jsonChild{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-left:10px;
      border-left:1px dashed rgba(102,163,255,0.3);
      padding-left:10px;
      min-width:0;
      flex:1;
    }

    .jsonBubble{
      display:inline-flex;
      align-items:center;
      border-radius:999px;
      padding:3px 9px;
      line-height:1.2;
      max-width:100%;
      word-break:break-word;
      white-space:normal;
    }

    .jsonKeyBubble{
      background: rgba(102,163,255,0.18);
      border:1px solid rgba(102,163,255,0.45);
      color: #c6e3ff;
      font-weight:600;
    }

    .jsonValBubble{
      background: rgba(123,220,181,0.15);
      border:1px solid rgba(123,220,181,0.45);
      color: #c8ffe2;
    }

    .jsonValBubble.type-number{
      background: rgba(255,211,124,0.15);
      border-color: rgba(255,211,124,0.45);
      color: #ffeec3;
    }

    .jsonValBubble.type-boolean{
      background: rgba(206,160,255,0.15);
      border-color: rgba(206,160,255,0.45);
      color: #f0deff;
    }

    .jsonValBubble.type-null{
      background: rgba(255,123,123,0.15);
      border-color: rgba(255,123,123,0.45);
      color: #ffd6d6;
    }

    .fmeaWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:60vh;
    }

    .fmeaCard{
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(255,255,255,0.02);
      padding:10px;
      min-height:0;
    }

    .fmeaSubTabs{
      margin-bottom:0;
    }

    .fmeaSubPanel{
      display:none;
      min-height:0;
    }

    .fmeaSubPanel.active{
      display:block;
    }

    .fmeaTitle{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.6px;
      color: var(--muted);
      margin-bottom:8px;
    }

    .fmeaPath{
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 10px;
      font-size:12px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
      font-family: var(--mono);
      margin-bottom:8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .fmeaSearchRow{
      display:flex;
      gap:8px;
      align-items:center;
      margin-bottom:8px;
    }

    .fmeaSearchInput{
      flex:1;
      min-width:180px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 10px;
      font-size:12px;
      color: var(--text);
      background: rgba(255,255,255,0.04);
    }

    .fmeaSearchCount{
      font-size:12px;
      color: var(--muted);
      min-width:72px;
      text-align:right;
    }

    .fmeaMdViewport{
      border:1px solid rgba(42,52,71,0.6);
      border-radius:10px;
      background: rgba(15,20,30,0.45);
      padding:10px;
      min-height:58vh;
      overflow:auto;
    }

    mark.searchHit{
      background: rgba(255,211,124,0.35);
      color: #fff4d6;
      border-radius:4px;
      padding:0 1px;
    }

    .fmeaJsonViewport{
      border:1px solid rgba(42,52,71,0.6);
      border-radius:10px;
      background: rgba(15,20,30,0.45);
      padding:10px;
      min-height:58vh;
      overflow:auto;
    }

    .status{
      padding:8px 12px;
      border-radius:999px;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.8px;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }

    .status.ok{ background: rgba(123,220,181,0.12); color: var(--accent); border:1px solid rgba(123,220,181,0.35); }
    .status.err{ background: rgba(255,123,123,0.12); color: var(--danger); border:1px solid rgba(255,123,123,0.35); }

    .modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 16px;
    }

    .modal{
      width: min(560px, 96vw);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .modal h3{
      margin: 0 0 10px;
      font-size: 18px;
    }

    .modalGrid{
      display: grid;
      gap: 10px;
    }

    .modalActions{
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .input{
      width: 100%;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      font: inherit;
    }

    .contextMenu{
      position: fixed;
      display: none;
      z-index: 60;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--shadow);
      min-width: 160px;
      overflow: hidden;
    }

    .contextMenu button{
      width: 100%;
      border: none;
      background: transparent;
      color: var(--text);
      text-align: left;
      padding: 8px 10px;
      cursor: pointer;
    }

    .contextMenu button:hover{
      background: rgba(102,163,255,0.15);
    }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      aside{ order:2; }
      main{ order:1; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        Catalog Reader
      </div>
    </header>

    <div class="layout">
      <aside>
        <div class="sidebar-head">
          <div class="label">Files</div>
          <div class="search">
            <input id="searchInput" type="search" placeholder="Filter by filename or PN..." />
          </div>
          <div class="meta-row">
            <span class="pill" id="fileCount">Loading...</span>
            <span class="pill" id="dataStatus">Index: pending</span>
          </div>
        </div>
        <div class="file-list" id="fileList"></div>
      </aside>

      <main>
        <div class="preview-head">
          <div class="preview-title" id="previewTitle">Select a markdown file</div>
          <div class="preview-meta" id="previewMeta"></div>
          <div class="tabBar" id="previewTabs">
            <button class="tabBtn active" data-tab="markdown">Markdown</button>
            <button class="tabBtn" data-tab="json">JSON</button>
            <button class="tabBtn" data-tab="schematic">Schematic</button>
            <button class="tabBtn" data-tab="layout">Layout</button>
            <button class="tabBtn" data-tab="fmea">FMEA Report</button>
            <button class="tabBtn" data-tab="assembly">Assembly</button>
            <button class="tabBtn" data-tab="testing">Testing</button>
          </div>
        </div>
        <div class="preview" id="previewPane">
          <div class="tabPanel active" data-panel="markdown">
            <div class="empty" id="emptyState">Pick a file from the left to render its markdown.</div>
          </div>
          <div class="tabPanel" data-panel="json">
            <div class="jsonWrap">
              <div class="jsonToolbar">
                <div class="jsonUrl" id="jsonPath">Path: (none)</div>
                <button class="jsonBtn" id="jsonReloadBtn" type="button">Reload</button>
                <button class="jsonBtn" id="jsonCopyBtn" type="button">Copy</button>
              </div>
              <div class="jsonStatus" id="jsonStatus">Select a file to load JSON.</div>
              <div class="jsonViewport">
                <div id="jsonContent" class="jsonStatus">No JSON loaded.</div>
              </div>
            </div>
          </div>
          <div class="tabPanel" data-panel="schematic">
            <div class="empty">Schematic view placeholder. Add images or SVGs here.</div>
          </div>
          <div class="tabPanel" data-panel="layout">
            <div class="empty">Layout view placeholder. Add board renders or layout images here.</div>
          </div>
          <div class="tabPanel" data-panel="fmea">
            <div class="fmeaWrap">
              <div class="tabBar fmeaSubTabs" id="fmeaSubTabs">
                <button class="tabBtn active" data-fmea-tab="md">Markdown</button>
                <button class="tabBtn" data-fmea-tab="json">JSON</button>
              </div>
              <div class="fmeaSubPanel active" data-fmea-panel="md">
                <div class="fmeaCard">
                  <div class="fmeaTitle">FMEA Markdown</div>
                  <div class="fmeaPath" id="fmeaMdPath">Path: (none)</div>
                  <div class="fmeaSearchRow">
                    <input id="fmeaMdSearchInput" class="fmeaSearchInput" type="search" placeholder="Search FMEA markdown..." />
                    <span id="fmeaMdSearchCount" class="fmeaSearchCount"></span>
                  </div>
                  <div class="fmeaMdViewport" id="fmeaMdContent">
                    <div class="empty">Select a file to load FMEA markdown.</div>
                  </div>
                </div>
              </div>
              <div class="fmeaSubPanel" data-fmea-panel="json">
                <div class="fmeaCard">
                  <div class="fmeaTitle">FMEA JSON</div>
                  <div class="fmeaPath" id="fmeaJsonPath">Path: (none)</div>
                  <div class="jsonStatus" id="fmeaJsonStatus">Select a file to load FMEA JSON.</div>
                  <div class="fmeaSearchRow">
                    <input id="fmeaJsonSearchInput" class="fmeaSearchInput" type="search" placeholder="Search FMEA JSON..." />
                    <span id="fmeaJsonSearchCount" class="fmeaSearchCount"></span>
                  </div>
                  <div class="fmeaJsonViewport">
                    <div id="fmeaJsonContent" class="jsonStatus">No FMEA JSON loaded.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="tabPanel" data-panel="assembly">
            <div class="empty">Assembly view placeholder. Add assembly drawings or BOM links here.</div>
          </div>
          <div class="tabPanel" data-panel="testing">
            <div class="empty">Testing view placeholder. Add procedures or test results here.</div>
          </div>
        </div>
      </main>
    </div>
  </div>



    <script src="schematics-data.js"></script>
<script>
    const state = {
      entries: [],
      filtered: [],
      current: null,
      requestId: 0,
      currentFetch: null,
      mdIndex: [],
      currentMarkdownText: "",
      currentJsonPath: "",
      currentJsonText: "",
      currentJsonValue: null,
      currentFmeaMdPath: "",
      currentFmeaJsonPath: "",
      pathExistsCache: {}
    };

    const $ = (id) => document.getElementById(id);

    function parsePnFromTitle(title){
      const raw = (title || "").split("|")[0].trim();
      return raw || "";
    }

    function getHashPath(){
      const raw = decodeURIComponent(location.hash.replace(/^#/, ""));
      return raw.split("|")[0];
    }

    function setHashPath(path){
      const stamp = Date.now().toString(36);
      const next = encodeURIComponent(path || "") + "|" + stamp;
      history.replaceState(null, "", "#" + next);
    }

    function safeSetHashPath(path){
      try{
        setHashPath(path);
      }catch(err){
        const next = encodeURIComponent(path || "");
        location.hash = next;
      }
    }

    function escapeHtml(str){
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function formatInline(text){
      let out = escapeHtml(text);
      out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
      out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      out = out.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      out = out.replace(/_([^_]+)_/g, '<em>$1</em>');
      out = out.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
      return out;
    }

    function parseTable(lines, startIdx){
      const header = lines[startIdx];
      const divider = lines[startIdx + 1] || "";
      if(!/^\s*\|?\s*[-:| ]+\|?\s*$/.test(divider)) return null;

      const rows = [];
      let i = startIdx;
      while(i < lines.length && /\|/.test(lines[i])){
        rows.push(lines[i]);
        i += 1;
      }

      const parseRow = (row) => {
        const trimmed = row.trim();
        const strip = trimmed.startsWith("|") ? trimmed.slice(1) : trimmed;
        const strip2 = strip.endsWith("|") ? strip.slice(0, -1) : strip;
        return strip2.split("|").map(cell => formatInline(cell.trim()));
      };

      const headCells = parseRow(rows[0]);
      const bodyRows = rows.slice(2).map(parseRow);

      let html = '<table><thead><tr>';
      html += headCells.map(cell => `<th>${cell}</th>`).join("");
      html += '</tr></thead><tbody>';
      html += bodyRows.map(cells => `<tr>${cells.map(c => `<td>${c}</td>`).join("")}</tr>`).join("");
      html += '</tbody></table>';

      return { html, nextIndex: i };
    }

    function markdownToHtml(md){
      const lines = md.replace(/\r\n?/g, "\n").split("\n");
      const blocks = [];
      let i = 0;

      while(i < lines.length){
        const line = lines[i];

        if(line.trim() === ""){
          i += 1;
          continue;
        }

        if(line.startsWith("```")){
          const lang = line.slice(3).trim();
          let code = "";
          i += 1;
          while(i < lines.length && !lines[i].startsWith("```")){
            code += lines[i] + "\n";
            i += 1;
          }
          i += 1;
          blocks.push(`<pre><code data-lang="${escapeHtml(lang)}">${escapeHtml(code)}</code></pre>`);
          continue;
        }

        const table = parseTable(lines, i);
        if(table){
          blocks.push(table.html);
          i = table.nextIndex;
          continue;
        }

        if(/^#{1,6}\s/.test(line)){
          const level = line.match(/^#{1,6}/)[0].length;
          const content = line.replace(/^#{1,6}\s*/, "");
          blocks.push(`<h${level}>${formatInline(content)}</h${level}>`);
          i += 1;
          continue;
        }

        if(/^>\s?/.test(line)){
          let quote = line.replace(/^>\s?/, "");
          i += 1;
          while(i < lines.length && /^>\s?/.test(lines[i])){
            quote += "\n" + lines[i].replace(/^>\s?/, "");
            i += 1;
          }
          blocks.push(`<blockquote>${formatInline(quote)}</blockquote>`);
          continue;
        }

        if(/^(-{3,}|\*{3,})$/.test(line.trim())){
          blocks.push("<hr />");
          i += 1;
          continue;
        }

        if(/^\s*([-*+]\s+)/.test(line)){
          const items = [];
          while(i < lines.length && /^\s*([-*+]\s+)/.test(lines[i])){
            items.push(lines[i].replace(/^\s*([-*+]\s+)/, ""));
            i += 1;
          }
          blocks.push(`<ul>${items.map(item => `<li>${formatInline(item)}</li>`).join("")}</ul>`);
          continue;
        }

        if(/^\s*\d+\.\s+/.test(line)){
          const items = [];
          while(i < lines.length && /^\s*\d+\.\s+/.test(lines[i])){
            items.push(lines[i].replace(/^\s*\d+\.\s+/, ""));
            i += 1;
          }
          blocks.push(`<ol>${items.map(item => `<li>${formatInline(item)}</li>`).join("")}</ol>`);
          continue;
        }

        let para = line;
        i += 1;
        while(i < lines.length && lines[i].trim() !== "" &&
          !/^#{1,6}\s/.test(lines[i]) &&
          !/^>\s?/.test(lines[i]) &&
          !/^\s*([-*+]\s+)/.test(lines[i]) &&
          !/^\s*\d+\.\s+/.test(lines[i]) &&
          !/^(-{3,}|\*{3,})$/.test(lines[i].trim()) &&
          !/^\s*\|/.test(lines[i])
        ){
          para += " " + lines[i].trim();
          i += 1;
        }
        blocks.push(`<p>${formatInline(para)}</p>`);
      }

      return blocks.join("\n");
    }
    function renderImages(entry){
      const schematicPanel = document.querySelector('.tabPanel[data-panel="schematic"]');
      const layoutPanel = document.querySelector('.tabPanel[data-panel="layout"]');
      if(!schematicPanel || !layoutPanel) return;

      const pn = entry && entry.pn ? entry.pn : '';
      if(!pn){
        schematicPanel.innerHTML = '<div class="empty">No PN found for this file.</div>';
        layoutPanel.innerHTML = '<div class="empty">No PN found for this file.</div>';
        return;
      }

      schematicPanel.innerHTML = '<div class="empty">Loading schematics...</div>';
      layoutPanel.innerHTML = '<div class="empty">Loading layout...</div>';

      const found = [];
      const maxPages = 12;
      let checked = 0;

      const tryFinishSchematics = () => {
        checked += 1;
        if(checked < maxPages) return;
        if(found.length){
          found.sort((a, b) => a.order - b.order);
          const buttons = found.map((it, idx) =>
            `<button class="pageBtn${idx == 0 ? ' active' : ''}" data-src="${it.src}" data-label="${it.label}">${it.label}</button>`
          ).join('');
          const first = found[0];
          schematicPanel.innerHTML = `
            <div class="pageTabs" data-pages="schematic">${buttons}</div>
            <div class="imageCard">
              <div class="imageViewport" data-zoom="1">
                <div class="imageLayer">
                  <img src="${first.src}" alt="${first.label}" />
                  <div class="imageOverlay"></div>
                </div>
              </div>
              <div class="caption" id="schematicCaption">${first.label}</div>
            </div>`;

          const tabs = schematicPanel.querySelector('.pageTabs');
          tabs.addEventListener('click', (e) => {
            const btn = e.target.closest('.pageBtn');
            if(!btn) return;
            tabs.querySelectorAll('.pageBtn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const img = schematicPanel.querySelector('img');
            const cap = schematicPanel.querySelector('#schematicCaption');
            if(img) img.src = btn.getAttribute('data-src') || '';
            if(cap) cap.textContent = btn.getAttribute('data-label') || '';
            const vp = schematicPanel.querySelector('.imageViewport');
            if(vp) vp.setAttribute('data-ready', 'false');
            setupImageInteractions(schematicPanel);
          });

          setupImageInteractions(schematicPanel);
        }else{
          schematicPanel.innerHTML = '<div class="empty">No schematic images found for this PN.</div>';
        }
      };

      for(let i = 1; i <= maxPages; i += 1){
        const page = String(i).padStart(2, '0');
        const src = `images/${pn}_schematic_${page}.png`;
        const img = new Image();
        img.onload = () => {
          found.push({
            src,
            label: `${pn} schematic ${page}`,
            order: Number(page)
          });
          tryFinishSchematics();
        };
        img.onerror = () => {
          tryFinishSchematics();
        };
        img.src = src;
      }

      const layoutSrc = `images/${pn}_components_top.png`;
      const layoutImg = new Image();
      layoutImg.onload = () => {
        layoutPanel.innerHTML = `
          <div class="imageGrid">
            <div class="imageCard">
              <div class="imageViewport" data-zoom="1">
                <div class="imageLayer">
                  <img src="${layoutSrc}" alt="${pn} components top" />
                  <div class="imageOverlay"></div>
                </div>
              </div>
              <div class="caption">${pn} components top</div>
            </div>
          </div>`;
        setupImageInteractions(layoutPanel);
      };
      layoutImg.onerror = () => {
        layoutPanel.innerHTML = '<div class="empty">No layout image found for this PN.</div>';
      };
      layoutImg.src = layoutSrc;
    }

    function setStatus(ok, message){
      const el = $("dataStatus");
      el.textContent = message;
      el.className = ok ? "pill status ok" : "pill status err";
    }

    function renderList(){
      const list = $("fileList");
      list.innerHTML = "";
      if(!state.filtered.length){
        list.innerHTML = '<div class="empty">No files match the filter.</div>';
        return;
      }

      for(const entry of state.filtered){
        const item = document.createElement("div");
        item.className = "file-item" + (state.current && state.current.pn === entry.pn ? " active" : "");
        item.dataset.pn = entry.pn || "";
        item.innerHTML = `
          <div class="name">${escapeHtml(entry.title || entry.pn || entry.filename || "")}</div>
          <div class="sub">
            ${entry.pn ? `<span class="pill">${escapeHtml(entry.pn)}</span>` : ""}
            ${entry.rev ? `<span class="pill">${escapeHtml(entry.rev)}</span>` : ""}
            ${entry.kind ? `<span class="pill">${escapeHtml(entry.kind)}</span>` : ""}
            ${entry.hasMarkdown ? `<span class="pill">md</span>` : `<span class="pill">no md</span>`}
          </div>
        `;
        item.addEventListener("click", () => selectEntry(entry));
        list.appendChild(item);
      }
    }

    function updateMeta(entry){
      const meta = $("previewMeta");
      meta.innerHTML = "";
      if(!entry){
        return;
      }
      const parts = [];
      if(entry.pn) parts.push(`PN: ${escapeHtml(entry.pn)}`);
      if(entry.rev) parts.push(`REV: ${escapeHtml(entry.rev)}`);
      if(entry.kind) parts.push(`KIND: ${escapeHtml(entry.kind)}`);
      if(entry.mtime) parts.push(`Updated: ${escapeHtml(entry.mtime)}`);
      meta.innerHTML = parts.map(p => `<span class="pill">${p}</span>`).join("");
    }

    function compareRevDesc(a, b){
      const parse = (rev) => {
        const m = String(rev || "").match(/^([A-Z]+)(\d+)-(\d+)$/i);
        if(!m) return { stage: "", major: -1, minor: -1 };
        return { stage: m[1].toUpperCase(), major: Number(m[2]), minor: Number(m[3]) };
      };
      const ra = parse(a);
      const rb = parse(b);
      if(ra.stage !== rb.stage) return ra.stage < rb.stage ? 1 : -1;
      if(ra.major !== rb.major) return rb.major - ra.major;
      return rb.minor - ra.minor;
    }

    function parseA1Minor(rev){
      const m = String(rev || "").match(/^A1-(\d{2})$/i);
      return m ? Number(m[1]) : 0;
    }

    async function pathExists(path){
      if(!path) return false;
      if(Object.prototype.hasOwnProperty.call(state.pathExistsCache, path)){
        return !!state.pathExistsCache[path];
      }
      try{
        const res = await fetch(path + "?v=" + Date.now(), { method: "HEAD", cache: "no-store" });
        state.pathExistsCache[path] = !!res.ok;
        return !!res.ok;
      }catch(_){
        state.pathExistsCache[path] = false;
        return false;
      }
    }

    async function resolveMdPathForEntry(entry){
      const pn = (entry && entry.pn) || "";
      if(!pn) return "";

      const existing = (state.mdIndex || []).filter(x => x && x.pn === pn);
      if(existing.length){
        existing.sort((a, b) => compareRevDesc(a.rev, b.rev));
        const bestIndexed = existing[0];
        const bestMinor = parseA1Minor(bestIndexed && bestIndexed.rev);

        // If index.json lags behind latest pushes, probe for newer A1-XX revisions.
        for(let i = 30; i > bestMinor; i -= 1){
          const rev = String(i).padStart(2, "0");
          const candidate = `md/${pn}_A1-${rev}_sch.md`;
          if(await pathExists(candidate)){
            entry.mdPath = candidate;
            entry.filename = `${pn}_A1-${rev}_sch.md`;
            entry.rev = `A1-${rev}`;
            entry.kind = "sch";
            entry.hasMarkdown = true;
            return candidate;
          }
        }

        if((bestIndexed && bestIndexed.path) && await pathExists(bestIndexed.path)){
          entry.mdPath = bestIndexed.path;
          entry.filename = bestIndexed.filename || entry.filename || "";
          entry.rev = bestIndexed.rev || entry.rev || "";
          entry.kind = bestIndexed.kind || entry.kind || "";
          entry.hasMarkdown = true;
          return bestIndexed.path;
        }
      }

      if((entry && entry.mdPath)) return entry.mdPath;

      // Fallback probe when index.json is stale: try common A1-XX schematic names.
      for(let i = 30; i >= 1; i -= 1){
        const rev = String(i).padStart(2, "0");
        const candidate = `md/${pn}_A1-${rev}_sch.md`;
        if(await pathExists(candidate)){
          entry.mdPath = candidate;
          entry.filename = `${pn}_A1-${rev}_sch.md`;
          entry.rev = `A1-${rev}`;
          entry.kind = "sch";
          entry.hasMarkdown = true;
          return candidate;
        }
      }

      return "";
    }

    function setupImageInteractions(scope){
      const viewports = (scope || document).querySelectorAll(".imageViewport");
      const storedZoom = parseFloat(localStorage.getItem("imageZoom") || "1");

      const applyZoom = (vp, layer, img, zoom) => {
        if(!layer || !img) return;
        const naturalW = img.naturalWidth || img.width || 0;
        const naturalH = img.naturalHeight || img.height || 0;
        if(!naturalW || !naturalH) return;
        layer.style.width = `${naturalW * zoom}px`;
        layer.style.height = `${naturalH * zoom}px`;
        vp.setAttribute("data-zoom", String(zoom));
      };

      viewports.forEach(vp => {
        const layer = vp.querySelector(".imageLayer");
        const img = vp.querySelector("img");
        if(!layer || !img) return;

        const initZoom = storedZoom || 1;
        if(vp.getAttribute("data-ready") == "true"){
          applyZoom(vp, layer, img, initZoom);
          return;
        }
        vp.setAttribute("data-ready", "true");
        if(!img.complete){
          img.addEventListener("load", () => applyZoom(vp, layer, img, initZoom), { once: true });
        }
        applyZoom(vp, layer, img, initZoom);

        let isPanning = false;
        let startX = 0;
        let startY = 0;
        let scrollLeft = 0;
        let scrollTop = 0;

        vp.addEventListener("pointerdown", (e) => {
          if(e.button !== 0) return;
          isPanning = true;
          vp.setPointerCapture(e.pointerId);
          const rect = vp.getBoundingClientRect();
          startX = e.clientX - rect.left;
          startY = e.clientY - rect.top;
          scrollLeft = vp.scrollLeft;
          scrollTop = vp.scrollTop;
        });

        vp.addEventListener("pointerup", (e) => {
          isPanning = false;
          try{ vp.releasePointerCapture(e.pointerId); }catch(_){}
        });

        vp.addEventListener("pointerleave", () => { isPanning = false; });

        vp.addEventListener("pointermove", (e) => {
          if(!isPanning) return;
          e.preventDefault();
          const rect = vp.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          vp.scrollLeft = scrollLeft - (x - startX);
          vp.scrollTop = scrollTop - (y - startY);
        });

        vp.addEventListener("wheel", (e) => {
          e.preventDefault();
          const current = parseFloat(vp.getAttribute("data-zoom") || "1");
          const delta = e.deltaY < 0 ? 0.05 : -0.05;
          const next = Math.min(4, Math.max(0.1, current + delta));
          localStorage.setItem("imageZoom", String(next));
          applyZoom(vp, layer, img, next);
        }, { passive: false });

        vp.addEventListener("dblclick", (e) => {
          e.preventDefault();
          const reset = 1;
          localStorage.setItem("imageZoom", String(reset));
          applyZoom(vp, layer, img, reset);
        });
      });
    }

    function renderJsonValueTree(value, keyLabel){
      const entry = document.createElement("div");
      entry.className = "jsonEntry";

      if(keyLabel){
        const key = document.createElement("span");
        key.className = "jsonBubble jsonKeyBubble";
        key.textContent = keyLabel;
        entry.appendChild(key);
      }

      const appendPrimitive = (primitive) => {
        const bubble = document.createElement("span");
        let cls = "type-string";
        if(primitive === null) cls = "type-null";
        else if(typeof primitive === "number") cls = "type-number";
        else if(typeof primitive === "boolean") cls = "type-boolean";
        bubble.className = `jsonBubble jsonValBubble ${cls}`;
        bubble.textContent = primitive === null ? "null" : String(primitive);
        entry.appendChild(bubble);
      };

      if(value === null || typeof value !== "object"){
        appendPrimitive(value);
        return entry;
      }

      const child = document.createElement("div");
      child.className = "jsonChild";

      if(Array.isArray(value)){
        if(!value.length){
          appendPrimitive("empty list");
          return entry;
        }
        value.forEach((item, idx) => child.appendChild(renderJsonValueTree(item, `item ${idx + 1}`)));
      }else{
        const keys = Object.keys(value);
        if(!keys.length){
          appendPrimitive("empty object");
          return entry;
        }
        keys.forEach((k) => child.appendChild(renderJsonValueTree(value[k], k)));
      }

      entry.appendChild(child);
      return entry;
    }

    function renderJsonPaneContent(value){
      const contentEl = $("jsonContent");
      if(!contentEl) return;
      contentEl.innerHTML = "";
      if(value === null || value === undefined){
        contentEl.className = "jsonStatus";
        contentEl.textContent = "No JSON loaded.";
        return;
      }
      const tree = document.createElement("div");
      tree.className = "jsonTree";
      tree.appendChild(renderJsonValueTree(value, "root"));
      contentEl.className = "";
      contentEl.appendChild(tree);
    }

    function updateJsonPane(path, text, status, value){
      const pathEl = $("jsonPath");
      const statusEl = $("jsonStatus");
      if(pathEl) pathEl.textContent = `Path: ${path || "(none)"}`;
      if(statusEl) statusEl.textContent = status || "";
      if(value !== undefined){
        renderJsonPaneContent(value);
      }else{
        const contentEl = $("jsonContent");
        if(contentEl){
          contentEl.className = "jsonStatus";
          contentEl.textContent = text || "";
        }
      }
    }

    function updateFmeaPane(mdPath, mdHtml, jsonPath, jsonStatus, jsonValue){
      const mdPathEl = $("fmeaMdPath");
      const mdContentEl = $("fmeaMdContent");
      const jsonPathEl = $("fmeaJsonPath");
      const jsonStatusEl = $("fmeaJsonStatus");
      const jsonContentEl = $("fmeaJsonContent");

      if(mdPathEl) mdPathEl.textContent = `Path: ${mdPath || "(none)"}`;
      if(mdContentEl){
        if(mdHtml){
          mdContentEl.innerHTML = `<div class="md">${mdHtml}</div>`;
        }else{
          mdContentEl.innerHTML = `<div class="empty">No FMEA markdown found.</div>`;
        }
      }

      if(jsonPathEl) jsonPathEl.textContent = `Path: ${jsonPath || "(none)"}`;
      if(jsonStatusEl) jsonStatusEl.textContent = jsonStatus || "";
      if(jsonContentEl){
        jsonContentEl.innerHTML = "";
        if(jsonValue && typeof jsonValue === "object"){
          const tree = document.createElement("div");
          tree.className = "jsonTree";
          tree.appendChild(renderJsonValueTree(jsonValue, "root"));
          jsonContentEl.className = "";
          jsonContentEl.appendChild(tree);
        }else{
          jsonContentEl.className = "jsonStatus";
          jsonContentEl.textContent = "No FMEA JSON loaded.";
        }
      }

      applyFmeaMdSearch();
      applyFmeaJsonSearch();
    }

    function clearSearchHighlights(root){
      if(!root) return;
      const marks = root.querySelectorAll("mark.searchHit");
      marks.forEach(mark => {
        const textNode = document.createTextNode(mark.textContent || "");
        const parent = mark.parentNode;
        if(!parent) return;
        parent.replaceChild(textNode, mark);
        parent.normalize();
      });
    }

    function highlightInContainer(root, query){
      if(!root) return 0;
      clearSearchHighlights(root);
      const q = String(query || "").trim().toLowerCase();
      if(!q) return 0;

      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
        acceptNode(node){
          const value = node && node.nodeValue ? node.nodeValue : "";
          if(!value.trim()) return NodeFilter.FILTER_REJECT;
          if(node.parentElement && node.parentElement.closest("mark.searchHit")) return NodeFilter.FILTER_REJECT;
          return NodeFilter.FILTER_ACCEPT;
        }
      });

      const textNodes = [];
      let current = walker.nextNode();
      while(current){
        textNodes.push(current);
        current = walker.nextNode();
      }

      let total = 0;
      textNodes.forEach(node => {
        const original = node.nodeValue || "";
        const lower = original.toLowerCase();
        if(!lower.includes(q)) return;

        const frag = document.createDocumentFragment();
        let start = 0;
        while(true){
          const idx = lower.indexOf(q, start);
          if(idx === -1) break;
          if(idx > start){
            frag.appendChild(document.createTextNode(original.slice(start, idx)));
          }
          const mark = document.createElement("mark");
          mark.className = "searchHit";
          mark.textContent = original.slice(idx, idx + q.length);
          frag.appendChild(mark);
          total += 1;
          start = idx + q.length;
        }
        if(start < original.length){
          frag.appendChild(document.createTextNode(original.slice(start)));
        }
        const parent = node.parentNode;
        if(parent) parent.replaceChild(frag, node);
      });

      return total;
    }

    function applyFmeaMdSearch(){
      const root = $("fmeaMdContent");
      const input = $("fmeaMdSearchInput");
      const countEl = $("fmeaMdSearchCount");
      if(!root || !input || !countEl) return;
      const count = highlightInContainer(root, input.value);
      countEl.textContent = input.value ? `${count} match${count === 1 ? "" : "es"}` : "";
    }

    function applyFmeaJsonSearch(){
      const root = $("fmeaJsonContent");
      const input = $("fmeaJsonSearchInput");
      const countEl = $("fmeaJsonSearchCount");
      if(!root || !input || !countEl) return;
      const count = highlightInContainer(root, input.value);
      countEl.textContent = input.value ? `${count} match${count === 1 ? "" : "es"}` : "";
    }

    async function loadFmeaForEntry(entry, requestId){
      const pn = (entry && entry.pn) || "";
      const rev = (entry && entry.rev) || "";
      if(!pn || !rev){
        state.currentFmeaMdPath = "";
        state.currentFmeaJsonPath = "";
        updateFmeaPane("", "", "", "Missing PN or REV for FMEA lookup.", null);
        return;
      }

      const base = `json/fmea/analysis_${pn}_${rev}`;
      const mdPath = `${base}.md`;
      const jsonPath = `${base}.json`;
      state.currentFmeaMdPath = mdPath;
      state.currentFmeaJsonPath = jsonPath;

      let mdHtml = "";
      let jsonValue = null;
      let jsonStatus = "FMEA JSON not found.";

      try{
        const mdRes = await fetch(mdPath + "?v=" + Date.now(), { cache: "no-store" });
        if(requestId !== state.requestId) return;
        if(mdRes.ok){
          const mdText = await mdRes.text();
          if(requestId !== state.requestId) return;
          mdHtml = markdownToHtml(mdText);
        }
      }catch(_){}

      try{
        const jsonRes = await fetch(jsonPath + "?v=" + Date.now(), { cache: "no-store" });
        if(requestId !== state.requestId) return;
        if(jsonRes.ok){
          const text = await jsonRes.text();
          if(requestId !== state.requestId) return;
          try{
            jsonValue = JSON.parse(text);
            jsonStatus = "FMEA JSON loaded.";
          }catch(_){
            jsonStatus = "FMEA JSON parse failed.";
          }
        }
      }catch(_){}

      updateFmeaPane(mdPath, mdHtml, jsonPath, jsonStatus, jsonValue);
    }

    function getJsonCandidates(entry, mdPath){
      const candidates = [];
      const pushUnique = (v) => {
        if(!v) return;
        if(!candidates.includes(v)) candidates.push(v);
      };

      const fromMd = (mdPath || "").replace(/^md\//, "json/").replace(/\.md$/i, ".json");
      pushUnique(fromMd);
      const fromFilename = (entry && entry.filename ? String(entry.filename) : "").replace(/\.md$/i, ".json");
      if(fromFilename) pushUnique(`json/${fromFilename}`);
      if(entry && entry.pn && entry.rev){
        pushUnique(`json/${entry.pn}_${entry.rev}_sch.json`);
      }
      if(entry && entry.pn){
        pushUnique(`json/${entry.pn}_A1-01_sch.json`);
      }
      return candidates.filter(Boolean);
    }

    async function loadJsonForEntry(entry, mdPath, requestId){
      const candidates = getJsonCandidates(entry, mdPath);
      if(!candidates.length){
        state.currentJsonPath = "";
        state.currentJsonText = "";
        state.currentJsonValue = null;
        updateJsonPane("", "No JSON candidate path for this entry.", "No JSON loaded.", null);
        return;
      }

      for(const path of candidates){
        try{
          updateJsonPane(path, state.currentJsonText || "Loading...", "Fetching JSON...");
          const res = await fetch(path + "?v=" + Date.now(), { cache: "no-store" });
          if(requestId !== state.requestId) return;
          if(!res.ok) continue;
          const raw = await res.text();
          if(requestId !== state.requestId) return;
          let pretty = raw;
          let parsed = null;
          try{
            parsed = JSON.parse(raw);
            pretty = JSON.stringify(parsed, null, 2);
          }catch(_){}
          state.currentJsonPath = path;
          state.currentJsonText = pretty;
          state.currentJsonValue = parsed;
          updateJsonPane(path, pretty, "JSON loaded.", parsed);
          return;
        }catch(_){
          if(requestId !== state.requestId) return;
        }
      }

      state.currentJsonPath = candidates[0] || "";
      state.currentJsonText = "";
      state.currentJsonValue = null;
      updateJsonPane(state.currentJsonPath, "No JSON file found for this entry.", "JSON not found.", null);
    }

    async function selectEntry(entry){
      let path = entry && entry.mdPath ? entry.mdPath : "";
      try{
        state.current = entry;
        const requestId = ++state.requestId;
        $("previewTitle").textContent = (entry && entry.title) || (entry && entry.pn) || (entry && entry.filename) || "";
        updateMeta(entry);
        renderImages(entry);
        const emptyState = $("emptyState");
        if(emptyState) emptyState.style.display = "none";
        const mdPanel = document.querySelector(".tabPanel[data-panel=\"markdown\"]");
        path = await resolveMdPathForEntry(entry);
        const hashTarget = path || (entry && entry.pn) || (entry && entry.filename) || "";
        safeSetHashPath(hashTarget);
      if(!path){
        if(mdPanel) mdPanel.innerHTML = `<div class="empty">No markdown found for this miniPCB. Open schematic page: <a href="${escapeHtml((entry && entry.href) || "#")}" target="_blank" rel="noopener">${escapeHtml((entry && entry.href) || "link")}</a>.</div>`;
        state.currentMarkdownText = "";
        await loadJsonForEntry(entry, "", requestId);
        await loadFmeaForEntry(entry, requestId);
        return;
      }
        if(mdPanel) mdPanel.innerHTML = '<div class="empty">Loading...</div>';

        if(state.currentFetch && typeof state.currentFetch.abort === "function"){
          state.currentFetch.abort();
        }
        const controller = typeof AbortController !== "undefined" ? new AbortController() : null;
        state.currentFetch = controller;

        const url = path + "?v=" + Date.now();

        const timeoutMs = 6000;
        const timeout = new Promise((_, reject) =>
          setTimeout(() => {
            if(controller) controller.abort();
            reject(new Error("Request timed out"));
          }, timeoutMs)
        );

        const res = await Promise.race([
          fetch(url, { cache: "no-store", signal: controller ? controller.signal : undefined }),
          timeout
        ]);
        if(requestId !== state.requestId) return;
        if(!res.ok) throw new Error(`Failed to load ${path} (${res.status})`);
        const text = await res.text();
        if(requestId !== state.requestId) return;
        const html = markdownToHtml(text);
        if(mdPanel) mdPanel.innerHTML = `<div class="md" data-path="${escapeHtml(path)}">${html}</div>`;
        state.currentMarkdownText = text;
        await loadJsonForEntry(entry, path, requestId);
        await loadFmeaForEntry(entry, requestId);
      }catch(err){
        const msg = (err && err.message) || "Unknown error";
        const mdPanel = document.querySelector(".tabPanel[data-panel=\"markdown\"]");
        if(!path){
          if(mdPanel) mdPanel.innerHTML = `<div class="empty">No markdown found for this miniPCB. Open schematic page: <a href="${escapeHtml((entry && entry.href) || "#")}" target="_blank" rel="noopener">${escapeHtml((entry && entry.href) || "link")}</a>.</div>`;
          state.currentMarkdownText = "";
          await loadJsonForEntry(entry, "", state.requestId);
          await loadFmeaForEntry(entry, state.requestId);
          return;
        }
        if(mdPanel) mdPanel.innerHTML = `<div class="empty">${escapeHtml(msg)}</div>`;
        state.currentMarkdownText = "";
        await loadJsonForEntry(entry, path, state.requestId);
        await loadFmeaForEntry(entry, state.requestId);
      }

      renderList();
    }

    function filterList(query){
      const q = query.trim().toLowerCase();
      if(!q){
        state.filtered = state.entries.slice();
      }else{
        state.filtered = state.entries.filter(e => {
          return [e.title, e.pn, e.rev, e.kind].some(v => (v || "").toLowerCase().includes(q));
        });
      }
      $("fileCount").textContent = `${state.filtered.length} items`;
      renderList();
    }

    async function loadIndex(){
      let mdEntries = [];
      try{
        const res = await fetch("md/index.json?v=" + Date.now(), { cache: "no-store" });
        if(!res.ok) throw new Error("Index not found");
        const data = await res.json();
        mdEntries = Array.isArray(data.entries) ? data.entries.slice() : [];
        setStatus(true, "Index: loaded");
      }catch(err){
        setStatus(false, "Index: missing");
      }

      state.mdIndex = mdEntries;
      const mdByPn = new Map();
      mdEntries.forEach(entry => {
        if(entry.pn) mdByPn.set(entry.pn, entry);
      });

      const catalog = Array.isArray(window.SCHEMATICS) ? window.SCHEMATICS : [];
      const merged = catalog.map(item => {
        const pn = parsePnFromTitle(item.title);
        const md = mdByPn.get(pn);
        return {
          title: item.title,
          href: item.href,
          pn,
          mdPath: md ? md.path : "",
          filename: md ? md.filename : "",
          rev: md ? md.rev : "",
          kind: md ? md.kind : "",
          mtime: md ? md.mtime : "",
          hasMarkdown: !!md
        };
      });

      mdEntries.forEach(md => {
        if(!md.pn) return;
        if(!merged.find(e => e.pn === md.pn)){
          merged.push({
            title: md.filename,
            href: "",
            pn: md.pn,
            mdPath: md.path,
            filename: md.filename,
            rev: md.rev,
            kind: md.kind,
            mtime: md.mtime,
            hasMarkdown: true
          });
        }
      });

      merged.sort((a, b) => (a.pn || "").localeCompare(b.pn || ""));
      state.entries = merged;
      state.filtered = merged.slice();
      $("fileCount").textContent = `${state.filtered.length} items`;
      renderList();

      const hashPath = getHashPath();
      const target = state.entries.find(e => e.mdPath === hashPath || e.filename === hashPath || e.pn === hashPath);
      if(target){
        selectEntry(target);
      }
    }

    $("searchInput").addEventListener("input", (e) => filterList(e.target.value));
    function setupTabs(){
      const tabs = document.querySelectorAll("#previewTabs .tabBtn");
      const panels = document.querySelectorAll(".tabPanel");
      tabs.forEach(btn => {
        btn.addEventListener("click", () => {
          tabs.forEach(t => t.classList.remove("active"));
          btn.classList.add("active");
          const id = btn.getAttribute("data-tab");
          panels.forEach(p => {
            p.classList.toggle("active", p.getAttribute("data-panel") === id);
          });
        });
      });
    }

    function setupFmeaTabs(){
      const tabs = document.querySelectorAll("#fmeaSubTabs .tabBtn");
      const panels = document.querySelectorAll(".fmeaSubPanel");
      tabs.forEach(btn => {
        btn.addEventListener("click", () => {
          tabs.forEach(t => t.classList.remove("active"));
          btn.classList.add("active");
          const id = btn.getAttribute("data-fmea-tab");
          panels.forEach(p => {
            p.classList.toggle("active", p.getAttribute("data-fmea-panel") === id);
          });
        });
      });
    }

    function setupFmeaSearch(){
      const mdInput = $("fmeaMdSearchInput");
      const jsonInput = $("fmeaJsonSearchInput");
      if(mdInput){
        mdInput.addEventListener("input", () => applyFmeaMdSearch());
      }
      if(jsonInput){
        jsonInput.addEventListener("input", () => applyFmeaJsonSearch());
      }
    }

    function setupJsonActions(){
      const reloadBtn = $("jsonReloadBtn");
      const copyBtn = $("jsonCopyBtn");
      if(reloadBtn){
        reloadBtn.addEventListener("click", async () => {
          if(!state.current) return;
          await loadJsonForEntry(state.current, state.current && state.current.mdPath ? state.current.mdPath : "", state.requestId);
        });
      }
      if(copyBtn){
        copyBtn.addEventListener("click", async () => {
          const text = state.currentJsonText || "";
          if(!text) return;
          try{
            await navigator.clipboard.writeText(text);
            updateJsonPane(state.currentJsonPath, text, "Copied JSON to clipboard.", state.currentJsonValue);
          }catch(_){
            updateJsonPane(state.currentJsonPath, text, "Clipboard write failed.", state.currentJsonValue);
          }
        });
      }
    }

    window.addEventListener("hashchange", () => {
      const hashPath = getHashPath();
      const target = state.entries.find(e => e.mdPath === hashPath || e.filename === hashPath || e.pn === hashPath);
      if(target && (!state.current || target.pn !== state.current.pn || target.mdPath !== state.current.mdPath)) selectEntry(target);
    });

    setupTabs();
    setupFmeaTabs();
    setupFmeaSearch();
    setupJsonActions();
    loadIndex();
  </script>
  </body>
</html>
