<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Test Base 2026 — Document Management (Skeleton)</title>
  <style>
    :root{
      --bg:#0f1218;
      --panel:#141a24;
      --panel2:#101622;
      --text:#e7edf7;
      --muted:#a7b3c8;
      --border:#2a3447;
      --accent:#7cc4ff;
      --accent2:#98ffa7;
      --warn:#ffd37c;
      --bad:#ff7c7c;
      --good:#7cffb0;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:14px;
      --radius2:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% 0%, rgba(124,196,255,.10), transparent 60%),
                  radial-gradient(1000px 500px at 80% 0%, rgba(152,255,167,.08), transparent 55%),
                  var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    /* Shell */
    .app{ height:100%; display:flex; flex-direction:column; }
    .topbar{
      height:54px;
      display:flex; align-items:center; gap:12px;
      padding:0 14px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(20,26,36,.92), rgba(16,22,34,.92));
      backdrop-filter: blur(8px);
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      padding-right:10px;
      border-right:1px solid var(--border);
      user-select:none;
    }
    .dot{
      width:12px;height:12px;border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.2));
      box-shadow: 0 0 0 2px rgba(124,196,255,.25), 0 0 18px rgba(124,196,255,.25);
    }
    .brand h1{ margin:0; font-size:14px; font-weight:650; letter-spacing:.2px; }
    .menu{ display:flex; align-items:center; gap:10px; flex:1; min-width:0; }
    .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      border-radius:999px;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      color: var(--text);
      font-size:12px;
      white-space:nowrap;
    }
    .pill:hover{ background: rgba(124,196,255,.06); border-color: rgba(124,196,255,.25); }
    .pill:active{ transform: translateY(1px); }
    .pill.attn{
      background: rgba(124,255,176,.16);
      border-color: rgba(124,255,176,.55);
    }
    .sep{ width:1px;height:26px;background:var(--border); margin:0 2px; }

    .planBadge{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px dashed rgba(124,196,255,.35);
      background: rgba(124,196,255,.06);
      border-radius: 999px;
      min-width: 0;
      max-width: 42%;
    }
    .planBadge .name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:12px; font-weight:650; }
    .planBadge .sub{ font-size:11px; color:var(--muted); white-space:nowrap; }

    .status{ display:flex; gap:10px; align-items:center; justify-content:flex-end; min-width: 270px; }
    .chip{
      display:flex; align-items:center; gap:8px;
      padding:7px 10px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      border-radius: 999px;
      font-size:12px;
      color: var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .chip.clickable{ cursor:pointer; }
    .chip.clickable:hover{ border-color: rgba(124,196,255,.35); background: rgba(124,196,255,.06); }
    .clickableText{ cursor:pointer; }
    .clickableText:hover{ color: var(--accent); }
    .chip strong{ color:var(--text); font-weight:650; }
    .led{
      width:10px;height:10px;border-radius:999px;
      background: rgba(255,255,255,.12);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.10);
    }
    .led.ok{ background: rgba(124,255,176,.85); box-shadow: 0 0 14px rgba(124,255,176,.35); }
    .led.warn{ background: rgba(255,211,124,.95); box-shadow: 0 0 14px rgba(255,211,124,.35); }
    .led.bad{ background: rgba(255,124,124,.95); box-shadow: 0 0 14px rgba(255,124,124,.35); }

    /* Main */
    .main{ flex:1; display:flex; min-height:0; }
    .view{ flex:1; display:none; min-height:0; }
    .view.active{ display:flex; }

    /* Cards / Panels */
    .card, .panel{
      background: linear-gradient(180deg, rgba(20,26,36,.90), rgba(16,22,34,.90));
      border:1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      min-height:0;
      display:flex;
      flex-direction:column;
    }
    .brand{ cursor:pointer; }
    .cardHeader, .panelHeader{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .cardHeader h2, .panelHeader h3{
      margin:0;
      font-size:13px;
      font-weight:750;
      letter-spacing:.2px;
    }
    .muted{ color:var(--muted); font-size:12px; }
    .cardBody, .panelBody{ padding:14px; min-height:0; overflow:auto; }
    .panelBody{ flex:1; }
    .panelBody.chatPanelBody{ overflow:hidden; display:flex; flex-direction:column; }

    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      color:var(--text);
      padding:9px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      font-size:12px;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{ background: rgba(124,196,255,.06); border-color: rgba(124,196,255,.25); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: rgba(124,196,255,.14); border-color: rgba(124,196,255,.35); }
    .btn.danger:hover{ background: rgba(255,124,124,.10); border-color: rgba(255,124,124,.35); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; transform:none !important; }
    .mini{ padding:7px 9px; border-radius: 10px; font-size:11px; }
    .btn.attn{
      background: rgba(124,255,176,.16);
      border-color: rgba(124,255,176,.55);
    }
    .btn.attn:hover{ background: rgba(124,255,176,.24); border-color: rgba(124,255,176,.75); }

    .aiPermRow{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:6px;
      flex-wrap:wrap;
    }
    .aiPermRow .tag{ margin-left:2px; }
    .aiPermRange{
      width:180px;
      accent-color: var(--accent);
    }
    .maturity-menu .btn.selected{
      background: rgba(124,255,176,.22);
      border-color: rgba(124,255,176,.65);
      color: var(--text);
    }
    .tag.maturity-dirty{
      background: rgba(124,255,176,.18);
      border-color: rgba(124,255,176,.55);
      box-shadow: 0 0 0 1px rgba(124,255,176,.18) inset;
    }
    .locked-field{
      opacity: .7;
      cursor: not-allowed;
    }
    .drag-handle{
      cursor: grab;
    }
    .dragging{
      opacity: .6;
    }
    .drag-target{
      outline: 2px dashed rgba(124,196,255,.6);
      outline-offset: 2px;
      background: rgba(124,196,255,.06);
    }

    .input, .select, textarea{
      width:100%;
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      outline:none;
      transition: border-color .15s ease, background .15s ease;
    }
    .select option{
      background: var(--panel2);
      color: var(--text);
    }
    .input:focus, .select:focus, textarea:focus{
      border-color: rgba(124,196,255,.45);
      background: rgba(124,196,255,.04);
    }
    textarea{ min-height:88px; resize: vertical; font-family: var(--sans); line-height:1.35; }
    .ai-pending{
      background: rgba(255,124,124,.10);
      border-color: rgba(255,124,124,.35);
    }
    .ai-working{
      background: rgba(255,211,124,.12);
      border-color: rgba(255,211,124,.45);
    }
    .ai-accepted{
      background: rgba(124,255,176,.12);
      border-color: rgba(124,255,176,.45);
    }
    .dirty-field{
      background: rgba(124,255,176,.10);
      border-color: rgba(124,255,176,.55);
    }

    .hr{ height:1px; background: rgba(42,52,71,.7); margin: 12px 0; }
    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ flex:1; }
    .label{ font-size:11px; color:var(--muted); margin:0 0 6px 2px; }
    .toolbarRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .tag{
      display:inline-flex; align-items:center; gap:6px;
      border:1px solid var(--border);
      border-radius:999px;
      padding:4px 8px;
      font-size:10px;
      color:var(--muted);
      background: rgba(255,255,255,.02);
    }
    .tag.dirty{ border-color: rgba(255,124,124,.35); color: rgba(255,124,124,.95); }

    /* Library */
    .library{ padding:14px; gap:14px; }
    .grid2{ display:grid; grid-template-columns: 1.15fr .85fr; gap:14px; min-height:0; }
    .list{ border:1px solid var(--border); border-radius: 14px; overflow:hidden; background: rgba(255,255,255,.02); }
    .listHeader{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .listHeader .title{ font-size:12px; font-weight:700; }
    .listBody{ overflow:auto; }
    .item{
      padding:10px 12px;
      display:flex; justify-content:space-between; align-items:flex-start;
      gap:10px;
      border-bottom:1px solid rgba(42,52,71,.7);
    }
    .item:last-child{ border-bottom:none; }
    .listBody .item{
      cursor:pointer;
      transition: background 120ms ease, border-color 120ms ease;
    }
    .listBody .item:hover{
      background: rgba(124, 193, 255, 0.12);
      border-color: rgba(124, 193, 255, 0.45);
    }
    .item .left{ min-width:0; flex:1; }
    .item .name{ font-weight:750; font-size:12px; margin:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .item .meta{ margin-top:4px; font-size:11px; color:var(--muted); display:flex; flex-wrap:wrap; gap:10px; }
    .item .actions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }

    /* Editor */
    .editor{ padding:14px; gap:14px; display:flex; flex-direction:column; min-height:0; flex:1; }
    .gridEditor{
      flex:1;
      display:grid;
      grid-template-columns: 320px 1.1fr 520px;
      gap:14px;
      min-height:0;
      height:100%;
    }
    .gridEditor.matrixExpanded{
      grid-template-columns: 0 1fr 520px;
    }
    .gridEditor.matrixExpanded .listPanel{
      display:none;
    }
    .gridEditor.matrixExpanded .editorPanel{
      grid-column: 1 / 3;
    }
    .gridEditor.matrixExpanded .aiPanel{
      grid-column: 3 / 4;
    }
    .gridEditor.matrixExpanded .matrixViewport{
      height:520px;
    }
    .testRow{
      padding:10px 10px;
      border:1px solid rgba(42,52,71,.65);
      border-radius: 14px;
      background: rgba(255,255,255,.02);
      cursor:pointer;
      transition: border-color .15s ease, background .15s ease;
      margin-bottom:10px;
    }
    .testRow:hover{ border-color: rgba(124,196,255,.28); background: rgba(124,196,255,.05); }
    .testRow.active{ border-color: rgba(124,196,255,.55); background: rgba(124,196,255,.10); }
    .testRow.review-pending{ border-color: rgba(255,124,124,.35); background: rgba(255,124,124,.08); }
    .testRow.review-working{ border-color: rgba(255,211,124,.55); background: rgba(255,211,124,.12); }
    .testRow.review-done{ border-color: rgba(124,255,176,.40); background: rgba(124,255,176,.10); }
    .testRow.dragging{ opacity:.55; }
    .testRow.dragover{ outline:2px dashed rgba(124,196,255,.55); outline-offset:-4px; }
    .testRow .top{ display:flex; justify-content:space-between; align-items:flex-start; gap:8px; }
    .testRow .tno{ font-family: var(--mono); font-size:12px; font-weight:800; letter-spacing:.2px; }
    .testRow .tname{ margin-top:4px; font-size:12px; font-weight:650; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .testRow .sub{ margin-top:4px; font-size:11px; color: var(--muted); display:flex; gap:8px; flex-wrap:wrap; }

    .formGrid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .formGrid .full{ grid-column: 1 / -1; }
    .fieldHead{ display:flex; align-items:center; justify-content:flex-start; gap:6px; }
    .fieldHead .tag{ margin-bottom:4px; }
    .matrixWrap{
      border:1px solid var(--border);
      border-radius:12px;
      background: rgba(255,255,255,.02);
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:220px;
    }
    .matrixToolbar{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .matrixToolbar .tag{ margin-left:0; }
    .matrixZoomControls{ display:inline-flex; gap:6px; align-items:center; }
    .matrixViewport{
      border:1px solid rgba(42,52,71,.6);
      border-radius:10px;
      background: rgba(15,20,30,.45);
      overflow:auto;
      height:320px;
      position:relative;
      cursor: grab;
    }
    .matrixViewport.dragging{ cursor: grabbing; }
    .matrixCanvas{
      transform-origin: 0 0;
      min-width: 100%;
    }
    .matrixTable{
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
    }
    .matrixTable th,
    .matrixTable td{
      border:1px solid rgba(42,52,71,.6);
      padding:0;
      background: rgba(255,255,255,.02);
    }
    .matrixTable th{
      font-size:11px;
      color: var(--muted);
      background: rgba(42,52,71,.25);
      padding:6px 8px;
      text-align:left;
      font-weight:600;
      min-width:140px;
      position:relative;
    }
    .matrixTable th.matrixCorner{
      min-width:120px;
    }
    .matrixRowLabel{
      font-size:11px;
      color: var(--muted);
      padding:6px 8px;
      white-space:nowrap;
      background: rgba(42,52,71,.18);
      min-width:120px;
    }
    .matrixInput{
      width:100%;
      border:none;
      background: transparent;
      color: var(--text);
      padding:8px;
      font-size:12px;
      outline:none;
      min-width:140px;
    }
    .matrixColResizer{
      position:absolute;
      right:2px;
      top:4px;
      bottom:4px;
      width:6px;
      cursor: col-resize;
      border-radius: 6px;
      background: transparent;
    }
    .matrixColResizer:hover{
      background: rgba(124,196,255,.25);
    }
    .matrixInput:focus{
      background: rgba(124,196,255,.08);
    }
    .matrixInput.matrixDirty{
      background: rgba(124,255,176,.12);
      box-shadow: 0 0 0 1px rgba(124,255,176,.35) inset;
    }
    .matrixInput.matrixPrompt{
      background: rgba(255, 218, 132, .12);
      box-shadow: 0 0 0 1px rgba(255, 218, 132, .45) inset;
    }
    .matrixInput.matrixMatch{
      background: rgba(124,196,255,.18);
      box-shadow: 0 0 0 1px rgba(124,196,255,.45) inset;
    }
    .matrixSearch{
      height:26px;
      min-width:120px;
      width:140px;
      font-size:11px;
      padding:0 8px;
      border-radius: 10px;
    }
    .matrixHint{
      font-size:10px;
      color: var(--muted);
    }
    .req{ display:inline-flex; align-items:center; gap:6px; font-size:10px; color: rgba(255,211,124,.95); }
    .req::before{ content:"●"; font-size:10px; }
    .hint{ font-size:11px; color: var(--muted); margin-top:6px; line-height:1.35; }

    .tabs{ display:flex; gap:8px; align-items:center; }
    .tab{
      display:inline-flex;
      align-items:center;
      height:27px;
      padding:0 9px;
      border-radius: 10px;
      font-size:11px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      cursor:pointer;
      user-select:none;
    }
    .tab.active{ border-color: rgba(124,196,255,.45); background: rgba(124,196,255,.10); }
    .tabContent{ display:none; }
    .tabContent.active{ display:flex; flex-direction:column; min-height:0; }
    .miniTabs{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .miniTab{
      display:inline-flex;
      align-items:center;
      height:27px;
      padding:0 9px;
      border-radius: 10px;
      font-size:11px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      cursor:pointer;
      user-select:none;
    }
    .miniTab.active{ border-color: rgba(124,196,255,.45); background: rgba(124,196,255,.10); }
    .miniTabContent{ display:none; }
    .miniTabContent.active{ display:block; }

    .flowWrap, .mdWrap{
      border:1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,.02);
      overflow:hidden;
    }
    #tab-md .mdWrap{ flex:1; display:flex; flex-direction:column; min-height:0; }
    .flowTop, .mdTop{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    svg{ display:block; width:100%; height:520px; background: transparent; shape-rendering: crispEdges; }
    .flowWrap svg{ cursor: grab; }
    .flowWrap svg.dragging{ cursor: grabbing; }
    .svgNote{ padding:10px 12px; border-top:1px solid var(--border); color: var(--muted); font-size:11px; line-height:1.35; }

    .mdArea{
      width:100%;
      min-height: 240px;
      font-family: var(--mono);
      font-size:11px;
      line-height:1.4;
      border:none;
      outline:none;
      padding:12px;
      background: transparent;
      color: var(--text);
      resize: vertical;
    }
    .mdPreview{
      padding:12px;
      font-family: var(--mono);
      font-size:11px;
      line-height:1.4;
      white-space: pre-wrap;
      color: var(--text);
      border-top: 1px solid rgba(42,52,71,.7);
      max-height: 260px;
      overflow:auto;
      flex:1;
      min-height:0;
    }
    .chatWrap{ display:flex; flex-direction:column; gap:10px; min-height:0; height:100%; flex:1; }
    .chatLog{
      flex:1;
      min-height:0;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      background: rgba(255,255,255,.03);
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size:12px;
      line-height:1.4;
    }
    .chatMsg{ padding:8px 10px; border-radius:10px; max-width:85%; }
    .chatMsg.user{ align-self:flex-end; background: rgba(68,140,255,.18); border:1px solid rgba(68,140,255,.35); }
    .chatMsg.ai{ align-self:flex-start; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); }
    .chatInput{ min-height:90px; height:90px; resize:none; }
    .fieldSelected{
      outline:2px solid #4fb66a;
      box-shadow: inset 0 0 0 1px rgba(79,182,106,.45);
      background: rgba(79,182,106,.12);
    }

    /* Log */
    .logbar{
      height: 150px;
      border-top:1px solid var(--border);
      background: rgba(10,14,20,.55);
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .logHead{
      padding:10px 12px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border-bottom:1px solid rgba(42,52,71,.7);
    }
    .logHead .title{ font-size:12px; font-weight:750; }
    .log{
      flex:1;
      padding:10px 12px;
      overflow:auto;
      font-family: var(--mono);
      font-size:11px;
      color: rgba(231,237,247,.92);
      line-height:1.35;
    }
    .log .line{ margin-bottom:6px; }
    .log .time{ color: rgba(167,179,200,.85); }
    .log .ok{ color: rgba(124,255,176,.95); }
    .log .warn{ color: rgba(255,211,124,.95); }
    .log .bad{ color: rgba(255,124,124,.95); }

    /* Toast */
    .toast{
      position: fixed;
      right: 16px;
      top: 64px;
      max-width: 520px;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(20,26,36,.92);
      box-shadow: var(--shadow);
      display:none;
      z-index: 50;
      font-size:12px;
      color: var(--text);
    }
    .toast.show{ display:block; }
    .toast .t{ font-weight:750; }
    .toast .m{ margin-top:4px; color: var(--muted); }

    .contextMenu{
      position:fixed;
      z-index: 9999;
      min-width: 200px;
      background: rgba(16,22,34,.98);
      border:1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding:6px;
      display:none;
    }
    .contextMenu button{
      width:100%;
      text-align:left;
      border:none;
      background:transparent;
      color:var(--text);
      font-size:12px;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
    }
    .contextMenu button:hover{
      background: rgba(124,196,255,.12);
    }

    /* Modal */
    .modalOverlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 100;
      padding: 18px;
    }
    .modalOverlay.show{ display:flex; }
    .modal{
      width: min(980px, 100%);
      max-height: 86vh;
      overflow:hidden;
      border-radius: 18px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(20,26,36,.96), rgba(16,22,34,.96));
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .modal.wide{ width: min(1200px, 100%); }
    .modalHeader{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modalHeader h3{ margin:0; font-size:13px; font-weight:800; }
    .modalBody{ padding:14px; overflow:auto; min-height:0; }
    .modalFooter{
      padding:12px 14px;
      border-top:1px solid var(--border);
      display:flex;
      justify-content:flex-end;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    /* Scrollbars */
    ::-webkit-scrollbar{ width: 12px; height: 12px; }
    ::-webkit-scrollbar-thumb{
      background: rgba(167,179,200,.18);
      border-radius: 999px;
      border: 3px solid rgba(0,0,0,0);
      background-clip: padding-box;
    }
    ::-webkit-scrollbar-thumb:hover{ background: rgba(167,179,200,.28); }
    ::-webkit-scrollbar-corner{ background: transparent; }

    @media (max-width: 1280px){
      .gridEditor{ grid-template-columns: 300px 1fr; }
      .gridEditor > .panel:nth-child(3){ grid-column: 1 / -1; }
      svg{ height: 420px; }
    }
    @media (max-width: 980px){
      .grid2{ grid-template-columns: 1fr; }
      .status{ min-width: 0; }
      .planBadge{ max-width: 55%; }
    }
    .splash{
      position: fixed;
      inset: 0;
      background: rgba(10,14,22,0.75);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
    .splashCard{
      width: min(720px, 92vw);
      background: linear-gradient(180deg, rgba(22,28,42,0.98), rgba(18,24,36,0.98));
      border: 1px solid rgba(124,196,255,.25);
      border-radius: 16px;
      padding: 20px 22px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
    }
    .splashHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .splashTitle{ font-size:18px; font-weight:700; }
    .splashBody{ font-size:12px; color: var(--muted); line-height:1.6; }
    .splashDisclaimer{
      margin-top:12px;
      font-size:18px;
      font-weight:800;
      letter-spacing:.4px;
      text-transform:uppercase;
      color: var(--text);
    }
    .splashList{ margin:10px 0 0 16px; }
    .splashActions{ margin-top:16px; display:flex; gap:10px; }
    .splashPath{
      margin-top:10px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;
      background: rgba(255,255,255,.04);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      color: var(--text);
      word-break: break-all;
    }
  </style>
</head>

<body>
<div class="splash" id="splashScreen">
  <div class="splashCard">
    <div class="splashHeader">
      <div class="splashTitle">Welcome to Test Base 2026</div>
      <button class="btn mini" id="splashClose">Close</button>
    </div>
    <div class="splashBody">
      Create, edit, and review structured documents with templates and AI assistance.
      <ul class="splashList">
        <li>Use the Library to open or create documents.</li>
        <li>Build lists with templates and inline editing.</li>
        <li>Run AI Review or chat for guided updates.</li>
      </ul>
    </div>
    <div class="splashActions">
      <button class="btn primary" id="splashStart">Get Started</button>
    </div>
    <div class="splashDisclaimer">Provided for educational use only.</div>
  </div>
</div>
<div class="splash" id="splashFolder">
  <div class="splashCard">
    <div class="splashHeader">
      <div class="splashTitle">Word Exports Setup</div>
      <button class="btn mini" id="splashFolderClose">Close</button>
    </div>
    <div class="splashBody">
      For Word Document exports to work, set the Library Folder using <strong>Set Library Folder</strong> to:
      <div class="splashPath">C:\Repos\test_base_2026</div>
    </div>
    <div class="splashActions">
      <button class="btn primary" id="splashFolderPrefs">Open Preferences</button>
      <button class="btn" id="splashFolderDone">Continue</button>
    </div>
  </div>
</div>
<div class="app">
  <!-- TOPBAR -->
    <div class="topbar">
      <div class="brand" title="Single-file HTML prototype">
      <h1 id="appTitle">Test Base 2026</h1>
    </div>

    <div class="menu">

      <div class="planBadge" id="planBadge" style="display:none;">
        <div class="name clickableText" id="planBadgeName">—</div>
        <div class="sub" id="planBadgeSub">0 sections</div>
      </div>

      <div style="flex:1; min-width:0;"></div>
    </div>

    <div class="status">
      <div class="pill" id="switchPlanBtn" title="Return to Document Library" style="display:none;">Switch Document</div>
      <div class="pill" id="saveAllBtn" style="display:none;">Save All</div>
      <div class="chip clickable" id="aiChip" title="AI is optional. Saving never depends on AI.">
        <span class="led bad" id="aiLed"></span>
        <span><strong>AI</strong> <span id="aiText">Proxy</span></span>
      </div>
    </div>
  </div>

  <!-- MAIN -->
  <div class="main">
    <!-- LIBRARY VIEW -->
    <div class="view library active" id="viewLibrary">
      <div class="grid2" style="min-height:0; flex:1;">
            <div class="card" style="min-height:0;">
              <div class="cardHeader">
                <div>
                  <h2>Library</h2>
                  <div class="muted" id="plansSub"></div>
                </div>
                <div class="toolbarRow">
                  <div style="width: 260px;">
                    <input class="input" id="planSearch" placeholder="Search documents by name…" />
                  </div>
                  <button class="btn primary" id="btnNewPlan">Create New</button>
                </div>
              </div>

              <div class="cardBody" style="padding:0; min-height:0;">
                <div class="list" style="border:none; border-radius:0;">
                  <div class="listHeader">
                    <div class="title">Templates</div>
                    <div class="muted" id="templatesCount">0</div>
                  </div>
                  <div class="listBody" id="templatesList"></div>
                </div>
                <div class="hr"></div>
                <div class="list" style="border:none; border-radius:0;">
                  <div class="listHeader">
                    <div class="title">Documents</div>
                    <div class="muted" id="plansCount">0</div>
                  </div>
                  <div class="listBody" id="plansList"></div>
                </div>
              </div>
            </div>

            <div class="card" style="min-height:0;">
              <div class="cardHeader">
                <div>
                  <h2>Workspace</h2>
                  <div class="muted">Workspace stats, storage, and maintenance tools.</div>
                </div>
                <button class="btn" id="btnPrefs">Preferences</button>
              </div>

              <div class="cardBody" style="min-height:0;">
                <div class="row">
                  <div>
                    <div class="label">Total Documents</div>
                    <div class="input" style="display:flex;align-items:center;" id="wsPlanCount">0</div>
                  </div>
                  <div>
                    <div class="label">Total Sections</div>
                    <div class="input" style="display:flex;align-items:center;" id="wsTestCount">0</div>
                  </div>
                </div>

                <div class="hr"></div>

                <div class="row">
                  <div>
                    <div class="label">Total Templates</div>
                    <div class="input" style="display:flex;align-items:center;" id="wsTemplateCount">0</div>
                  </div>
                  <div>
                    <div class="label">Template Sections</div>
                    <div class="input" style="display:flex;align-items:center;" id="wsTemplateTestCount">0</div>
                  </div>
                </div>

                <div class="hr"></div>
                <div class="label">Example Documents</div>
                <div class="toolbarRow" style="margin-top:8px;">
                  <button class="btn" id="btnSeedDemo">Electronics Test Plan</button>
                  <button class="btn" id="btnSeedSpec">Specifications Document</button>
                  <button class="btn" id="btnSeedRtm">Requirements Traceability Matrix</button>
                  <button class="btn" id="btnSeedBom">Bill of Materials</button>
                  <button class="btn" id="btnSeedVerify">Verification Matrix</button>
                  <button class="btn" id="btnSeedDesignReview">Design Review Checklist</button>
                  <button class="btn" id="btnSeedIcd">Interface Control Document</button>
                  <button class="btn" id="btnSeedFmea">FMEA</button>
                  <button class="btn" id="btnSeedEmc">EMC/EMI Compliance Plan</button>
                </div>
              </div>
            </div>

      </div>
    </div>

    <!-- EDITOR VIEW -->
      <div class="view editor" id="viewEditor" style="display:none;">
      <div class="gridEditor">
        <!-- Left -->
        <div class="panel listPanel">
          <div class="panelHeader">
            <h3 id="testListTitle">List</h3>
            <div class="toolbarRow">
              <button class="btn mini primary" id="btnNewTest">New Test</button>
              <button class="btn mini" id="btnManageTestTemplates">Templates</button>
            </div>
          </div>
          <div class="panelBody">
            <div class="row" style="margin-bottom:10px;">
              <input class="input" id="testSearch" placeholder="Search…" />
            </div>
            <div id="testsList"></div>
          </div>
        </div>

        <!-- Center -->
        <div class="panel editorPanel">
          <div class="panelHeader">
            <div style="min-width:0;">
              <h3 style="margin:0;">Editor</h3>
              <div class="muted" id="editorSub">No test selected</div>
              <div class="muted" id="templateEditSub" style="display:none;"></div>
            </div>
            <div class="toolbarRow">
              <button class="btn mini" id="btnAiSuggest" title="Suggest text for the focused field">AI Suggest</button>
            </div>
          </div>

          <div class="panelBody">
            <div class="muted" style="margin-bottom:10px; line-height:1.45;">
            </div>

            <div class="formGrid" id="formGrid"></div>

            <div class="hr"></div>

            <div class="label" style="display:flex; align-items:center; gap:8px;">
              <span>Review Notes</span>
              <span class="tag" title="Notes maturity">M3</span>
            </div>
            <textarea class="input" id="reviewNotes" spellcheck="false"></textarea>

            <div class="hr"></div>

            <div class="row">
              <button class="btn" id="btnShowJson">View Current JSON</button>
            </div>

            <div class="hint" id="dirtyHint" style="display:none;">
              <span style="color: rgba(255,124,124,.95); font-weight:700;">● Modified</span>
              — changes not saved yet.
            </div>
          </div>
        </div>

        <!-- Right -->
        <div class="panel aiPanel">
          <div class="panelHeader">
            <div>
              <h3 style="margin:0;">AI Interface</h3>
              <div class="muted">AI Model: <span id="aiChatModel">—</span></div>
              <div class="aiPermRow">
                <span class="muted">AI Permission</span>
                <input class="aiPermRange" type="range" id="aiPermSlider" min="0" max="2" step="1" value="1" />
                <span class="tag" id="aiPermLabel">Revise/Edit</span>
              </div>
            </div>
          </div>

          <div class="panelBody chatPanelBody">
            <div class="chatWrap">
              <div class="chatLog" id="aiChatLog"></div>
              <textarea class="input chatInput" id="aiChatInput" placeholder="Tell the AI what to change in the document…"></textarea>
              <div class="row">
                <button class="btn primary" id="btnAiChatSend">Send</button>
                <button class="btn" id="btnAiChatClear">Clear</button>
              </div>
              <div class="hr"></div>
              <div class="row">
                <button class="btn mini" id="btnAiReviewPlan">AI Review</button>
                <button class="btn mini" id="btnAiReviewPause" disabled>Pause</button>
                <button class="btn mini danger" id="btnAiReviewCancel" disabled>Cancel</button>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- LOG -->
  <div class="logbar">
    <div class="logHead">
      <div class="title">Log</div>
      <div class="toolbarRow">
        <button class="btn mini" id="btnCopyLog">Copy</button>
        <button class="btn mini" id="btnClearLog">Clear</button>
      </div>
    </div>
    <div class="log" id="log"></div>
  </div>
</div>

<!-- TOAST -->
<div class="toast" id="toast">
  <div class="t" id="toastTitle">—</div>
  <div class="m" id="toastMsg">—</div>
</div>

<div class="contextMenu" id="contextMenu"></div>

<!-- MODAL -->
<div class="modalOverlay" id="modalOverlay">
  <div class="modal" id="modal">
    <div class="modalHeader">
      <h3 id="modalTitle">Modal</h3>
    </div>
    <div class="modalBody" id="modalBody"></div>
    <div class="modalFooter" id="modalFooter"></div>
  </div>
</div>

<script>
(() => {
  /* =========================================================
     Test Base 2026 — Skeleton
      - File System document folders when enabled (fallback to Browser Store)
     - Document Library + Document Editor
     - Schema-driven form editor
     - Non-blocking save fallback
     - Markdown + Flowchart tabs
     ========================================================= */

  /* ---------- Schema (edit freely) ---------- */
  const TEST_SCHEMA_DEFAULT = Object.freeze({
    section_title: "",
    section_no: "",
    uut_pn: "",
    last_section_no: "",
    section_type: "",
    test_equipment: "",
    purpose: "",
    scope: "",
    setup: "",
    procedure: "",
    measurement: "",
    parameter: "",
    signal_pin: "N/A",
    return_pin: "N/A",
    ll: "N/A",
    tv: "N/A",
    ul: "N/A",
    units: "N/A",
    param1_label: "Units",
    param1_value: "units",
    param2_label: "Target Value",
    param2_value: "tv",
    // dependency-ish fields (wire these into flowchart later)
    in_tol_conclusion: "",
    in_tol_next_step: "",
    oot_low_conclusion: "",
    oot_low_unable_adjust: "",
    oot_low_next_step: "",
    oot_high_conclusion: "",
    oot_high_unable_adjust: "",
    oot_high_next_step: ""
  });

  const DEFAULT_FIELD_LABELS = Object.freeze({
    section_title: "Test Name",
    section_no: "Test No",
    uut_pn: "UUT P/N",
    last_section_no: "Last Test No",
    section_type: "Test Type",
    test_equipment: "Test Equipment",
    purpose: "Purpose",
    scope: "Scope",
    setup: "Setup",
    procedure: "Procedure",
    measurement: "Measurement",
    parameter: "Parameter",
    signal_pin: "Signal Pin",
    return_pin: "Return Pin",
    ll: "Lower Limit (ll)",
    tv: "Target Value (tv)",
    ul: "Upper Limit (ul)",
    units: "Units",
    param1_label: "Param 1 Label",
    param1_value: "Param 1 Value",
    param2_label: "Param 2 Label",
    param2_value: "Param 2 Value",
    in_tol_conclusion: "In-Tolerance Conclusion",
    in_tol_next_step: "In-Tolerance Next Step",
    oot_low_conclusion: "OOT Low Conclusion",
    oot_low_unable_adjust: "OOT Low Unable to Adjust Conclusion",
    oot_low_next_step: "OOT Low Next Step",
    oot_high_conclusion: "OOT High Conclusion",
    oot_high_unable_adjust: "OOT High Unable to Adjust Conclusion",
    oot_high_next_step: "OOT High Next Step"
  });

  const DEFAULT_FIELD_PROMPTS = Object.freeze({
    section_title: "Provide a short, descriptive test name.",
    section_no: "Provide the test number (e.g., 001).",
    uut_pn: "",
    last_section_no: "Enter the prior test number that precedes this step (or N/A).",
    section_type: "Specify the test type/category (e.g., Inspection, Functional Verification).",
    test_equipment: "List required test equipment and tools.",
    purpose: "State the objective of this test in one concise paragraph.",
    scope: "Define what is covered/excluded and conditions for this test.",
    setup: "List required equipment, connections, and initial conditions.",
    procedure: "Write a step-by-step procedure; keep it clear and sequential.",
    measurement: "Describe what is measured, how, and with what instruments.",
    parameter: "List key parameters and acceptance references.",
    signal_pin: "Specify the signal pin identifier or N/A.",
    return_pin: "Specify the return pin identifier or N/A.",
    ll: "Enter the lower limit value or N/A.",
    tv: "Enter the target value or N/A.",
    ul: "Enter the upper limit value or N/A.",
    units: "Enter measurement units (e.g., V, A, W) or N/A.",
    param1_label: "Enter the label for Parameter 1 (e.g., Units).",
    param1_value: "Select which field supplies Parameter 1's value.",
    param2_label: "Enter the label for Parameter 2 (e.g., Target Value).",
    param2_value: "Select which field supplies Parameter 2's value.",
    in_tol_conclusion: "Describe pass criteria and expected conclusion when in tolerance.",
    in_tol_next_step: "Specify the next test number or END PASS.",
    oot_low_conclusion: "Describe failure criteria for low out-of-tolerance.",
    oot_low_unable_adjust: "Describe actions when adjustment is not possible after low OOT.",
    oot_low_next_step: "Specify next action/step after low OOT.",
    oot_high_conclusion: "Describe failure criteria for high out-of-tolerance.",
    oot_high_unable_adjust: "Describe actions when adjustment is not possible after high OOT.",
    oot_high_next_step: "Specify next action/step after high OOT."
  });

  const DEFAULT_REVIEW_PERSONALITIES = Object.freeze({
    quality_assurance: "Quality Assurance",
    design_engineer: "Design Engineer",
    reliability_analyst: "Reliability Analyst"
  });

  const DEFAULT_REVIEW_PERSONALITY_FOCUS = Object.freeze({
    quality_assurance: "compliance, clarity, completeness, and acceptance criteria",
    design_engineer: "technical correctness, feasibility, and alignment with design intent",
    reliability_analyst: "robustness, failure modes, and long-term reliability risks"
  });

  const DEFAULT_REVIEW_PERSONALITY_GUIDANCE = Object.freeze({
    quality_assurance: "",
    design_engineer: "",
    reliability_analyst: ""
  });

  function getPlanReviewPersonas(plan){
    const out = {};
    for(const [id,label] of Object.entries(DEFAULT_REVIEW_PERSONALITIES)){
      out[id] = {
        label,
        focus: DEFAULT_REVIEW_PERSONALITY_FOCUS[id] || "",
        guidance: DEFAULT_REVIEW_PERSONALITY_GUIDANCE[id] || ""
      };
    }
    const src = plan?.review_personalities;
    if(src && typeof src === "object"){
      for(const [id,p] of Object.entries(src)){
        const key = String(id || "").trim();
        if(!key) continue;
        out[key] = {
          label: safeStringify(p?.label) || key,
          focus: safeStringify(p?.focus) || (out[key]?.focus || ""),
          guidance: safeStringify(p?.guidance) || (out[key]?.guidance || "")
        };
      }
    }
    return out;
  }

  function normalizePersonaId(id){
    return String(id || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, "_")
      .replace(/[^a-z0-9_]/g, "");
  }

  function seedReviewComment(personaId, label, prompt){
    const lbl = label || "this field";
    const guide = prompt ? ` Guide: ${prompt}` : "";
    switch(personaId){
      case "quality_assurance":
        return `Validate ${lbl} for completeness, clarity, and acceptance criteria.${guide}`;
      case "design_engineer":
        return `Verify ${lbl} is technically correct and aligned with design intent.${guide}`;
      case "reliability_analyst":
        return `Check ${lbl} for robustness and failure-mode coverage.${guide}`;
      default:
        return `Review ${lbl} for clarity and correctness.${guide}`;
    }
  }

  function buildSeedReviewPersonalitiesForData(data){
    const keys = Object.keys(data || {}).filter(k => k !== "_ai");
    const ai = data._ai || ensureAiMeta(null, keys);
    const out = {};
    for(const [id,label] of Object.entries(DEFAULT_REVIEW_PERSONALITIES)){
      const field_comments = {};
      for(const k of keys){
        const lbl = ai.field_labels?.[k] || k;
        const prompt = ai.field_prompts?.[k] || "";
        field_comments[k] = seedReviewComment(id, lbl, prompt);
      }
      out[id] = {
        label,
        last_reviewed: nowIsoTimestamp(),
        model: "seed",
        summary: "Seed review comments generated for all fields.",
        notes: "",
        field_comments
      };
    }
    return out;
  }

  function buildDefaultReviewPersonalities(keys, personaDefs){
    const fieldKeys = Array.isArray(keys) ? keys : Object.keys(TEST_SCHEMA_DEFAULT);
    const defs = personaDefs && typeof personaDefs === "object" ? personaDefs : DEFAULT_REVIEW_PERSONALITIES;
    const out = {};
    for(const [id,p] of Object.entries(defs)){
      const label = typeof p === "string" ? p : (p?.label || id);
      const field_comments = {};
      for(const k of fieldKeys) field_comments[k] = "";
      out[id] = {
        label,
        last_reviewed: "",
        model: "",
        summary: "",
        notes: "",
        field_comments
      };
    }
    return out;
  }

  function mergeReviewPersonalities(base, override, keys, personaDefs){
    const fieldKeys = Array.isArray(keys) ? keys : Object.keys(TEST_SCHEMA_DEFAULT);
    const defs = personaDefs && typeof personaDefs === "object" ? personaDefs : DEFAULT_REVIEW_PERSONALITIES;
    const out = structuredClone(base || {});
    for(const [id,p] of Object.entries(defs)){
      const label = typeof p === "string" ? p : (p?.label || id);
      if(!out[id]) out[id] = { label, last_reviewed:"", model:"", summary:"", notes:"", field_comments:{} };
      if(!out[id].label) out[id].label = label;
    }
    if(override && typeof override === "object"){
      for(const [id, p] of Object.entries(override)){
        if(!out[id]){
          out[id] = { label: safeStringify(p?.label) || id, last_reviewed:"", model:"", summary:"", notes:"", field_comments:{} };
        }
        const dest = out[id];
        if(p && typeof p === "object"){
          if(p.label != null) dest.label = safeStringify(p.label);
          if(p.last_reviewed != null) dest.last_reviewed = safeStringify(p.last_reviewed);
          if(p.model != null) dest.model = safeStringify(p.model);
          if(p.summary != null) dest.summary = safeStringify(p.summary);
          if(p.notes != null) dest.notes = safeStringify(p.notes);
          if(p.field_comments && typeof p.field_comments === "object"){
            dest.field_comments = { ...(dest.field_comments || {}) };
            for(const [k,v] of Object.entries(p.field_comments)){
              dest.field_comments[k] = safeStringify(v);
            }
          }
        }
      }
    }
    for(const id of Object.keys(out)){
      if(!(id in defs)) delete out[id];
    }
    for(const id of Object.keys(out)){
      const dest = out[id];
      if(!dest.field_comments || typeof dest.field_comments !== "object") dest.field_comments = {};
      for(const k of fieldKeys){
        if(!(k in dest.field_comments)) dest.field_comments[k] = "";
      }
    }
    return out;
  }

  const TEXTAREA_FIELDS = Object.freeze([
    "purpose","scope","setup","test_equipment","procedure","measurement","parameter",
    "in_tol_conclusion","in_tol_next_step",
    "oot_low_conclusion","oot_low_unable_adjust","oot_low_next_step",
    "oot_high_conclusion","oot_high_unable_adjust","oot_high_next_step"
  ]);

  const DEFAULT_FIELD_TYPES = Object.freeze(
    Object.keys(TEST_SCHEMA_DEFAULT).reduce((acc, k) => {
      acc[k] = TEXTAREA_FIELDS.includes(k) ? "textarea" : "text";
      return acc;
    }, {})
  );

  const REQUIRED_FIELDS = Object.freeze([
    "section_title","section_no","uut_pn","section_type",
    "purpose","setup","procedure","measurement",
    "in_tol_conclusion","in_tol_next_step",
    "oot_low_conclusion","oot_low_next_step",
    "oot_high_conclusion","oot_high_next_step"
  ]);

  const MARKERS = Object.freeze({
    start: "<!-- USER_NOTES_START -->",
    end: "<!-- USER_NOTES_END -->"
  });

  /* ---------- DOM helpers ---------- */
  const $ = (id) => document.getElementById(id);

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
    }[c]));
  }

  function cssEscape(val){
    return String(val).replace(/[^a-zA-Z0-9_-]/g, (ch) => `\\${ch}`);
  }

  function nowIsoDate(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }

  function nowIsoTimestamp(){
    return new Date().toISOString();
  }

  function sleep(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function uid(){
    return crypto.randomUUID ? crypto.randomUUID() : `id_${Math.random().toString(16).slice(2)}_${Date.now()}`;
  }

  function slugifyPlanName(name){
    return (name || "")
      .toLowerCase()
      .replace(/\s+/g, "_")
      .replace(/[^a-z0-9_]/g, "")
      .replace(/_+/g, "_")
      .replace(/^_+|_+$/g, "") || "untitled_plan";
  }

  function safeStringify(val){
    if (val === null || val === undefined) return "";
    if (typeof val === "string") return val;
    if (typeof val === "number" || typeof val === "boolean" || typeof val === "bigint") return String(val);
    try { return JSON.stringify(val); } catch { return String(val); }
  }

  function sanitizeAiText(value){
    if(value === null || value === undefined) return "";
    let text = String(value);
    // Normalize non-standard characters that can break Word imports
    const replacements = {
      "\u2018": "'", "\u2019": "'", "\u201A": "'", "\u201B": "'",
      "\u201C": "\"", "\u201D": "\"", "\u201E": "\"", "\u201F": "\"",
      "\u2026": "...",
      "\u2010": "-", "\u2011": "-", "\u2012": "-", "\u2013": "-", "\u2014": "-", "\u2015": "-",
      "\u00C2": "",
      "\u00A0": " ", "\u2007": " ", "\u202F": " ",
      "\u200B": "", "\u200C": "", "\u200D": "", "\u2060": "", "\uFEFF": ""
    };
    text = text.replace(/[\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2026\u2010\u2011\u2012\u2013\u2014\u2015\u00C2\u00A0\u2007\u202F\u200B\u200C\u200D\u2060\uFEFF]/g, (ch) => replacements[ch] ?? ch);
    text = text.replace(/â€‘/g, "-");
    text = text.replace(/Â±/g, "±").replace(/Â°C/g, "°C").replace(/Â°/g, "°");
    // Strip control chars except tab/newline/CR
    text = text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, "");
    return text;
  }

    function ensureAiMeta(ai, dataKeys){
      const out = {
        maturity: {},
        last_ai_reviewed: "",
        last_ai_review_model: "",
        last_human_reviewed: "",
        notes: "",
        review_personalities: {},
        field_labels: {},
        field_prompts: {},
        field_types: {},
        field_options: {},
        field_schema: {}
      };
    if(ai && typeof ai === "object"){
      if(ai.maturity && typeof ai.maturity === "object"){
        for(const [k,v] of Object.entries(ai.maturity)){
          const n = Number(v);
          out.maturity[k] = Number.isFinite(n) ? n : 0;
        }
      }
      out.last_ai_reviewed = safeStringify(ai.last_ai_reviewed);
      out.last_ai_review_model = safeStringify(ai.last_ai_review_model);
      out.last_human_reviewed = safeStringify(ai.last_human_reviewed);
      out.notes = safeStringify(ai.notes);
      if(ai.field_labels && typeof ai.field_labels === "object"){
        for(const [k,v] of Object.entries(ai.field_labels)){
          out.field_labels[k] = safeStringify(v);
        }
      }
      if(ai.field_prompts && typeof ai.field_prompts === "object"){
        for(const [k,v] of Object.entries(ai.field_prompts)){
          out.field_prompts[k] = safeStringify(v);
        }
      }
      if(ai.field_types && typeof ai.field_types === "object"){
        for(const [k,v] of Object.entries(ai.field_types)){
          out.field_types[k] = safeStringify(v);
        }
      }
      if(ai.field_options && typeof ai.field_options === "object"){
        for(const [k,v] of Object.entries(ai.field_options)){
          out.field_options[k] = Array.isArray(v) ? v.map(x => safeStringify(x)) : [];
        }
      }
      if(ai.field_schema && typeof ai.field_schema === "object"){
        for(const [k,v] of Object.entries(ai.field_schema)){
          out.field_schema[k] = cloneJsonValue(v);
        }
      }
    }
      const keys = Array.isArray(dataKeys) ? dataKeys : Object.keys(TEST_SCHEMA_DEFAULT);
      for(const k of keys){
        if(!(k in out.maturity)){
          const isParam = (k === "param1_label" || k === "param1_value" || k === "param2_label" || k === "param2_value");
          const isPin = (k === "signal_pin" || k === "return_pin");
          out.maturity[k] = (isParam || isPin) ? 3 : 0;
        }
        if(!(k in out.field_labels)) out.field_labels[k] = DEFAULT_FIELD_LABELS[k] || k;
        if(!(k in out.field_prompts)) out.field_prompts[k] = DEFAULT_FIELD_PROMPTS[k] || "";
        if(!(k in out.field_types)) out.field_types[k] = DEFAULT_FIELD_TYPES[k] || "text";
      }
      out.review_personalities = mergeReviewPersonalities(
        buildDefaultReviewPersonalities(keys),
        ai && typeof ai === "object" ? ai.review_personalities : null,
        keys
      );
      out.maturity.last_ai_reviewed = Math.max(Number(out.maturity.last_ai_reviewed) || 0, 4);
      out.maturity.last_ai_review_model = Math.max(Number(out.maturity.last_ai_review_model) || 0, 4);
      out.maturity.last_human_reviewed = Math.max(Number(out.maturity.last_human_reviewed) || 0, 4);
      out.maturity.notes = Math.max(Number(out.maturity.notes) || 0, 3);
    return out;
  }

  function normalizeTestData(obj){
    const out = {};
    const src = obj && typeof obj === "object" ? obj : {};
    const aiMeta = src._ai && typeof src._ai === "object" ? src._ai : null;
    const fieldTypes = aiMeta?.field_types || {};
    const dataKeys = Object.keys(src).filter(k => k !== "_ai");
    const keys = dataKeys.length ? dataKeys : Object.keys(TEST_SCHEMA_DEFAULT);
    for(const k of keys){
      const fieldType = String(fieldTypes[k] || "").toLowerCase();
      const isMatrix = fieldType.includes("matrix");
      if(isMatrix){
        out[k] = (src[k] && typeof src[k] === "object") ? cloneJsonValue(src[k]) : {};
      }else{
        out[k] = safeStringify(src[k]);
      }
      if(["ll","tv","ul","units"].includes(k) && out[k].trim() === "") out[k] = "N/A";
    }
    out._ai = ensureAiMeta(src._ai, keys);
    return out;
  }

  function cloneJsonValue(value){
    try{
      return JSON.parse(JSON.stringify(value));
    }catch{
      return value;
    }
  }

  function emptyFields(data){
    const missing = [];
    for(const k of Object.keys(data || {})){
      if(k === "_ai") continue;
      if(((data[k] ?? "") + "").trim() === "") missing.push(k);
    }
    return missing;
  }

  let AI_PROXY_BASE = (localStorage.getItem("tb26_api_base") || "https://minipcb-github-io.vercel.app/api").replace(/\/+$/,"");
  const USE_PROXY = true;

  function apiHeaders(){
    const headers = { "Content-Type": "application/json" };
    if(!USE_PROXY){
      const key = getAiKey();
      if(key) headers.Authorization = `Bearer ${key}`;
    }else{
    // Proxy key removed
    }
    return headers;
  }

  function apiUrl(path){
    return `${AI_PROXY_BASE}${path}`;
  }

  /* ---------- Preferences (minimal) ---------- */
  const DEFAULT_PREFS = Object.freeze({
    ai_enabled: false,                // skeleton toggle (legacy)
    ai_model: "gpt-4.1-mini",
    ai_suggest_maturity_max: 2,       // suggest for fields with maturity <= this
    ai_review_debug: false,           // log one AI Review payload + response
    ai_review_pause_ms: 300,          // pause between AI review field calls
    ai_review_concurrency: 1,         // concurrent AI review calls
    ai_chat_permission: 1,            // 0=search, 1=revise, 2=create/delete
    ai_maturity_clicks: 4,            // 2=inline select, 4=modal
    ui_clicks: 4,                     // 2=fast edit/review, 4=explicit
    ai_personality_dialog: false,
    test_editor_lock: "locked",
    bom_matrix_controls: true,
    new_test_template_mode: "default",// default | choose
    new_test_template_default: "__blank__"
  });

  const DEFAULT_AI_PROMPTS = Object.freeze({
    review_persona:
      "You are a {{personaLabel}}. Provide a concise review comment for this field focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
    review_field:
      "Return ONLY the field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
    review_matrix_cell:
      "Return ONLY the cell value text. No extra words, no markdown. Use matrix_cell.row_label and matrix_cell.col_label to decide what belongs in the cell. Use matrix_cell.cell_prompt if provided; otherwise use matrix_cell.col_prompt. Use matrix_cell.cell_value as the current value. If maturity <= 2, rewrite and improve the value even if it is already filled; do not return the exact same text. If you cannot improve, return an empty string. If provided, matrix_full is the initial full matrix and matrix_changes is the list of accepted changes so far. If unknown, return an empty string. Never return placeholders like \"Value\" or \"TBD\", and never repeat the column label.{{guidanceLine}}",
    chat_edit:
      "You edit a document. Permission level: {{permLabel}} ({{perm}}). Return ONLY strict JSON (no extra text, no markdown). Use these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material. If matrix_template is provided in the user payload (derived from Partlist headers), you MUST return the matrix structure ONLY (rows/cols/row_labels/col_labels/col_prompts/cells:{}), and MUST NOT include any cell data.",
    create_plan:
      "Respond with strict JSON containing: plan (goal, scope) and tests (array of sections). Provide exactly {{testCount}} sections with 3-digit section_no values and meaningful section_title values. Each section must include a set object using full schema keys: {{schemaKeys}}. Fill purpose/scope/setup/procedure/measurement/parameter and limits/units where applicable. Use source markdown tables (pin interfaces, test points, netlist, partlist) to drive content. If matrix_template is provided in the user payload (derived from Partlist headers), you MUST return the matrix structure ONLY (rows/cols/row_labels/col_labels/col_prompts/cells:{}), and MUST NOT include any cell data. No extra text.",
    suggest_field:
      "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context. If current_value contains TODO or Auto-filled text, replace it with improved content.",
    suggest_field_strict:
      "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context. If current_value contains TODO or Auto-filled text, replace it with improved content.",
    suggest_limits_note:
      "For ll/tv/ul/units, return measurement values only (e.g., numeric limits or a unit token). Do NOT return explanations."
  });

  const DOC_PROMPT_OVERRIDES = Object.freeze({
    specifications: Object.freeze({
      create_plan:
        "Return STRICT JSON: {\"plan\":{\"goal\":\"\",\"scope\":\"\"},\"tests\":[{\"section_no\":\"SEC-001\",\"section_title\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections with meaningful section titles and IDs. The set object should use full schema keys: {{schemaKeys}}. Write as a specifications document, not a test procedure. No extra text.",
      chat_edit:
        "You edit a specifications document. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
      suggest_field:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this specification section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
      suggest_field_strict:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this specification section. If current_value contains TODO or Auto-filled text, replace it with improved content."
    }),
    verification: Object.freeze({
      create_plan:
        "Return STRICT JSON: {\"plan\":{\"goal\":\"\",\"scope\":\"\"},\"tests\":[{\"section_no\":\"VM-001\",\"section_title\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for a verification matrix. The set object should use full schema keys: {{schemaKeys}}. Use concise, matrix-style language. No extra text.",
      chat_edit:
        "You edit a verification matrix. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
      suggest_field:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this verification matrix section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
      suggest_field_strict:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this verification matrix section. If current_value contains TODO or Auto-filled text, replace it with improved content."
    }),
    designReview: Object.freeze({
      create_plan:
        "Return STRICT JSON: {\"plan\":{\"goal\":\"\",\"scope\":\"\"},\"tests\":[{\"section_no\":\"DR-001\",\"section_title\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for a design review checklist. The set object should use full schema keys: {{schemaKeys}}. Use checklist-style, review-oriented language. No extra text.",
      chat_edit:
        "You edit a design review checklist. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
      suggest_field:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this design review section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
      suggest_field_strict:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this design review section. If current_value contains TODO or Auto-filled text, replace it with improved content."
    }),
    icd: Object.freeze({
      create_plan:
        "Return STRICT JSON: {\"plan\":{\"goal\":\"\",\"scope\":\"\"},\"tests\":[{\"section_no\":\"ICD-001\",\"section_title\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for an interface control document. The set object should use full schema keys: {{schemaKeys}}. Use precise interface terminology. No extra text.",
      chat_edit:
        "You edit an interface control document. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
      suggest_field:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this interface control document section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
      suggest_field_strict:
        "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this interface control document section. If current_value contains TODO or Auto-filled text, replace it with improved content."
    })
  });

  function getDocPromptOverrides(plan){
    const name = String(plan?.name || "").toLowerCase();
    if(name.includes("specifications document")) return DOC_PROMPT_OVERRIDES.specifications;
    if(name.includes("verification matrix")) return DOC_PROMPT_OVERRIDES.verification;
    if(name.includes("design review checklist")) return DOC_PROMPT_OVERRIDES.designReview;
    if(name.includes("interface control document")) return DOC_PROMPT_OVERRIDES.icd;
    return null;
  }

  function ensurePlanAiPrompts(plan){
    const overrides = getDocPromptOverrides(plan);
    if(!overrides) return false;
    if(!plan.ai_prompts) plan.ai_prompts = {};
    let changed = false;
    for(const [key, val] of Object.entries(overrides)){
      const current = plan.ai_prompts[key];
      if(!current || current === DEFAULT_AI_PROMPTS[key] || String(current).includes("You edit a document") || String(current).includes("You edit a test plan")){
        plan.ai_prompts[key] = val;
        changed = true;
      }
    }
    return changed;
  }

  function applyPromptTemplate(template, vars){
    const safe = String(template ?? "");
    return safe.replace(/\{\{\s*([\w.]+)\s*\}\}/g, (_m, key) => {
      if(!vars) return "";
      const val = vars[key];
      return val == null ? "" : String(val);
    });
  }

  function getAiPrompt(plan, key, vars){
    const raw = plan?.ai_prompts?.[key] || DEFAULT_AI_PROMPTS[key] || "";
    return applyPromptTemplate(raw, vars);
  }

  function syncPlanReviewPersonalities(plan){
    if(!plan || !Array.isArray(plan.tests)) return;
    const defs = getPlanReviewPersonas(plan);
    plan.review_personalities = defs;
    for(const t of plan.tests){
      if(!t?.data) continue;
      if(!t.data._ai) t.data._ai = ensureAiMeta(null, Object.keys(t.data).filter(k => k !== "_ai"));
      const keys = Object.keys(t.data).filter(k => k !== "_ai");
      const before = JSON.stringify(t.data._ai.review_personalities || {});
      const merged = mergeReviewPersonalities(
        buildDefaultReviewPersonalities(keys, defs),
        t.data._ai.review_personalities || {},
        keys,
        defs
      );
      t.data._ai.review_personalities = merged;
      const after = JSON.stringify(merged);
      if(before !== after){
        t.modified = true;
        if(!t._dirtyFields) t._dirtyFields = {};
        t._dirtyFields["_ai.review_personalities"] = true;
      }
    }
  }

  function loadPrefs(){
    try{
      const raw = JSON.parse(localStorage.getItem("tb26_prefs") || "{}");
      const prefs = { ...DEFAULT_PREFS, ...(raw || {}) };
      if(typeof prefs.ai_model !== "string" || !/^gpt-/i.test(prefs.ai_model)){
        prefs.ai_model = DEFAULT_PREFS.ai_model;
      }
        prefs.ai_chat_permission = normalizeAiChatPermission(prefs.ai_chat_permission ?? DEFAULT_PREFS.ai_chat_permission);
        prefs.ai_maturity_clicks = normalizeMaturityClicks(prefs.ai_maturity_clicks ?? DEFAULT_PREFS.ai_maturity_clicks);
        prefs.ui_clicks = normalizeUiClicks(prefs.ui_clicks ?? DEFAULT_PREFS.ui_clicks);
        prefs.test_editor_lock = (prefs.test_editor_lock === "unlocked") ? "unlocked" : "locked";
        prefs.ai_personality_dialog = !!prefs.ai_personality_dialog;
        return prefs;
      }catch{
        return { ...DEFAULT_PREFS };
      }
    }

  function savePrefs(){
    localStorage.setItem("tb26_prefs", JSON.stringify(state.prefs));
  }

  function loadModelCache(){
    try{
      const raw = JSON.parse(localStorage.getItem("tb26_models") || "[]");
      return Array.isArray(raw) ? raw : [];
    }catch{
      return [];
    }
  }

  function saveModelCache(list){
    localStorage.setItem("tb26_models", JSON.stringify(list || []));
  }

  const AI_CHAT_PERMISSION_LEVELS = [
    { value: 0, label: "Search/Find", desc: "Read-only. No edits are applied." },
    { value: 1, label: "Revise/Edit", desc: "Update existing plan and test fields." },
    { value: 2, label: "Create/Delete", desc: "May add or remove items if supported." }
  ];

  function normalizeAiChatPermission(val){
    const num = Number(val);
    if(Number.isNaN(num)) return 1;
    return Math.min(2, Math.max(0, Math.round(num)));
  }

  function aiChatPermissionLabel(val){
    const lvl = normalizeAiChatPermission(val);
    return AI_CHAT_PERMISSION_LEVELS.find(l => l.value === lvl)?.label || "Revise/Edit";
  }

  const MAX_CHAT_CONTEXT_FILES = 5;
  const MAX_CHAT_CONTEXT_CHARS = 20000;

  function addAiChatContextFile(file, text){
    const name = file?.name || "context";
    const type = file?.type || "text/plain";
    let content = String(text || "");
    let truncated = false;
    if(content.length > MAX_CHAT_CONTEXT_CHARS){
      content = content.slice(0, MAX_CHAT_CONTEXT_CHARS);
      truncated = true;
    }
    state.aiChatContextFiles = (state.aiChatContextFiles || []).filter(f => f.name !== name);
    state.aiChatContextFiles.unshift({
      name,
      type,
      size: file?.size || content.length,
      truncated,
      text: content
    });
    state.aiChatContextFiles = state.aiChatContextFiles.slice(0, MAX_CHAT_CONTEXT_FILES);
  }

  function openAiChatFilePicker(){
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".md,.markdown,.json,text/markdown,application/json,text/plain";
    input.onchange = () => {
      const file = input.files?.[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const text = String(reader.result || "");
        addAiChatContextFile(file, text);
        appendChatMessage("ai", `Loaded context file: ${file.name}`);
        logLine(`AI Chat: loaded context file "${file.name}" (${text.length} chars).`, "ok");
      };
      reader.onerror = () => {
        toast("AI Chat", "Failed to read file.", "warn");
      };
      reader.readAsText(file);
    };
    input.click();
  }

  function normalizeMaturityClicks(val){
    const num = Number(val);
    return num === 2 ? 2 : 4;
  }

  function normalizeUiClicks(val){
    const num = Number(val);
    return num === 2 ? 2 : 4;
  }

  function isTestEditorUnlocked(){
    return (state.prefs?.test_editor_lock || "locked") === "unlocked";
  }

  function maturityDescription(level){
    const m = Number(level);
    return m === 0 ? "M0 — Unknown" :
           m === 1 ? "M1 — Placeholder" :
           m === 2 ? "M2 — AI-Assisted" :
           m === 3 ? "M3 — Human-Reviewed" :
           m === 4 ? "M4 — Locked" : "M0 — Unknown";
  }

  function mergeAiMeta(base, override){
    const out = structuredClone(base || {});
    const src = override || {};
    out.maturity = { ...(out.maturity || {}), ...(src.maturity || {}) };
    out.field_labels = { ...(out.field_labels || {}), ...(src.field_labels || {}) };
    out.field_prompts = { ...(out.field_prompts || {}), ...(src.field_prompts || {}) };
    out.field_types = { ...(out.field_types || {}), ...(src.field_types || {}) };
    if(src.review_personalities || out.review_personalities){
      out.review_personalities = mergeReviewPersonalities(
        out.review_personalities || {},
        src.review_personalities || {},
        Object.keys(TEST_SCHEMA_DEFAULT)
      );
    }
    if(src.last_ai_reviewed != null) out.last_ai_reviewed = src.last_ai_reviewed;
    if(src.last_ai_review_model != null) out.last_ai_review_model = src.last_ai_review_model;
    if(src.last_human_reviewed != null) out.last_human_reviewed = src.last_human_reviewed;
    if(src.notes != null) out.notes = src.notes;
    return out;
  }

  function nextTestNo(plan){
    const nums = (plan?.tests || [])
      .map(t => String(t?.data?.section_no || "").trim())
      .map(v => (v.match(/^(\d+)$/) ? Number(v) : NaN))
      .filter(n => Number.isFinite(n));
    const next = (nums.length ? Math.max(...nums) : 0) + 1;
    return String(next).padStart(3, "0");
  }

  function createTestFromSet(plan, set, testNo){
    const nextOrder = (plan.tests?.reduce((m,t)=>Math.max(m, t.order||0), 0) || 0) + 1;
    const data = { ...TEST_SCHEMA_DEFAULT, ...(set || {}) };
    if(testNo) data.section_no = testNo;
    const t = {
      id: uid(),
      order: nextOrder,
      modified: true,
      data: normalizeTestData(data)
    };
    const keys = Object.keys(set || {});
    for(const k of keys){
      if(k === "_ai") continue;
      if(set?._ai?.maturity && Object.prototype.hasOwnProperty.call(set._ai.maturity, k)) continue;
      setFieldMaturity(t, k, 2);
    }
    if(!t._dirtyFields) t._dirtyFields = {};
    for(const k of keys) t._dirtyFields[k] = true;
    plan.tests.push(t);
    return t;
  }

  function normalizeTestOrder(plan){
    if(!plan?.tests) return;
    plan.tests = plan.tests.slice().sort((a,b) => (a.order||0) - (b.order||0));
    plan.tests.forEach((t, i) => { t.order = i + 1; });
  }

  function parseMarkdownTableLines(lines){
    const rows = lines.filter(l => /\|/.test(l));
    if(rows.length < 2) return [];
    const headerCells = rows[0].split("|").map(s => s.trim()).filter(Boolean);
    const dataRows = rows.slice(2);
    const out = [];
    for(const row of dataRows){
      const cells = row.split("|").map(s => s.trim()).filter(Boolean);
      if(!cells.length) continue;
      const item = {};
      headerCells.forEach((h, i) => { item[h] = cells[i] ?? ""; });
      out.push(item);
    }
    return out;
  }

  function parseMarkdownTableHeader(lines){
    const rows = lines.filter(l => /\|/.test(l));
    if(rows.length < 2) return [];
    return rows[0].split("|").map(s => s.trim()).filter(Boolean);
  }

  function escapeRegex(text){
    return String(text || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function extractMarkdownSectionTable(md, heading){
    if(!md) return [];
    const re = new RegExp(`^#\\s+${escapeRegex(heading)}\\s*$`, "im");
    const match = md.match(re);
    if(!match) return [];
    const start = md.slice(match.index + match[0].length);
    const section = start.split(/\n# /)[0];
    const lines = section.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    return parseMarkdownTableLines(lines);
  }

  function extractMarkdownSectionMeta(md, headings){
    const list = Array.isArray(headings) ? headings : [headings];
    for(const heading of list){
      if(!heading) continue;
      const re = new RegExp(`^#\\s+${escapeRegex(heading)}\\s*$`, "im");
      const match = md.match(re);
      if(!match) continue;
      const start = md.slice(match.index + match[0].length);
      const section = start.split(/\n# /)[0];
      const lines = section.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const headers = parseMarkdownTableHeader(lines);
      const rows = parseMarkdownTableLines(lines);
      return { headers, rowCount: rows.length };
    }
    return { headers: [], rowCount: 0 };
  }

  function buildMatrixTemplateFromPartlist(headers, rowCount){
    const normKey = (s) => String(s || "").toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
    const cols = [];
    const colLabels = {};
    const colPrompts = {};
    for(const raw of (headers || [])){
      const id = normKey(raw);
      if(!id) continue;
      if(!cols.includes(id)) cols.push(id);
      if(!(id in colLabels)) colLabels[id] = raw;
      if(!(id in colPrompts)) colPrompts[id] = `Provide ${raw}.`;
    }
    const rows = [];
    const rowLabels = {};
    const count = Math.max(Number(rowCount) || 0, 0);
    for(let i = 1; i <= count; i++){
      const id = String(i).padStart(3, "0");
      rows.push(id);
      rowLabels[id] = id;
    }
    return {
      rows,
      cols,
      row_labels: rowLabels,
      col_labels: colLabels,
      col_prompts: colPrompts,
      cells: {}
    };
  }

  function extractSchematicMarkdownData(md){
    const netlist = extractMarkdownSectionTable(md, "Netlist");
    const partlist = extractMarkdownSectionTable(md, "Partlist");
    const partlistMeta = extractMarkdownSectionMeta(md, ["Partlist", "Partlist (Schematic)"]);
    const pinout = extractMarkdownSectionTable(md, "Pinout Description Table, P1");
    const circuitId = extractMarkdownSectionTable(md, "Circuit Identification");
    const testPoints = partlist.filter(p => /test point/i.test(p["PART TYPE"] || p["Part Type"] || p["PART"] || ""));
    return { netlist, partlist, partlistHeaders: partlistMeta.headers, partlistRowCount: partlistMeta.rowCount, pinout, circuitId, testPoints };
  }

    function sanitizeAiMeta(meta){
      if(!meta || typeof meta !== "object") return meta;
      const out = structuredClone(meta);
      if(out.maturity && typeof out.maturity === "object"){
        out.maturity = { ...out.maturity };
      }
      if(out.review_personalities && typeof out.review_personalities === "object"){
        for(const [id,p] of Object.entries(out.review_personalities)){
          if(!p || typeof p !== "object") continue;
          if(p.label != null) p.label = sanitizeAiText(p.label);
          if(p.last_reviewed != null) p.last_reviewed = sanitizeAiText(p.last_reviewed);
          if(p.model != null) p.model = sanitizeAiText(p.model);
          if(p.summary != null) p.summary = sanitizeAiText(p.summary);
          if(p.notes != null) p.notes = sanitizeAiText(p.notes);
          if(p.field_comments && typeof p.field_comments === "object"){
            for(const k of Object.keys(p.field_comments)){
              p.field_comments[k] = sanitizeAiText(p.field_comments[k]);
            }
          }
        }
      }
      if(out.field_labels && typeof out.field_labels === "object"){
        for(const k of Object.keys(out.field_labels)){
          out.field_labels[k] = sanitizeAiText(out.field_labels[k]);
        }
      }
    if(out.field_prompts && typeof out.field_prompts === "object"){
      for(const k of Object.keys(out.field_prompts)){
        out.field_prompts[k] = sanitizeAiText(out.field_prompts[k]);
      }
    }
    if(out.field_types && typeof out.field_types === "object"){
      for(const k of Object.keys(out.field_types)){
        out.field_types[k] = sanitizeAiText(out.field_types[k]);
      }
    }
    if(out.field_options && typeof out.field_options === "object"){
      for(const k of Object.keys(out.field_options)){
        const arr = Array.isArray(out.field_options[k]) ? out.field_options[k] : [];
        out.field_options[k] = arr.map(v => sanitizeAiText(v));
      }
    }
    if(out.last_ai_reviewed != null) out.last_ai_reviewed = sanitizeAiText(out.last_ai_reviewed);
    if(out.last_ai_review_model != null) out.last_ai_review_model = sanitizeAiText(out.last_ai_review_model);
    if(out.last_human_reviewed != null) out.last_human_reviewed = sanitizeAiText(out.last_human_reviewed);
    if(out.notes != null) out.notes = sanitizeAiText(out.notes);
    return out;
  }

  function sanitizeTestData(test){
    if(!test?.data) return;
    const data = test.data;
    for(const k of Object.keys(data)){
      if(k === "_ai") continue;
      if(typeof data[k] === "string" || typeof data[k] === "number" || typeof data[k] === "boolean"){
        data[k] = sanitizeAiText(data[k]);
      }
    }
    if(data._ai) data._ai = sanitizeAiMeta(data._ai);
  }

  async function sanitizePlanJson(planId){
    const plan = await Store.loadPlan(planId).catch(() => null);
    if(!plan) throw new Error("Plan not found");
      plan.name = sanitizeAiText(plan.name || "");
      plan.goal = sanitizeAiText(plan.goal || "");
      plan.scope = sanitizeAiText(plan.scope || "");
      if(plan.ai_review_guidance) plan.ai_review_guidance = sanitizeAiText(plan.ai_review_guidance);
      if(plan.userNotes) plan.userNotes = sanitizeAiText(plan.userNotes);
    for(const t of (plan.tests || [])){
      sanitizeTestData(t);
      t.modified = true;
    }
    plan.updated = nowIsoDate();
    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    return plan;
  }

  /* ---------- File System Root (optional) ---------- */
  const FS_DB = "tb26_fs";
  const FS_STORE = "handles";

  function idbOpen(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(FS_DB, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if(!db.objectStoreNames.contains(FS_STORE)) db.createObjectStore(FS_STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(FS_STORE, "readonly");
      const store = tx.objectStore(FS_STORE);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbSet(key, value){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(FS_STORE, "readwrite");
      const store = tx.objectStore(FS_STORE);
      const req = store.put(value, key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  async function loadPlanRoot(){
    try{
      const handle = await idbGet("planRoot");
      if(handle) state.planRootHandle = handle;
      const path = await idbGet("planRootPath");
      if(path) state.planRootPath = String(path);
    }catch{}
  }

  async function setPlanRoot(){
    if(!window.showDirectoryPicker){
      toast("Not supported", "This browser does not support folder access.", "warn");
      return;
    }
    try{
      const baseHandle = await window.showDirectoryPicker({ mode: "readwrite" });
      let rootHandle = baseHandle;
      if(baseHandle.name !== "test_base_2026"){
        rootHandle = await baseHandle.getDirectoryHandle("test_base_2026", { create: true });
      }
      state.planRootHandle = rootHandle;
      state.planRootPath = (baseHandle.name === "Repos" && rootHandle.name === "test_base_2026")
        ? "C:\\Repos\\test_base_2026"
        : rootHandle.name;
      await idbSet("planRoot", rootHandle);
      await idbSet("planRootPath", state.planRootPath);
      updatePlanRootUI();
      runAsync(renderLibrary());
      toast("Library folder set", state.planRootPath || "Library root selected.", "ok");
    }catch(e){
      toast("Canceled", "Library folder not set.", "warn");
    }
  }

  function updatePlanRootUI(){
    const text = $("planRootText");
    if(text){
      if(state.planRootHandle){
        text.textContent = state.planRootPath || state.planRootHandle.name || "Selected folder";
      }else{
        text.textContent = "Not set";
      }
    }
    const setBtn = $("btnSetPlanRoot");
    if(setBtn){
      if(!state.planRootHandle) setBtn.classList.add("attn");
      else setBtn.classList.remove("attn");
    }
    $("plansSub").textContent = "";
    const storageText = $("storageModeText");
    if(storageText){
      storageText.textContent = state.planRootHandle ? "File System" : "Browser Store";
    }
    const libSub = $("planLibrarySub");
    if(libSub){
      libSub.textContent = state.planRootHandle
        ? "Create, browse, and open test documents (saved to folders + JSON + markdown)."
        : "Create, browse, and open test documents (Browser Store skeleton).";
    }
  }

  function promptPlanRootIfNeeded(){
    if(state.planRootHandle) return;
    showModal("Select Document Library Root", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          Select the folder that will contain document folders (ideally the folder next to this HTML file).
          Each document will create its own folder containing test JSON files and a document markdown file.
        </div>
      `;
      footer.innerHTML = `
        <button class="btn" id="skipRoot">Not now</button>
        <button class="btn primary" id="setRootNow">Select Folder</button>
      `;
      $("skipRoot").onclick = hideModal;
      $("setRootNow").onclick = async () => { hideModal(); await setPlanRoot(); };
    });
  }

  /* ---------- Store (Browser + File System) ---------- */
  function useFileSystemStore(){
    return !!state.planRootHandle && !!window.showDirectoryPicker;
  }

  function templatesKey(){
    return "tb26_templates";
  }

  async function ensurePlanRootHandle(){
    if(!state.planRootHandle) return null;
    try{
      const perm = await state.planRootHandle.queryPermission({ mode: "readwrite" });
      if(perm === "granted") return state.planRootHandle;
      const req = await state.planRootHandle.requestPermission({ mode: "readwrite" });
      return req === "granted" ? state.planRootHandle : null;
    }catch{
      return null;
    }
  }

  async function ensurePlanRootHandleRead(){
    if(!state.planRootHandle) return null;
    try{
      const perm = await state.planRootHandle.queryPermission({ mode: "read" });
      if(perm === "granted") return state.planRootHandle;
      const req = await state.planRootHandle.requestPermission({ mode: "read" });
      return req === "granted" ? state.planRootHandle : null;
    }catch{
      return null;
    }
  }

  function safeFilePart(value, fallback){
    const base = (value || fallback || "item").toString().trim();
    const cleaned = base.replace(/[<>:"/\\|?*]+/g, " ").replace(/\s+/g, " ").trim();
    return cleaned || (fallback || "item");
  }

  function makePlanFolderName(plan){
    const slug = plan.slug || slugifyPlanName(plan.name || "plan");
    const shortId = (plan.id || uid()).replace(/[^a-zA-Z0-9]/g, "").slice(0, 8) || "plan";
    return safeFilePart(`${slug}_${shortId}`, "plan");
  }

  function makeTestFileName(test, used){
    const order = String(test.order ?? 0).padStart(3, "0");
    const tno = safeFilePart(test.data?.section_no || "", "test");
    let name = `test_${order}_${tno}.json`;
    if(used.has(name)){
      let i = 2;
      while(used.has(`test_${order}_${tno}_${i}.json`)) i++;
      name = `test_${order}_${tno}_${i}.json`;
    }
    used.add(name);
    return name;
  }

  async function fsWriteText(dirHandle, filename, text, type){
    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(new Blob([text], { type: type || "text/plain" }));
    await writable.close();
  }

  async function fsReadText(dirHandle, filename){
    try{
      const fileHandle = await dirHandle.getFileHandle(filename);
      const file = await fileHandle.getFile();
      return await file.text();
    }catch{
      return null;
    }
  }

  async function fsReadJson(dirHandle, filename){
    const text = await fsReadText(dirHandle, filename);
    if(!text) return null;
    try{ return JSON.parse(text); }catch{ return null; }
  }

  async function fsEnsureTemplatesRoot(create=true){
    const root = create ? await ensurePlanRootHandle() : await ensurePlanRootHandleRead();
    if(!root) return null;
    try{
      return await root.getDirectoryHandle("templates", { create: true });
    }catch{
      return null;
    }
  }

  async function fsListTestTemplates(plan){
    if(!plan) return [];
    const templatesDir = await fsEnsureTestTemplatesDir(plan, false);
    if(!templatesDir) return [];
    const list = [];
    for await (const [name, handle] of templatesDir.entries()){
      if(handle.kind !== "file" || !name.toLowerCase().endsWith(".json")) continue;
      const data = await fsReadJson(templatesDir, name);
      if(!data) continue;
      const testData = data.data || data;
      const title = (testData?.section_title || "").trim() || name.replace(/\.json$/i, "");
      list.push({ id: name, name: title, file: name, data: testData });
    }
    return list.sort((a,b) => a.name.localeCompare(b.name));
  }

  async function fsEnsureTestTemplatesDir(plan, create){
    if(!plan) return null;
    const root = await ensurePlanRootHandle();
    if(!root) return null;
    let entry = null;
    if(state.currentTemplateId){
      entry = await fsFindTemplateDirById(state.currentTemplateId);
      if(!entry && create){
        try{
          await fsSaveTemplate(plan);
        }catch{}
        entry = await fsFindTemplateDirById(state.currentTemplateId);
      }
    }else{
      entry = await fsFindPlanDirById(plan.id);
      if(!entry && create){
        try{
          await fsSavePlan(plan);
        }catch{}
        entry = await fsFindPlanDirById(plan.id);
      }
    }
    if(!entry) return null;
    let testsDir = null;
    try{
      testsDir = await entry.dir.getDirectoryHandle("tests", { create: !!create });
    }catch{
      return null;
    }
    try{
      return await testsDir.getDirectoryHandle("templates", { create: !!create });
    }catch{
      return null;
    }
  }

  function makeTestTemplateFileName(name){
    const safe = safeFilePart(name || "template", "template");
    return `${safe}.json`;
  }

  async function fsCopyDir(srcHandle, destHandle){
    for await (const [name, handle] of srcHandle.entries()){
      if(handle.kind === "file"){
        const file = await handle.getFile();
        const buf = await file.arrayBuffer();
        const fileHandle = await destHandle.getFileHandle(name, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(buf);
        await writable.close();
      }else if(handle.kind === "directory"){
        const sub = await destHandle.getDirectoryHandle(name, { create: true });
        await fsCopyDir(handle, sub);
      }
    }
  }

  async function fsEnsureUniquePlanFolder(root, baseName, planId){
    let name = baseName;
    let i = 2;
    while(true){
      try{
        const dir = await root.getDirectoryHandle(name);
        const meta = await fsReadJson(dir, "plan.json");
        if(meta && meta.id === planId) return name;
        name = `${baseName}_${i++}`;
      }catch{
        return name;
      }
    }
  }

  async function fsRenamePlanFolder(plan, desiredFolder){
    const root = await ensurePlanRootHandle();
    if(!root) throw new Error("Plan folder not set");
    const entry = await fsFindPlanDirById(plan.id);
    if(!entry) return null;
    const currentName = entry.name;
    const target = await fsEnsureUniquePlanFolder(root, desiredFolder, plan.id);
    if(currentName === target) return currentName;
    const targetDir = await root.getDirectoryHandle(target, { create: true });
    await fsCopyDir(entry.dir, targetDir);
    await root.removeEntry(currentName, { recursive: true });
    return target;
  }

  async function fsLoadPlanFromDir(dirHandle, folderName){
    const meta = await fsReadJson(dirHandle, "plan.json");
    if(!meta) return null;
    const md = await fsReadText(dirHandle, "plan.md");
    let tests = [];
    let testsDir = null;
    try{ testsDir = await dirHandle.getDirectoryHandle("tests"); }catch{}
    if(Array.isArray(meta.tests) && testsDir){
      for(const t of meta.tests){
        if(!t || !t.file) continue;
        const tjson = await fsReadJson(testsDir, t.file);
        if(!tjson) continue;
        tests.push({
          id: t.id || tjson.id || uid(),
          order: t.order ?? tjson.order ?? 0,
          modified: false,
          data: normalizeTestData(tjson.data || tjson)
        });
      }
    }else if(testsDir){
      for await (const [name, handle] of testsDir.entries()){
        if(handle.kind !== "file" || !name.toLowerCase().endsWith(".json")) continue;
        const tjson = await fsReadJson(testsDir, name);
        if(!tjson) continue;
        tests.push({
          id: tjson.id || uid(),
          order: tjson.order ?? 0,
          modified: false,
          data: normalizeTestData(tjson.data || tjson)
        });
      }
    }
    const plan = {
      id: meta.id || uid(),
      name: meta.name || folderName || "Plan",
      slug: meta.slug || slugifyPlanName(meta.name || folderName || "plan"),
      folder: meta.folder || folderName,
      created: meta.created || nowIsoDate(),
      updated: meta.updated || nowIsoDate(),
      tests,
      markdown: md || meta.markdown || "",
      userNotes: meta.userNotes ?? extractUserNotes(md || meta.markdown || ""),
      ai_prompts: meta.ai_prompts || {}
    };
    const mdMeta = extractPlanMetaFromMarkdown(plan.markdown || "");
    plan.name = meta.name || mdMeta.planName || plan.name;
    plan.goal = meta.goal ?? mdMeta.goal ?? "";
    plan.scope = meta.scope ?? mdMeta.scope ?? "";
    plan.ai_review_guidance = meta.ai_review_guidance ?? mdMeta.aiReviewGuidance ?? "";
    if(!plan.markdown) generatePlanMarkdown(plan);
    return plan;
  }

  async function fsListPlans(){
    const root = await ensurePlanRootHandle();
    if(!root) return [];
    const plans = [];
    for await (const [name, handle] of root.entries()){
      if(handle.kind !== "directory") continue;
      const p = await fsLoadPlanFromDir(handle, name);
      if(p) plans.push(p);
    }
    return plans.sort((a,b) => (b.updated||"").localeCompare(a.updated||""));
  }

  async function fsFindPlanDirById(id){
    const root = await ensurePlanRootHandle();
    if(!root) return null;
    for await (const [name, handle] of root.entries()){
      if(handle.kind !== "directory") continue;
      const meta = await fsReadJson(handle, "plan.json");
      if(meta && meta.id === id){
        return { dir: handle, meta, name };
      }
    }
    return null;
  }

  async function fsLoadPlan(id){
    const entry = await fsFindPlanDirById(id);
    if(!entry) throw new Error("Plan not found");
    const plan = await fsLoadPlanFromDir(entry.dir, entry.name);
    if(!plan) throw new Error("Plan not found");
    return plan;
  }

  async function fsSavePlanToRoot(root, plan){
    if(!root) throw new Error("Plan folder not set");
    plan.slug = plan.slug || slugifyPlanName(plan.name || "plan");
    if(!plan.folder) plan.folder = makePlanFolderName(plan);
    const planDir = await root.getDirectoryHandle(plan.folder, { create: true });
    const testsDir = await planDir.getDirectoryHandle("tests", { create: true });
    const used = new Set();
    const existing = new Set();
    for await (const [name, handle] of testsDir.entries()){
      if(handle.kind === "file" && name.toLowerCase().endsWith(".json")){
        existing.add(name);
      }
    }
    const testsMeta = [];
    for(const t of (plan.tests || [])){
      const file = makeTestFileName(t, used);
      const payload = {
        id: t.id || uid(),
        order: t.order ?? 0,
        data: normalizeTestData(t.data || {})
      };
      await fsWriteText(testsDir, file, JSON.stringify(payload, null, 2), "application/json");
      testsMeta.push({
        id: payload.id,
        order: payload.order,
        file,
        section_no: payload.data.section_no || "",
        section_title: payload.data.section_title || ""
      });
    }
    for(const name of existing){
      if(!used.has(name)){
        try{ await testsDir.removeEntry(name); }catch{}
      }
    }
    if(!plan.markdown) generatePlanMarkdown(plan);
    await fsWriteText(planDir, "plan.md", plan.markdown || "", "text/markdown");
      const meta = {
        id: plan.id,
        name: plan.name,
        slug: plan.slug,
        folder: plan.folder,
        created: plan.created || nowIsoDate(),
        updated: plan.updated || nowIsoDate(),
        goal: plan.goal || "",
        scope: plan.scope || "",
        ai_review_guidance: plan.ai_review_guidance || "",
        ai_prompts: plan.ai_prompts || {},
        userNotes: plan.userNotes || extractUserNotes(plan.markdown || ""),
        markdownFile: "plan.md",
        tests: testsMeta
      };
    await fsWriteText(planDir, "plan.json", JSON.stringify(meta, null, 2), "application/json");
    return plan;
  }

  async function fsSavePlan(plan){
    const root = await ensurePlanRootHandle();
    return await fsSavePlanToRoot(root, plan);
  }

  async function fsListTemplates(){
    const root = await fsEnsureTemplatesRoot(false);
    if(!root){
      logLine("Templates: root not accessible (no read permission).", "warn");
      return [];
    }
    const templates = [];
    for await (const [name, handle] of root.entries()){
      if(handle.kind !== "directory") continue;
      const p = await fsLoadPlanFromDir(handle, name);
      if(p) templates.push(p);
    }
    if(!templates.length){
      logLine(`Templates: found 0 folder(s) under /templates.`, "warn");
    }else if(state.prefs.ai_review_debug){
      logLine(`Templates: found ${templates.length} folder(s) under /templates.`, "ok");
    }
    return templates.sort((a,b) => (b.updated||"").localeCompare(a.updated||""));
  }

  async function fsFindTemplateDirById(id){
    const root = await fsEnsureTemplatesRoot(false);
    if(!root) return null;
    for await (const [name, handle] of root.entries()){
      if(handle.kind !== "directory") continue;
      const meta = await fsReadJson(handle, "plan.json");
      if(meta && meta.id === id){
        return { dir: handle, meta, name, root };
      }
    }
    return null;
  }

  async function fsLoadTemplate(id){
    const entry = await fsFindTemplateDirById(id);
    if(!entry) throw new Error("Template not found");
    const plan = await fsLoadPlanFromDir(entry.dir, entry.name);
    if(!plan) throw new Error("Template not found");
    return plan;
  }

  async function fsSaveTemplate(plan){
    const root = await fsEnsureTemplatesRoot();
    return await fsSavePlanToRoot(root, plan);
  }

  async function fsDeleteTemplate(id){
    const entry = await fsFindTemplateDirById(id);
    if(!entry) return;
    await entry.root.removeEntry(entry.name, { recursive: true });
  }

  async function fsDeletePlan(id){
    const root = await ensurePlanRootHandle();
    if(!root) throw new Error("Plan folder not set");
    const entry = await fsFindPlanDirById(id);
    if(!entry) return;
    await root.removeEntry(entry.name, { recursive: true });
  }

  const Store = {
    key: "tb26_plans",
    async listPlans(){
      if(useFileSystemStore()) return await fsListPlans();
      return loadPlans().sort((a,b) => (b.updated||"").localeCompare(a.updated||""));
    },
    async loadPlan(id){
      if(useFileSystemStore()) return await fsLoadPlan(id);
      const all = loadPlans();
      const p = all.find(x => x.id === id);
      if(!p) throw new Error("Plan not found");
      return structuredClone(p);
    },
    async savePlan(plan){
      if(useFileSystemStore()){
        try{
          await fsSavePlan(plan);
          return;
        }catch(e){
          logLine(`Save failed (FS). Falling back to browser store. ${e.message || e}`, "warn");
        }
      }
      const all = loadPlans();
      const idx = all.findIndex(x => x.id === plan.id);
      if(idx >= 0) all[idx] = structuredClone(plan);
      else all.push(structuredClone(plan));
      localStorage.setItem(this.key, JSON.stringify(all));
    },
    async deletePlan(id){
      if(useFileSystemStore()){
        try{
          await fsDeletePlan(id);
          return;
        }catch(e){
          logLine(`Delete failed (FS). ${e.message || e}`, "warn");
        }
      }
      const all = loadPlans().filter(x => x.id !== id);
      localStorage.setItem(this.key, JSON.stringify(all));
    }
  };

  const Templates = {
    async listTemplates(){
      if(useFileSystemStore()){
        return await fsListTemplates();
      }
      const browserList = loadTemplates().sort((a,b) => (b.updated||"").localeCompare(a.updated||""));
      if(!state.planRootHandle) return browserList;
      const fsList = await fsListTemplates().catch(() => []);
      if(!fsList.length) return browserList;
      const byId = new Map(browserList.map(p => [p.id, p]));
      for(const p of fsList){
        if(!byId.has(p.id)) byId.set(p.id, p);
      }
      return Array.from(byId.values()).sort((a,b) => (b.updated||"").localeCompare(a.updated||""));
    },
    async loadTemplate(id){
      if(useFileSystemStore()) return await fsLoadTemplate(id);
      const all = loadTemplates();
      const t = all.find(x => x.id === id);
      if(!t) throw new Error("Template not found");
      return structuredClone(t);
    },
    async saveTemplate(plan){
      if(useFileSystemStore()){
        try{
          await fsSaveTemplate(plan);
          return;
        }catch(e){
          logLine(`Save template failed (FS). Falling back to browser store. ${e.message || e}`, "warn");
        }
      }
      const all = loadTemplates();
      const idx = all.findIndex(x => x.id === plan.id);
      if(idx >= 0) all[idx] = structuredClone(plan);
      else all.push(structuredClone(plan));
      localStorage.setItem(templatesKey(), JSON.stringify(all));
    },
    async deleteTemplate(id){
      if(useFileSystemStore()){
        try{
          await fsDeleteTemplate(id);
          return;
        }catch(e){
          logLine(`Delete template failed (FS). ${e.message || e}`, "warn");
        }
      }
      const all = loadTemplates().filter(x => x.id !== id);
      localStorage.setItem(templatesKey(), JSON.stringify(all));
    }
  };

  function loadPlans(){
    try{ return JSON.parse(localStorage.getItem(Store.key) || "[]") || []; }
    catch{ return []; }
  }

  function loadTemplates(){
    try{ return JSON.parse(localStorage.getItem(templatesKey()) || "[]") || []; }
    catch{ return []; }
  }

  /* ---------- Markdown generation (skeleton) ---------- */
  function extractUserNotes(md){
    const s = md || "";
    const i = s.indexOf(MARKERS.start);
    const j = s.indexOf(MARKERS.end);
    if(i >= 0 && j > i){
      return s
        .slice(i + MARKERS.start.length, j)
        .replace(/^\s*\r?\n/, "")
        .replace(/\r?\n\s*$/, "");
    }
    const m = s.match(/## Notes\s*[\r\n]+([\s\S]*?)(?:\r?\n## |\s*$)/i);
    if(m && m[1] != null){
      return m[1].replace(/^\s*\r?\n/, "").replace(/\r?\n\s*$/, "");
    }
    return "Add plan-level notes here (equipment, safety, lab setup, etc.).";
  }

  function extractPlanMetaFromMarkdown(md){
    const s = md || "";
    let planName = "";
    let goal = "";
    let scope = "";
    let aiReviewGuidance = "";
    for(const rawLine of s.split(/\r?\n/)){
      const line = rawLine.trim();
      if(line.toLowerCase().startsWith("- **name:**") || line.toLowerCase().startsWith("- **plan name:**")){
        planName = line.slice(line.toLowerCase().startsWith("- **name:**") ? "- **Name:**".length : "- **Plan Name:**".length).trim();
      }
      if(line.toLowerCase().startsWith("- **goal:**") || line.toLowerCase().startsWith("- **plan goal:**")){
        goal = line.slice(line.toLowerCase().startsWith("- **goal:**") ? "- **Goal:**".length : "- **Plan Goal:**".length).trim();
      }
      if(line.toLowerCase().startsWith("- **scope:**") || line.toLowerCase().startsWith("- **plan scope:**")){
        scope = line.slice(line.toLowerCase().startsWith("- **scope:**") ? "- **Scope:**".length : "- **Plan Scope:**".length).trim();
      }
      if(line.toLowerCase().startsWith("- **ai review guidance:**")){
        aiReviewGuidance = line.slice("- **AI Review Guidance:**".length).trim();
      }
    }
    return { planName, goal, scope, aiReviewGuidance };
  }

  function generatePlanMarkdown(plan){
    const tests = (plan.tests || []).slice().sort((a,b) => (a.order||0) - (b.order||0));
    const created = plan.created || nowIsoDate();
    const updated = nowIsoDate();
    const name = String(plan.name || "");
    const nameLower = name.toLowerCase();
    const docKind = nameLower.includes("electronics test plan") ? "test"
      : nameLower.includes("specifications document") ? "spec"
      : nameLower.includes("requirements traceability matrix") ? "rtm"
      : nameLower.includes("bill of materials") ? "bom"
      : nameLower.includes("verification matrix") ? "verification"
      : nameLower.includes("design review checklist") ? "designReview"
      : nameLower.includes("interface control document") ? "icd"
      : nameLower.includes("fmea") ? "fmea"
      : nameLower.includes("emc/emi compliance plan") ? "emc"
      : "document";
    const titlePrefix = docKind === "test" ? "Test Plan"
      : docKind === "spec" ? "Specifications Document"
      : docKind === "rtm" ? "Requirements Traceability Matrix"
      : docKind === "bom" ? "Bill of Materials"
      : docKind === "verification" ? "Verification Matrix"
      : docKind === "designReview" ? "Design Review Checklist"
      : docKind === "icd" ? "Interface Control Document"
      : docKind === "fmea" ? "FMEA"
      : docKind === "emc" ? "EMC/EMI Compliance Plan"
      : "Document";
    const listLabel = docKind === "test" ? "List" : "Sections";
    const totalLabel = docKind === "test" ? "Total Tests" : "Total Sections";
    const listHeaders = docKind === "test"
      ? "| Order | section_no | section_title | section_type |"
      : "| Order | section_id | section_title | section_type |";

    const md =
`# ${titlePrefix}: ${plan.name}

## Metadata
- **Name:** ${plan.name}
- **Goal:** ${plan.goal || ""}
- **Scope:** ${plan.scope || ""}
- **AI Review Guidance:** ${plan.ai_review_guidance || ""}
- **Created:** ${created}
- **Last Updated:** ${updated}
- **${totalLabel}:** ${tests.length}

## ${listLabel}
${listHeaders}
|------:|--------:|-----------|-----------|
${tests.map((t, idx) => {
  const d = t.data || {};
  const esc = (x) => String(x ?? "").replace(/\|/g, "\\|");
  return `| ${idx+1} | ${esc(d.section_no)} | ${esc(d.section_title)} | ${esc(d.section_type)} |`;
}).join("\n")}

## Notes
${plan.userNotes || "Add plan-level notes here (equipment, safety, lab setup, etc.)."}
`;
    plan.created = created;
    plan.updated = updated;
    plan.markdown = md;
    plan.userNotes = extractUserNotes(md);
    return md;
  }

  /* ---------- State ---------- */
  const state = {
    prefs: loadPrefs(),
    plansCache: [],
    templatesCache: [],
    currentPlan: null,
    currentTemplateId: null,
    currentTestTemplate: null,
    currentTestId: null,
    focusField: null,
    aiSuggestStatus: {},
    planRootHandle: null,
    templateListCache: [],
    templateEditReturnPlanId: null,
    flow: { x: 0, y: 0, scale: 1 },
    modelList: [],
    aiChatContextFiles: [],
    matrixPanKey: false,
    matrixExpanded: false,
    aiReviewControl: { running: false, paused: false, cancelled: false }
  };

  /* ---------- UI primitives ---------- */
  function toast(title, msg, kind=""){
    $("toastTitle").textContent = title;
    $("toastMsg").textContent = msg;
    const t = $("toast");
    t.classList.add("show");
    if(kind){
      t.style.borderColor = kind === "bad" ? "rgba(255,124,124,.35)" :
                           kind === "warn" ? "rgba(255,211,124,.35)" :
                           kind === "ok" ? "rgba(124,255,176,.30)" : "var(--border)";
    } else {
      t.style.borderColor = "var(--border)";
    }
    clearTimeout(state._toastTimer);
    state._toastTimer = setTimeout(() => t.classList.remove("show"), 2800);
  }

  function hideContextMenu(){
    const menu = $("contextMenu");
    if(menu) menu.style.display = "none";
  }

  function showContextMenu(x, y, items){
    const menu = $("contextMenu");
    if(!menu) return;
    menu.innerHTML = (items || []).map(it =>
      `<button type="button" data-action="${escapeHtml(it.id)}">${escapeHtml(it.label)}</button>`
    ).join("");
    menu.style.display = "block";
    const pad = 8;
    const rect = menu.getBoundingClientRect();
    const maxX = window.innerWidth - rect.width - pad;
    const maxY = window.innerHeight - rect.height - pad;
    menu.style.left = `${Math.max(pad, Math.min(x, maxX))}px`;
    menu.style.top = `${Math.max(pad, Math.min(y, maxY))}px`;
    menu.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-action");
        const action = (items || []).find(it => it.id === id);
        hideContextMenu();
        if(action && typeof action.onClick === "function") action.onClick();
      });
    });
  }

  function logLine(msg, level="info"){
    const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    const div = document.createElement("div");
    div.className = "line";
    const cls = level === "ok" ? "ok" : level === "warn" ? "warn" : level === "bad" ? "bad" : "";
    div.innerHTML = `<span class="time">[${time}]</span> <span class="${cls}">${escapeHtml(msg)}</span>`;
    $("log").appendChild(div);
    $("log").scrollTop = $("log").scrollHeight;
  }

  function updateAiReviewControls(){
    const pauseBtn = $("btnAiReviewPause");
    const cancelBtn = $("btnAiReviewCancel");
    if(!pauseBtn || !cancelBtn) return;
    const ctrl = state.aiReviewControl || { running:false, paused:false, cancelled:false };
    pauseBtn.disabled = !ctrl.running || ctrl.cancelled;
    cancelBtn.disabled = !ctrl.running || ctrl.cancelled;
    pauseBtn.textContent = ctrl.paused ? "Resume" : "Pause";
  }

  async function aiReviewWaitIfPaused(){
    while(state.aiReviewControl?.paused){
      if(state.aiReviewControl?.cancelled) return false;
      await sleep(200);
    }
    return !state.aiReviewControl?.cancelled;
  }

  function runAsync(promise){
    Promise.resolve(promise).catch(err => {
      logLine(`Error: ${err.message || err}`, "bad");
      toast("Error", err.message || String(err), "bad");
    });
  }

  function showModal(title, renderFn){
    $("modalTitle").textContent = title;
    $("modalBody").innerHTML = "";
    $("modalFooter").innerHTML = "";
    $("modalOverlay").classList.add("show");
    renderFn($("modalBody"), $("modalFooter"));
  }
  function hideModal(){
    $("modalOverlay").classList.remove("show");
    $("modal").classList.remove("wide");
  }

  function showModalWide(title, renderFn){
    $("modal").classList.add("wide");
    showModal(title, renderFn);
  }

  function safeParseJson(raw, contextLabel){
    const label = contextLabel || "JSON";
    let text = String(raw || "").trim();
    if(!text) return {};
    text = text.replace(/```(?:json)?/gi, "").replace(/```/g, "").trim();
    const first = text.indexOf("{");
    const last = text.lastIndexOf("}");
    if(first >= 0 && last > first) text = text.slice(first, last + 1);
    try{ return JSON.parse(text); }
    catch(e){
      try{
        const fixed = text
          .replace(/\\(?![\\\"\/bfnrt]|u[0-9a-fA-F]{4})/g, "\\\\")
          .replace(/[\u0000-\u0019]/g, (c) => {
            if(c === "\n") return "\\n";
            if(c === "\r") return "\\r";
            if(c === "\t") return "\\t";
            return "";
          });
        return JSON.parse(fixed);
      }catch(e2){
        const fallback = parseLooseJsonPairs(text);
        try{ Object.defineProperty(fallback, "__fromFallback", { value: true, enumerable: false }); }catch(_){}
        logLine(`${label} parse failed: ${e.message || e}. Fallback pairs: ${Object.keys(fallback).length}`, "warn");
        return fallback;
      }
    }
  }

  function repairJsonText(text){
    let fixed = String(text || "");
    fixed = fixed.replace(/```(?:json)?/gi, "").replace(/```/g, "");
    fixed = fixed.replace(/^\uFEFF/, "");
    fixed = fixed.replace(/[\u200B-\u200D\uFEFF]/g, "");
    fixed = fixed.replace(/[“”]/g, "\"").replace(/[‘’]/g, "'");
    const start = fixed.search(/[\{\[]/);
    if(start >= 0) fixed = fixed.slice(start);
    const end = Math.max(fixed.lastIndexOf("}"), fixed.lastIndexOf("]"));
    if(end >= 0) fixed = fixed.slice(0, end + 1);
    const dq = (fixed.match(/"/g) || []).length;
    const sq = (fixed.match(/'/g) || []).length;
    if(dq === 0 && sq > 0){
      fixed = fixed.replace(/'/g, "\"");
    }
    fixed = escapeNewlinesInStrings(fixed);
    fixed = fixed.replace(/,\s*([}\]])/g, "$1");
    return fixed.trim();
  }

  function escapeNewlinesInStrings(text){
    let out = "";
    let inStr = false;
    let esc = false;
    for(let i = 0; i < text.length; i++){
      const ch = text[i];
      if(inStr){
        if(esc){
          esc = false;
          out += ch;
          continue;
        }
        if(ch === "\\"){
          esc = true;
          out += ch;
          continue;
        }
        if(ch === "\n"){ out += "\\n"; continue; }
        if(ch === "\r"){ out += "\\r"; continue; }
        out += ch;
        continue;
      }
      if(ch === "\""){
        inStr = true;
        out += ch;
        continue;
      }
      out += ch;
    }
    return out;
  }

  function parseLooseJsonPairs(text){
    const out = {};
    const re = /"([^"\\]+)"\s*:\s*"((?:\\.|[^"\\])*)"/g;
    let m;
    while((m = re.exec(text))){
      const key = m[1];
      let val = m[2];
      val = val.replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "\t").replace(/\\"/g, "\"");
      out[key] = val;
    }
    return out;
  }

  function getReviewStatus(testId){
    return state.aiReviewStatus?.[testId] || "";
  }

  function setReviewStatus(testId, status){
    if(!state.aiReviewStatus) state.aiReviewStatus = {};
    if(status) state.aiReviewStatus[testId] = status;
    else delete state.aiReviewStatus[testId];
  }

  function getFieldKeys(test){
    const keys = Object.keys(test?.data || {}).filter(k => k !== "_ai");
    return keys.length ? keys : Object.keys(TEST_SCHEMA_DEFAULT);
  }

  function fieldsForAiReview(test, anchors){
    const keys = getFieldKeys(test);
    const out = [];
    for(const k of keys){
      if(["param1_label","param1_value","param2_label","param2_value"].includes(k)) continue;
      if(k === "_ai") continue;
      const m = getFieldMaturity(test, k);
      if(m > 2) continue;
      const v = (test.data[k] ?? "");
      if(["ll","tv","ul","units"].includes(k) && String(v).trim().toUpperCase() === "N/A") continue;
      out.push(k);
    }
    return out;
  }

  function buildMatrixReviewQueue(test, field){
    const { matrix } = ensureMatrixField(test, field);
    const queue = [];
    for(const rowId of matrix.rows || []){
      for(const colId of matrix.cols || []){
        queue.push({
          field,
          cellKey: matrixCellKey(rowId, colId),
          rowId,
          colId
        });
      }
    }
    return queue;
  }

  function buildAiReviewQueue(test, anchors){
    const fields = fieldsForAiReview(test, anchors);
    const queue = [];
    for(const field of fields){
      const fieldType = String(test.data?._ai?.field_types?.[field] || "text").toLowerCase();
      if(fieldType.includes("matrix")){
        queue.push(...buildMatrixReviewQueue(test, field));
      }else{
        queue.push({ field });
      }
    }
    return queue;
  }

  function setMatrixCellStatus(test, fieldKey, cellKey, status){
    if(!test || !fieldKey || !cellKey) return;
    if(!test._matrixCellStatus) test._matrixCellStatus = {};
    if(!test._matrixCellStatus[fieldKey]) test._matrixCellStatus[fieldKey] = {};
    if(status) test._matrixCellStatus[fieldKey][cellKey] = status;
    else delete test._matrixCellStatus[fieldKey][cellKey];
    const selector = `.matrixInput[data-matrix-field="${cssEscape(fieldKey)}"][data-matrix-cell="${cssEscape(cellKey)}"]`;
    const input = document.querySelector(selector);
    if(!input) return;
    input.classList.remove("ai-pending","ai-working","ai-accepted");
    if(status) input.classList.add(`ai-${status}`);
  }

  function fieldsForPersonalityReview(test){
    const keys = getFieldKeys(test);
    return keys.filter(k => !["_ai","param1_label","param1_value","param2_label","param2_value"].includes(k));
  }

  function setPersonalityComment(test, field, personaId, comment, model){
    if(!test || !field || !personaId) return;
    if(!test.data._ai) test.data._ai = ensureAiMeta(null, Object.keys(test.data).filter(k => k !== "_ai"));
          if(!test.data._ai.review_personalities || typeof test.data._ai.review_personalities !== "object"){
            test.data._ai.review_personalities = buildDefaultReviewPersonalities(Object.keys(test.data).filter(k => k !== "_ai"), getPlanReviewPersonas(state.currentPlan));
          }
    const persona = test.data._ai.review_personalities[personaId];
    if(!persona) return;
    if(!persona.field_comments || typeof persona.field_comments !== "object") persona.field_comments = {};
    persona.field_comments[field] = comment;
    persona.last_reviewed = nowIsoTimestamp();
    persona.model = model || "";
    test.modified = true;
    if(!test._dirtyFields) test._dirtyFields = {};
    test._dirtyFields[`_ai.review_personalities.${personaId}.field_comments.${field}`] = true;
  }

  async function aiReviewPlan(planId){
    const key = getAiKey();
    if(!USE_PROXY && !key){
      toast("AI Review", "Set an API key first.", "warn");
      logLine("AI Review: no API key available.", "warn");
      return;
    }
    state.aiReviewControl = { running: true, paused: false, cancelled: false };
    updateAiReviewControls();
    let plan = null;
    try{
      plan = await Store.loadPlan(planId);
    }catch(e){
      toast("AI Review", e.message || "Document not found.", "bad");
      state.aiReviewControl.running = false;
      updateAiReviewControls();
      return;
    }
    if(!plan.goal || !plan.scope || !plan.ai_review_guidance){
      const mdMeta = extractPlanMetaFromMarkdown(plan.markdown || "");
      if(!plan.goal) plan.goal = mdMeta.goal || "";
      if(!plan.scope) plan.scope = mdMeta.scope || "";
      if(!plan.ai_review_guidance) plan.ai_review_guidance = mdMeta.aiReviewGuidance || "";
    }
    if(!plan.review_personalities || typeof plan.review_personalities !== "object"){
      plan.review_personalities = getPlanReviewPersonas(plan);
    }
    syncPlanReviewPersonalities(plan);

    const tests = (plan.tests || []).slice().sort((a,b) => (a.order||0)-(b.order||0));
    if(!tests.length){
      toast("AI Review", "No list items to review.", "warn");
      state.aiReviewControl.running = false;
      updateAiReviewControls();
      return;
    }

    // Open plan in editor and visualize progress inline
    state.currentPlan = plan;
    state.currentTestId = tests[0]?.id || null;
    showEditor();

    const model = state.prefs.ai_model || "gpt-4.1-mini";
    const guidance = await getAiReviewGuidance();
    const guidanceLine = guidance ? ` Style/Tone/Vibe: ${guidance}` : "";
    const personaDefs = getPlanReviewPersonas(plan);
    const enablePersonalityReview = false;
    logLine(`AI Review: using model "${model}".`, "ok");

    async function reviewFieldComments(test, field){
      if(!test?.data) return;
      if(!test.data._ai) test.data._ai = ensureAiMeta(null, Object.keys(test.data).filter(k => k !== "_ai"));
      if(!test.data._ai.review_personalities || typeof test.data._ai.review_personalities !== "object"){
        test.data._ai.review_personalities = buildDefaultReviewPersonalities(Object.keys(test.data).filter(k => k !== "_ai"), getPlanReviewPersonas(plan));
      }
      const personas = Object.entries(test.data._ai.review_personalities);
      const payloadBase = {
        plan: { name: plan.name, created: plan.created, updated: plan.updated },
        section_no: test.data.section_no || "",
        section_title: test.data.section_title || "",
        field,
        current_value: test.data[field] ?? "",
        field_prompt: test.data?._ai?.field_prompts?.[field] || "",
        field_label: test.data?._ai?.field_labels?.[field] || field,
        maturity: getFieldMaturity(test, field),
        context: test.data
      };
      const tasks = [];
      for(const [personaId, persona] of personas){
        tasks.push({ personaId, persona });
      }
      if(!tasks.length) return;
      const concurrency = Math.max(1, Number(state.prefs.ai_review_concurrency ?? 1));
      let active = 0;
      let index = 0;
      await new Promise(resolve => {
        const launchNext = () => {
          if(state.aiReviewControl?.cancelled && active === 0) return resolve();
          if(state.aiReviewControl?.cancelled) return;
          if(index >= tasks.length && active === 0) return resolve();
          while(active < concurrency && index < tasks.length){
            const { personaId, persona } = tasks[index++];
            active++;
            const focus = personaDefs?.[personaId]?.focus || DEFAULT_REVIEW_PERSONALITY_FOCUS[personaId] || "clarity and usefulness";
            const personaGuidance = personaDefs?.[personaId]?.guidance
              ? ` Persona guidance: ${personaDefs[personaId].guidance}`
              : "";
            const prompt = {
              ...payloadBase,
              persona: { id: personaId, label: persona?.label || personaId, focus }
            };
            (async () => {
              try{
                if(!(await aiReviewWaitIfPaused())) return;
                logLine(`AI Review: persona ${persona?.label || personaId} reviewing ${test.data.section_no || test.id.slice(0,6)}.${field}...`, "ok");
                const resp = await fetch(apiUrl("/review"), {
                  method: "POST",
                  headers: apiHeaders(),
                  body: JSON.stringify({
                    model,
                    input: [
                    { role:"system", content:getAiPrompt(plan, "review_persona", { personaLabel: persona?.label || personaId, focus, guidanceLine: `${guidanceLine}${personaGuidance}` }) },
                      { role:"user", content: JSON.stringify(prompt, null, 2) }
                    ],
                    max_output_tokens: 120
                  })
                });
                if(!resp.ok){
                  const ttxt = await resp.text().catch(()=> "");
                  throw new Error(`HTTP ${resp.status}: ${ttxt.slice(0,160)}`);
                }
                const data = await resp.json();
                let val = String(extractResponseText(data) || "").trim();
                if((val.startsWith("\"") && val.endsWith("\"")) || (val.startsWith("'") && val.endsWith("'"))){
                  val = val.slice(1, -1).trim();
                }
                val = sanitizeAiText(val);
                if(isMatrixCell){
                  const colLabel = String(matrixContext?.col_label || "").trim();
                  const rowLabel = String(matrixContext?.row_label || "").trim();
                  const lowered = val.toLowerCase();
                  const maxLen = (item.colId === "requirement" || item.colId === "notes") ? 300 : 120;
                  const tooLong = val.length > maxLen;
                  const looksInstruction = /(?:\bshould\b|\benter\b|\bpopulate\b|\bfill\b|\buse\b|\binclude\b|\bprovide\b|\bset\b|\bcomplete\b)/i.test(val);
                  const looksSentence = /[.!?]/.test(val);
                  const allowSentences = item.colId === "requirement" || item.colId === "notes";
                  const startsWithBad = /^(value|tbd|to be completed|to be filled|complete per|per drawing|per schematic)/i.test(val);
                  const bad = !val
                    || /^value/i.test(val)
                    || /^n\/a$/i.test(val)
                    || (colLabel && val === colLabel)
                    || (rowLabel && val === rowLabel)
                    || startsWithBad
                    || (!allowSentences && looksInstruction && looksSentence)
                    || tooLong;
                  if(bad){
                    logLine(`AI Review: matrix cell rejected "${val}" for ${t.data.section_no || t.id.slice(0,6)}.${field} ${item.cellKey}.`, "warn");
                    setMatrixCellStatus(t, field, item.cellKey, "");
                    setSuggestStatus(t.id, field, "");
                    return;
                  }
                }
                if(!state.aiReviewControl?.cancelled && val){
                  setPersonalityComment(test, field, personaId, val, model);
                }
              }catch(err){
                logLine(`AI Review: comment failed ${test.data.section_no || test.id.slice(0,6)}.${field}.${personaId} (${err.message || err}).`, "warn");
              }finally{
                active--;
                const pauseMsLocal = Number(state.prefs.ai_review_pause_ms ?? 0);
                if(pauseMsLocal > 0) await sleep(pauseMsLocal);
                launchNext();
              }
            })();
          }
        };
        launchNext();
      });
    }

    const anchors = {};
    function considerAnchor(field, value, maturity, testNo){
      if(!value) return;
      const val = String(value).trim();
      if(!val) return;
      const cur = anchors[field];
      if(maturity === 3){
        anchors[field] = { value: val, maturity: 3, section_no: testNo };
        return;
      }
      if(!cur){
        anchors[field] = { value: val, maturity: maturity, section_no: testNo };
        return;
      }
      if(cur.maturity === 3) return;
      // if only M4 values exist, take latest
      if(maturity >= cur.maturity){
        anchors[field] = { value: val, maturity: maturity, section_no: testNo };
      }
    }

    function buildAnchorsFromTest(test){
      const keys = getFieldKeys(test);
      for(const k of keys){
        if(k === "_ai") continue;
        const m = getFieldMaturity(test, k);
        if(m >= 3){
          considerAnchor(k, test.data[k], m, test.data.section_no || "");
        }
      }
    }

    // Deterministic UUT P/N: lock to first test's value for all later tests
    const firstUutPn = String(tests[0]?.data?.uut_pn ?? "").trim();
    if(firstUutPn) anchors.uut_pn = { value: firstUutPn, maturity: 3, section_no: tests[0]?.data?.section_no || "" };

    // Pre-mark tests with pending review status
    for(const t of tests){
      setReviewStatus(t.id, "pending");
    }
    renderTestsList();

      let cancelled = false;
      for(const t of tests){
        if(!(await aiReviewWaitIfPaused())){ cancelled = true; break; }
        state.currentTestId = t.id;
        setReviewStatus(t.id, "working");
        if(!t.data._ai) t.data._ai = ensureAiMeta(null, Object.keys(t.data).filter(k => k !== "_ai"));
        const fields = fieldsForAiReview(t, anchors);
        const reviewQueue = buildAiReviewQueue(t, anchors);
        for(const f of fields) setSuggestStatus(t.id, f, "pending");
        renderEditor();

      // Force UUT P/N to match first test (no AI suggestion)
      if(anchors.uut_pn && t !== tests[0]){
        const curVal = String(t.data.uut_pn ?? "").trim();
        const anchorVal = String(anchors.uut_pn.value ?? "").trim();
        if(anchorVal && curVal !== anchorVal){
          t.data.uut_pn = anchorVal;
          setFieldMaturity(t, "uut_pn", 3);
          t.modified = true;
          logLine(`AI Review: enforced UUT P/N from first test on ${t.data.section_no || t.id.slice(0,6)}.`, "warn");
        }
      }

      // Enforce: M3 earlier replaces M4 later (order matters)
      for(const k of Object.keys(anchors)){
        const a = anchors[k];
        if(!a || a.maturity !== 3) continue;
        const curM = getFieldMaturity(t, k);
        const curVal = String(t.data[k] ?? "").trim();
        if(curM === 4 && a.value && curVal !== a.value){
          t.data[k] = a.value;
          setFieldMaturity(t, k, 3);
          t.modified = true;
          logLine(`AI Review: enforced M3 "${k}" from ${a.section_no || "prior test"} on ${t.data.section_no || t.id.slice(0,6)}.`, "warn");
        }
      }
        if(!fields.length){
          if(enablePersonalityReview){
            const commentFields = fieldsForPersonalityReview(t);
            if(commentFields.length){
              logLine(`AI Review: generating review comments for ${t.data.section_no || t.id.slice(0,6)} (${commentFields.length} fields)...`, "ok");
              for(const field of commentFields){
                if(!(await aiReviewWaitIfPaused())){ cancelled = true; break; }
                await reviewFieldComments(t, field);
              }
            }
          }
          for(const f of fields) setSuggestStatus(t.id, f, "accepted");
          setReviewStatus(t.id, "done");
          renderForm();
          renderTestsList();
          buildAnchorsFromTest(t);
          if(cancelled) break;
          continue;
        }

      logLine(`AI Review: reviewing ${t.data.section_no || t.id.slice(0,6)} (${reviewQueue.length} items)...`, "ok");

      let changedCount = 0;
      const matrixReviewState = new Map();
      const allItemsPayload = tests.map(tt => ({
        item_no: tt.data.section_no || "",
        item_name: tt.data.section_title || "",
        item_type: tt.data.section_type || ""
      }));

      const pauseMs = Number(state.prefs.ai_review_pause_ms ?? 0);
      const concurrency = Math.max(1, Number(state.prefs.ai_review_concurrency ?? 1));
      const queue = reviewQueue.filter(item => getFieldMaturity(t, item.field) < 3);

      let active = 0;
      let index = 0;
        await new Promise(resolve => {
        const launchNext = () => {
          if(state.aiReviewControl?.cancelled && active === 0) return resolve();
          if(state.aiReviewControl?.cancelled) return;
          if(index >= queue.length && active === 0) return resolve();
          while(active < concurrency && index < queue.length){
            const item = queue[index++];
            const field = item.field;
            active++;
            setSuggestStatus(t.id, field, "working");
            renderForm();
            const isMatrixCell = !!item.cellKey;
            let matrixContext = null;
              if(isMatrixCell){
                setMatrixCellStatus(t, field, item.cellKey, "working");
                const { matrix } = ensureMatrixField(t, field);
                const schema = t.data?._ai?.field_schema?.[field] || null;
                const matrixStateKey = `${t.id}:${field}`;
                if(!matrixReviewState.has(matrixStateKey)){
                  matrixReviewState.set(matrixStateKey, { sentFull: false, changes: [] });
                }
                const matrixState = matrixReviewState.get(matrixStateKey);
                matrixContext = {
                  cell_key: item.cellKey,
                  row_id: item.rowId,
                  col_id: item.colId,
                  row_label: matrix.row_labels?.[item.rowId] || item.rowId,
                  col_label: matrix.col_labels?.[item.colId] || item.colId,
                  cell_value: matrix.cells?.[item.cellKey] ?? "",
                  cell_prompt: schema?.cell_prompts?.[item.cellKey] || "",
                  col_prompt: schema?.col_prompts?.[item.colId] || ""
                };
                if(matrixState){
                  if(!matrixState.sentFull){
                    matrixContext.matrix_full = cloneJsonValue(matrix);
                    matrixContext.matrix_changes = [];
                    matrixState.sentFull = true;
                  }else{
                    matrixContext.matrix_changes = matrixState.changes.slice(-200);
                  }
                }
                if(state.prefs.ai_review_debug){
                  logLine(
                    `AI Review: matrix cell start ${t.data.section_no || t.id.slice(0,6)}.${field} ${matrixContext.cell_key} [${matrixContext.row_label} × ${matrixContext.col_label}] current="${String(matrixContext.cell_value || "").slice(0,80)}"`,
                    "warn"
                  );
                }
              }

            const contextData = (() => {
              const out = {};
              for(const k of Object.keys(t.data || {})){
                if(k === "_ai") continue;
                if(k === "section_title" || k === "section_no" || k === "section_type") continue;
                const v = t.data[k];
                if(typeof v === "string" || typeof v === "number" || typeof v === "boolean" || v === null){
                  out[k] = v;
                }
              }
              return out;
            })();
            const matrixPlanContext = isMatrixCell ? {
              item_no: t.data.section_no || "",
              item_name: t.data.section_title || "",
              item_type: t.data.section_type || "",
              section_no: t.data.section_no || "",
              section_name: t.data.section_title || "",
              section_type: t.data.section_type || ""
            } : contextData;

            const payload = {
              document: { name: plan.name, created: plan.created, updated: plan.updated },
              all_items: allItemsPayload,
              sections: allItemsPayload.map(x => ({
                section_no: x.item_no,
                section_name: x.item_name,
                section_type: x.item_type
              })),
              item_no: t.data.section_no || "",
              item_name: t.data.section_title || "",
              item_type: t.data.section_type || "",
              section_no: t.data.section_no || "",
              section_name: t.data.section_title || "",
              section_type: t.data.section_type || "",
              field,
              current_value: isMatrixCell ? (matrixContext?.cell_value ?? "") : (t.data[field] ?? ""),
              field_prompt: t.data?._ai?.field_prompts?.[field] || "",
              field_label: t.data?._ai?.field_labels?.[field] || field,
              maturity: getFieldMaturity(t, field),
              authoritative_values: Object.keys(anchors).reduce((acc, k) => (acc[k] = anchors[k].value, acc), {}),
              context: matrixPlanContext,
              matrix_cell: matrixContext || undefined,
              context_files: (state.aiChatContextFiles || []).slice(0, 1).map(f => ({
                name: f.name,
                type: f.type,
                truncated: !!f.truncated,
                text: f.text
              }))
            };
            if(isMatrixCell){
              payload.field_prompt = matrixContext?.cell_prompt
                || matrixContext?.col_prompt
                || payload.field_prompt;
            }

            (async () => {
              try{
                if(!(await aiReviewWaitIfPaused())) return;
                if(state.prefs.ai_review_debug){
                  logLine(`AI Review debug payload: ${JSON.stringify(payload).slice(0, 800)}...`, "warn");
                }
                const resp = await fetch(apiUrl("/review"), {
                  method: "POST",
                  headers: apiHeaders(),
                  body: JSON.stringify({
                    model,
                    input: [
                    { role:"system", content:getAiPrompt(plan, isMatrixCell ? "review_matrix_cell" : "review_field", { guidanceLine }) },
                      { role:"user", content: JSON.stringify(payload, null, 2) }
                    ],
                    max_output_tokens: 120
                  })
                });
                if(!resp.ok){
                  const ttxt = await resp.text().catch(()=> "");
                  throw new Error(`HTTP ${resp.status}: ${ttxt.slice(0,160)}`);
                }
                const data = await resp.json();
                const raw = extractResponseText(data);
                if(state.prefs.ai_review_debug){
                  logLine(`AI Review debug response: ${String(raw).slice(0, 800)}...`, "warn");
                  state.prefs.ai_review_debug = false;
                  savePrefs();
                }
                if(state.prefs.ai_review_debug && isMatrixCell){
                  logLine(
                    `AI Review: matrix cell raw ${t.data.section_no || t.id.slice(0,6)}.${field} ${matrixContext?.cell_key} => "${String(raw || "").slice(0,160)}"`,
                    "warn"
                  );
                }
                let val = String(raw || "").trim();
                if(!isMatrixCell && val.startsWith("{")){
                  const parsed = safeParseJson(val, "AI Review");
                  if(typeof parsed?.value === "string") val = parsed.value.trim();
                }
                if((val.startsWith("\"") && val.endsWith("\"")) || (val.startsWith("'") && val.endsWith("'"))){
                  val = val.slice(1, -1).trim();
                }
                val = sanitizeAiText(val);
                if(isMatrixCell){
                  if(!val){
                    setMatrixCellStatus(t, field, item.cellKey, "");
                    setSuggestStatus(t.id, field, "");
                    return;
                  }
                  const colLabel = String(matrixContext?.col_label || "").trim();
                  const rowLabel = String(matrixContext?.row_label || "").trim();
                  const maxLen = (item.colId === "requirement" || item.colId === "notes") ? 300 : 120;
                  const tooLong = val.length > maxLen;
                  const looksInstruction = /(?:\bshould\b|\benter\b|\bpopulate\b|\bfill\b|\buse\b|\binclude\b|\bprovide\b|\bset\b|\bcomplete\b)/i.test(val);
                  const looksSentence = /[.!?]/.test(val);
                  const allowInstruction = item.colId === "requirement";
                  const startsWithBad = /^(value|tbd|to be completed|to be filled|complete per|per drawing|per schematic|\{|\[|```)/i.test(val);
                  const allowRowMatch = ((item.colId === "item" || item.colId === "req_id") && rowLabel && val === rowLabel);
                  const bad = /^value/i.test(val)
                    || /^n\/a$/i.test(val)
                    || (colLabel && val === colLabel)
                    || (!allowRowMatch && rowLabel && val === rowLabel)
                    || startsWithBad
                    || (!allowInstruction && looksInstruction && looksSentence)
                    || tooLong;
                  if(bad){
                    logLine(`AI Review: matrix cell rejected "${val}" for ${t.data.section_no || t.id.slice(0,6)}.${field} ${item.cellKey}.`, "warn");
                    setMatrixCellStatus(t, field, item.cellKey, "");
                    setSuggestStatus(t.id, field, "");
                    return;
                  }
                }
                if(!state.aiReviewControl?.cancelled && val){
                  if(isMatrixCell){
                    const { matrix } = ensureMatrixField(t, field);
                    const curCell = String(matrix.cells?.[item.cellKey] ?? "");
                    if(val !== curCell){
                      matrix.cells[item.cellKey] = val;
                      t.data[field] = matrix;
                      if(!t._dirtyMatrixCells) t._dirtyMatrixCells = {};
                      if(!t._dirtyMatrixCells[field]) t._dirtyMatrixCells[field] = new Set();
                      t._dirtyMatrixCells[field].add(item.cellKey);
                      const matrixStateKey = `${t.id}:${field}`;
                      const matrixState = matrixReviewState.get(matrixStateKey);
                      if(matrixState){
                        matrixState.changes.push({
                          cell_key: item.cellKey,
                          row_id: item.rowId,
                          col_id: item.colId,
                          value: val
                        });
                      }
                      changedCount++;
                    }
                  }else if(val !== String(t.data[field] ?? "").trim()){
                    t.data[field] = val;
                    changedCount++;
                  }
                  setFieldMaturity(t, field, 2);
                  t.modified = true;
                  if(!t._dirtyFields) t._dirtyFields = {};
                  t._dirtyFields[field] = true;
                }
                if(isMatrixCell){
                  setMatrixCellStatus(t, field, item.cellKey, "accepted");
                  const cellInput = document.querySelector(`.matrixInput[data-matrix-field="${cssEscape(field)}"][data-matrix-cell="${cssEscape(item.cellKey)}"]`);
                  if(cellInput && val) cellInput.value = val;
                }
                setSuggestStatus(t.id, field, "accepted");
              }catch(err){
                setSuggestStatus(t.id, field, "");
                if(isMatrixCell) setMatrixCellStatus(t, field, item.cellKey, "");
                logLine(`AI Review: failed ${t.data.section_no || t.id.slice(0,6)}.${field} (${err.message || err}).`, "warn");
              }finally{
                active--;
                if(pauseMs > 0) await sleep(pauseMs);
                launchNext();
              }
            })();
          }
        };
        launchNext();
        });

        if(enablePersonalityReview){
          const commentFields = fieldsForPersonalityReview(t);
          if(commentFields.length){
            logLine(`AI Review: generating review comments for ${t.data.section_no || t.id.slice(0,6)} (${commentFields.length} fields)...`, "ok");
            for(const field of commentFields){
              if(!(await aiReviewWaitIfPaused())){ cancelled = true; break; }
              await reviewFieldComments(t, field);
            }
          }
        }
        if(cancelled) break;
        t.data._ai.last_ai_reviewed = nowIsoTimestamp();
        t.data._ai.last_ai_review_model = model;
      // If AI omits the new Unable-to-Adjust fields, derive a safe default.
      const unableAdjustPairs = [
        { field: "oot_low_unable_adjust", next: "oot_low_next_step", concl: "oot_low_conclusion" },
        { field: "oot_high_unable_adjust", next: "oot_high_next_step", concl: "oot_high_conclusion" }
      ];
      for(const u of unableAdjustPairs){
        if(!fields.includes(u.field)) continue;
        const cur = String(t.data[u.field] ?? "").trim();
        if(cur) continue;
        const nextStep = String(t.data[u.next] ?? "").trim();
        const conclusion = String(t.data[u.concl] ?? "").trim();
        if(!nextStep && !conclusion) continue;
        const suffix = nextStep ? ` Next: ${nextStep}` : "";
        t.data[u.field] = `Unable to adjust.${suffix}`.trim();
        setFieldMaturity(t, u.field, 2);
        t.modified = true;
        if(!t._dirtyFields) t._dirtyFields = {};
        t._dirtyFields[u.field] = true;
      }
      setReviewStatus(t.id, "done");
      renderForm();
      renderTestsList();
      logLine(`AI Review: updated ${t.data.section_no || t.id.slice(0,6)} (${changedCount} changes).`, changedCount ? "ok" : "warn");
      buildAnchorsFromTest(t);
    }

    if(cancelled){
      state.aiReviewControl.running = false;
      updateAiReviewControls();
      logLine("AI Review: cancelled by user.", "warn");
      toast("AI Review", "Cancelled.", "warn");
      return;
    }

    plan.updated = nowIsoDate();
    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("AI Review: document saved with improvements.", "ok");
    toast("AI Review", "Document updated.", "ok");
    if(state.currentPlan && state.currentPlan.id === plan.id){
      state.currentPlan = plan;
      renderEditor();
    }
    state.aiReviewControl.running = false;
    updateAiReviewControls();
  }

  function appendChatMessage(role, text){
    const log = $("aiChatLog");
    if(!log) return;
    const msg = document.createElement("div");
    msg.className = `chatMsg ${role}`;
    msg.textContent = text;
    log.appendChild(msg);
    log.scrollTop = log.scrollHeight;
  }

  function extractJsonBlock(text){
    const s = String(text || "");
    const fenced = s.match(/```json\s*([\s\S]*?)```/i);
    if(fenced && fenced[1]) return fenced[1].trim();
    const generic = s.match(/```([\s\S]*?)```/);
    if(generic && generic[1]) return generic[1].trim();
    return s.trim();
  }

  function extractBalancedJsonObject(text){
    const s = String(text || "");
    const start = s.indexOf("{");
    if(start < 0) return "";
    let depth = 0;
    let inStr = false;
    let esc = false;
    for(let i = start; i < s.length; i++){
      const ch = s[i];
      if(inStr){
        if(esc){ esc = false; continue; }
        if(ch === "\\"){ esc = true; continue; }
        if(ch === "\""){ inStr = false; continue; }
        continue;
      }
      if(ch === "\""){ inStr = true; continue; }
      if(ch === "{"){ depth++; }
      else if(ch === "}"){
        depth--;
        if(depth === 0) return s.slice(start, i + 1);
      }
    }
    return "";
  }

  function tryParseJson(text){
    try{ return JSON.parse(text); }catch{ return null; }
  }

  async function applyAiChatUpdates(plan, payload){
    const perm = normalizeAiChatPermission(state.prefs.ai_chat_permission ?? 1);
    if(perm <= 0) return false;
    let changed = false;
    const baseSchemaKeys = new Set(Object.keys(TEST_SCHEMA_DEFAULT));
    const defaultPlanKeys = new Set((plan?.tests?.[0]?.data ? Object.keys(plan.tests[0].data) : []).filter(k => k !== "_ai"));
    const deleteSet = new Set();
    if(perm >= 2){
      if(payload?.delete_all === true){
        if(plan.tests.length){
          plan.tests = [];
          changed = true;
        }
      }
      if(Array.isArray(payload?.delete_tests)){
        for(const rawNo of payload.delete_tests){
          const testNo = String(rawNo || "").trim();
          if(!testNo) continue;
          deleteSet.add(testNo);
        }
      }
    }
    if(payload?.plan){
      const p = payload.plan;
      if(typeof p.name === "string" && p.name.trim()){
        plan.name = sanitizeAiText(p.name.trim());
        plan.slug = slugifyPlanName(plan.name);
        changed = true;
      }
      if(typeof p.goal === "string"){
        plan.goal = sanitizeAiText(p.goal);
        changed = true;
      }
      if(typeof p.scope === "string"){
        plan.scope = sanitizeAiText(p.scope);
        changed = true;
      }
    }
    if(Array.isArray(payload?.tests)){
      for(const item of payload.tests){
        const testNo = String(item?.section_no || "").trim();
        const set = item?.set || {};
        const wantsDelete = perm >= 2 && item?.delete === true;
        if(wantsDelete && testNo){
          deleteSet.add(testNo);
          continue;
        }
        if(!set || typeof set !== "object") continue;
        let test = testNo ? plan.tests.find(t => String(t.data?.section_no || "").trim() === testNo) : null;
        if(!test){
          if(perm < 2) continue;
          const newNo = testNo || nextTestNo(plan);
          const safeSet = {};
          const allowedKeys = defaultPlanKeys.size ? defaultPlanKeys : baseSchemaKeys;
          for(const [k, v] of Object.entries(set)){
            if(!allowedKeys.has(k)) continue;
            safeSet[k] = sanitizeAiText(v);
          }
          test = createTestFromSet(plan, safeSet, newNo);
          changed = true;
        }
        const allowedKeys = new Set(Object.keys(test.data || {}).filter(k => k !== "_ai"));
        for(const [k, v] of Object.entries(set)){
          if(!allowedKeys.has(k)) continue;
          const curM = getFieldMaturity(test, k);
          if(curM >= 3) continue;
          const fieldType = String(test.data?._ai?.field_types?.[k] || "text").toLowerCase();
          if(fieldType.includes("matrix")){
            let nextVal = v;
            if(nextVal == null){
              const baseName = String(k).replace(/_matrix$/i, "");
              if(set && typeof set === "object"){
                if(set[`${baseName}_rows`] != null) nextVal = set[`${baseName}_rows`];
                else if(set[`${baseName}Rows`] != null) nextVal = set[`${baseName}Rows`];
                else if(set[`${baseName}_matrix`] != null) nextVal = set[`${baseName}_matrix`];
                else if(set[`${baseName}_template`] != null) nextVal = set[`${baseName}_template`];
                else if(set.matrix_template != null) nextVal = set.matrix_template;
              }
            }
            if((nextVal == null) && set && typeof set === "object"){
              const cellUpdates = extractMatrixCellPathUpdates(set, k);
              if(Object.keys(cellUpdates).length){
                const schema = getMatrixSchema(test, k);
                const currentMatrix = normalizeMatrixValue(test.data?.[k], schema);
                const merged = applyMatrixPayload(currentMatrix, schema, { cells: cellUpdates });
                test.data[k] = merged;
                setFieldMaturity(test, k, 2);
                test.modified = true;
                if(!test._dirtyFields) test._dirtyFields = {};
                test._dirtyFields[k] = true;
                changed = true;
                logLine(`AI Chat: applied ${Object.keys(cellUpdates).length} matrix cell updates to ${test.data?.section_no || "?"}.${k}.`, "ok");
              }else{
                logLine(`AI Chat: matrix updates ignored for ${test.data?.section_no || "?"}.${k} (no usable cell paths).`, "warn");
              }
              continue;
            }
            if(typeof nextVal === "string"){
              const raw = nextVal.trim();
              if(raw.startsWith("{") || raw.startsWith("[")){
                try{
                  nextVal = JSON.parse(raw);
                }catch{
                  logLine(`AI Chat: matrix update ignored for ${test.data?.section_no || "?"}.${k} (invalid JSON).`, "warn");
                  continue;
                }
              }else{
                logLine(`AI Chat: matrix update ignored for ${test.data?.section_no || "?"}.${k} (expected JSON object).`, "warn");
                continue;
              }
            }
            const schema = getMatrixSchema(test, k);
            const currentMatrix = normalizeMatrixValue(test.data?.[k], schema);
            const merged = applyMatrixPayload(currentMatrix, schema, nextVal);
            test.data[k] = merged;
          }else{
            const val = sanitizeAiText(v);
            if(String(test.data?.[k] ?? "") === val) continue;
            test.data[k] = val;
          }
          setFieldMaturity(test, k, 2);
          test.modified = true;
          if(!test._dirtyFields) test._dirtyFields = {};
          test._dirtyFields[k] = true;
          changed = true;
        }
      }
    }
    if(perm >= 2 && deleteSet.size){
      const before = plan.tests.length;
      plan.tests = plan.tests.filter(t => !deleteSet.has(String(t.data?.section_no || "").trim()));
      if(plan.tests.length !== before) changed = true;
    }
    if(changed){
      normalizeTestOrder(plan);
      if(state.currentTestId && !plan.tests.find(t => t.id === state.currentTestId)){
        state.currentTestId = plan.tests[0]?.id || null;
      }
    }
    if(changed){
      plan.updated = nowIsoDate();
      generatePlanMarkdown(plan);
      await Store.savePlan(plan);
    }
    return changed;
  }

  async function aiChatSend(){
    const plan = state.currentPlan;
    if(!plan){ toast("AI Chat", "Open a document first.", "warn"); return; }
    const input = $("aiChatInput");
    if(!input) return;
    const text = input.value.trim();
    if(!text) return;
    input.value = "";
    appendChatMessage("user", text);

    state.prefs = loadPrefs();
    const key = getAiKey();
    if(!USE_PROXY && !key){
      appendChatMessage("ai", "AI unavailable. Set a key in Preferences.");
      return;
    }
    if(!state.prefs.ai_enabled){
      appendChatMessage("ai", "AI is disabled. Enable it in Preferences.");
      return;
    }
    if(!plan.goal || !plan.scope || !plan.ai_review_guidance){
      const mdMeta = extractPlanMetaFromMarkdown(plan.markdown || "");
      if(!plan.goal) plan.goal = mdMeta.goal || "";
      if(!plan.scope) plan.scope = mdMeta.scope || "";
      if(!plan.ai_review_guidance) plan.ai_review_guidance = mdMeta.aiReviewGuidance || "";
    }
    const model = state.prefs.ai_model || "gpt-4.1-mini";
    const perm = normalizeAiChatPermission(state.prefs.ai_chat_permission ?? 1);
    const permLabel = aiChatPermissionLabel(perm);
    const partlistMeta = (state.aiChatContextFiles || []).reduce((acc, f) => {
      if(acc.headers.length) return acc;
      if(!f?.text) return acc;
      const meta = extractMarkdownSectionMeta(f.text, ["Partlist", "Partlist (Schematic)"]);
      if(meta.headers.length){
        acc.headers = meta.headers;
        acc.rowCount = meta.rowCount;
      }
      return acc;
    }, { headers: [], rowCount: 0 });
    const matrixTemplate = partlistMeta.headers.length
      ? buildMatrixTemplateFromPartlist(partlistMeta.headers, partlistMeta.rowCount)
      : null;
    const payload = {
      plan: { name: plan.name || "", goal: plan.goal || "", scope: plan.scope || "" },
      tests: (plan.tests || []).map(t => ({
        section_no: t.data?.section_no || "",
        section_title: t.data?.section_title || "",
        section_type: t.data?.section_type || ""
      })),
      document: { name: plan.name || "", goal: plan.goal || "", scope: plan.scope || "" },
      sections: (plan.tests || []).map(t => ({
        section_no: t.data?.section_no || "",
        section_name: t.data?.section_title || "",
        section_type: t.data?.section_type || ""
      })),
      permission: { level: perm, label: permLabel },
      partlist_headers: partlistMeta.headers,
      partlist_row_count: partlistMeta.rowCount,
      matrix_template: matrixTemplate,
      context_files: (state.aiChatContextFiles || []).map(f => ({
        name: f.name,
        type: f.type,
        truncated: !!f.truncated,
        text: f.text
      })),
      request: text
    };
    try{
      const resp = await fetch(apiUrl("/chat"), {
        method: "POST",
        headers: apiHeaders(),
        body: JSON.stringify({
          model,
          input: [
            { role:"system", content:getAiPrompt(plan, "chat_edit", { permLabel, perm }) },
            { role:"user", content: JSON.stringify(payload) }
          ],
          max_output_tokens: 600
        })
      });
      if(!resp.ok){
        const ttxt = await resp.text().catch(()=> "");
        throw new Error(`HTTP ${resp.status}: ${ttxt.slice(0,160)}`);
      }
      const data = await resp.json();
      const raw = extractResponseText(data);
      let parsed = null;
      if(typeof raw === "string"){
        const candidates = [];
        const balanced = extractBalancedJsonObject(raw);
        if(balanced) candidates.push(balanced);
        const extracted = extractJsonBlock(raw);
        if(extracted && extracted !== balanced) candidates.push(extracted);
        candidates.push(raw);
        for(const cand of candidates){
          const repaired = repairJsonText(cand);
          const strict = tryParseJson(repaired);
          if(strict){ parsed = strict; break; }
        }
        if(!parsed){
          const fallbackCandidate = repairJsonText(candidates[0] || raw);
          parsed = safeParseJson(fallbackCandidate, "AI Chat");
        }
      }else if(raw && typeof raw === "object"){
        parsed = raw;
      }
      if(parsed && typeof parsed === "object" && Object.keys(parsed).length){
        if(parsed.__fromFallback){
          const rawText = sanitizeAiText(String(raw || ""));
          logLine(`AI Chat parse fallback used. Raw response: ${rawText.slice(0, 800)}`, "warn");
        }
        const message = sanitizeAiText(parsed.message || "Applied requested updates.");
        appendChatMessage("ai", message);
        const changed = await applyAiChatUpdates(plan, parsed);
        if(!changed && normalizeAiChatPermission(state.prefs.ai_chat_permission ?? 1) <= 0){
          appendChatMessage("ai", "Request not applied. AI Permission is set to Search/Find (read-only).");
        }
        if(changed){
          renderEditor();
          renderTestsList();
        }
      }else{
        const rawText = sanitizeAiText(String(raw || ""));
        logLine(`AI Chat parse failed. Raw response: ${rawText.slice(0, 800)}`, "warn");
        appendChatMessage("ai", rawText);
      }
    }catch(e){
      appendChatMessage("ai", `AI error: ${e.message || e}`);
    }
  }

  function openMaturityDialog(test, field){
    if(!test) return;
    const current = getFieldMaturity(test, field);
    showModal("AI Maturity", (body, footer) => {
      body.innerHTML = `
        <div class="muted">Set maturity for <span class="tag">${escapeHtml(field)}</span></div>
        <div class="hr"></div>
        <div class="row">
          <div>
            <div class="label">Maturity Level</div>
            <select class="select" id="maturitySelect">
              <option value="0">M0 — Unknown</option>
              <option value="1">M1 — Placeholder</option>
              <option value="2">M2 — AI-Assisted</option>
              <option value="3">M3 — Human-Reviewed</option>
              <option value="4">M4 — Locked</option>
            </select>
          </div>
        </div>
      `;
      $("maturitySelect").value = String(current);
      footer.innerHTML = `
        <button class="btn" id="cancelMaturity">Cancel</button>
        <button class="btn primary" id="saveMaturity">Save</button>
      `;
      $("cancelMaturity").onclick = hideModal;
      $("saveMaturity").onclick = () => {
        const val = Number($("maturitySelect").value);
        if(!test.data._ai) test.data._ai = { maturity:{} };
        if(!test.data._ai.maturity) test.data._ai.maturity = {};
        test.data._ai.maturity[field] = Number.isFinite(val) ? val : 0;
        test.modified = true;
        if(!test._dirtyFields) test._dirtyFields = {};
        test._dirtyFields[`_ai.maturity.${field}`] = true;
        $("dirtyHint").style.display = "";
        hideModal();
        renderForm();
      };
    });
  }

  function openMaturityQuick(test, field, tagEl){
    if(!test || !tagEl) return;
    if(tagEl.querySelector(".maturity-menu")) return;
    const current = getFieldMaturity(test, field);
    const menu = document.createElement("div");
    menu.className = "maturity-menu";
    menu.style.display = "flex";
    menu.style.gap = "4px";
    menu.style.alignItems = "center";
    menu.innerHTML = [0,1,2,3,4].map(n => (
      `<button class="btn mini${n === current ? " selected" : ""}" data-m="${n}" type="button">M${n}</button>`
    )).join("");
    const applyVal = (val) => {
      const num = Number(val);
      if(!test.data._ai) test.data._ai = { maturity:{} };
      if(!test.data._ai.maturity) test.data._ai.maturity = {};
      test.data._ai.maturity[field] = Number.isFinite(num) ? num : 0;
      test.modified = true;
      if(!test._dirtyFields) test._dirtyFields = {};
      test._dirtyFields[`_ai.maturity.${field}`] = true;
      $("dirtyHint").style.display = "";
      tagEl.classList.add("maturity-dirty");
      tagEl.textContent = `M${Number.isFinite(num) ? num : 0}`;
    };
    tagEl.textContent = "";
    tagEl.appendChild(menu);
    menu.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const val = btn.getAttribute("data-m");
        menu.querySelectorAll("button").forEach(b => b.classList.toggle("selected", b === btn));
        applyVal(val);
      });
    });
    const onDoc = (e) => {
      if(tagEl.contains(e.target)) return;
      document.removeEventListener("click", onDoc, true);
      if(tagEl.textContent.trim() === "") tagEl.textContent = `M${current}`;
    };
    document.addEventListener("click", onDoc, true);
  }

  function downloadText(filename, text, mime="text/plain"){
    const blob = new Blob([text], {type: mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  }

  /* ---------- View switching ---------- */
  function showLibrary(){
    $("viewLibrary").classList.add("active");
    $("viewEditor").classList.remove("active");
    $("viewLibrary").style.display = "flex";
    $("viewEditor").style.display = "none";
    $("switchPlanBtn").style.display = "none";
    $("saveAllBtn").style.display = "none";
    $("planBadge").style.display = "none";
    state.currentPlan = null;
    state.currentTemplateId = null;
    state.currentTestId = null;
    runAsync(renderLibrary());
  }

  function showEditor(){
    $("viewLibrary").classList.remove("active");
    $("viewEditor").classList.add("active");
    $("viewLibrary").style.display = "none";
    $("viewEditor").style.display = "flex";
    $("switchPlanBtn").style.display = "";
    $("saveAllBtn").style.display = "";
    $("planBadge").style.display = "";
    renderEditor();
  }

  /* ---------- Library rendering ---------- */
  async function renderLibrary(){
    // status chips
    updateAiBadge();
    updateAiUI();
    updatePlanRootUI();

    const q = ($("planSearch").value || "").toLowerCase().trim();
    const plans = await Store.listPlans();
    const templates = await Templates.listTemplates();
    state.plansCache = plans;
    state.templatesCache = templates;

    const totalTests = plans.reduce((sum, p) => sum + (p.tests?.length || 0), 0);
    const totalTemplateTests = templates.reduce((sum, t) => sum + (t.tests?.length || 0), 0);
    const planCount = $("wsPlanCount");
    const testCount = $("wsTestCount");
    const templateCount = $("wsTemplateCount");
    const templateTestCount = $("wsTemplateTestCount");
    if(planCount) planCount.textContent = String(plans.length);
    if(testCount) testCount.textContent = String(totalTests);
    if(templateCount) templateCount.textContent = String(templates.length);
    if(templateTestCount) templateTestCount.textContent = String(totalTemplateTests);

    const filteredTemplates = templates.filter(t => !q || (t.name||"").toLowerCase().includes(q));
    const filtered = plans.filter(p => !q || (p.name||"").toLowerCase().includes(q));
    const templatesCount = $("templatesCount");
    if(templatesCount) templatesCount.textContent = `${filteredTemplates.length} shown`;
    $("plansCount").textContent = `${filtered.length} shown`;

    const tlist = $("templatesList");
    tlist.innerHTML = "";
    for(const t of filteredTemplates){
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="left">
          <div class="name">${escapeHtml(t.name || "(Unnamed Template)")}</div>
          <div class="meta">
            <span class="tag">${escapeHtml(t.slug || "template")}</span>
            <span class="tag">Items: ${escapeHtml(String((t.tests||[]).length))}</span>
            <span class="tag">Updated: ${escapeHtml(t.updated || "(unknown)")}</span>
          </div>
        </div>
        <div class="actions">
          <button class="btn mini primary" data-act="create" data-id="${escapeHtml(t.id)}">Create New</button>
          <button class="btn mini" data-act="rename-template" data-id="${escapeHtml(t.id)}">Rename</button>
          <button class="btn mini danger" data-act="delete-template" data-id="${escapeHtml(t.id)}">Delete</button>
        </div>
      `;
      el.addEventListener("click", (e) => {
        if(e.target.closest("button")) return;
        runAsync(openTemplateById(t.id));
      });
      tlist.appendChild(el);
    }

    const list = $("plansList");
    list.innerHTML = "";
    for(const p of filtered){
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="left">
          <div class="name">${escapeHtml(p.name || "(Unnamed Plan)")}</div>
          <div class="meta">
            <span class="tag">${escapeHtml(p.slug || "plan")}</span>
            <span class="tag">Items: ${escapeHtml(String((p.tests||[]).length))}</span>
            <span class="tag">Updated: ${escapeHtml(p.updated || "(unknown)")}</span>
          </div>
        </div>
        <div class="actions"></div>
      `;
      el.addEventListener("click", (e) => {
        if(e.target.closest("button")) return;
        runAsync(openPlanById(p.id));
      });
      el.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const items = [
          {
            id: "sanitize",
            label: "JSON Sanitize",
            onClick: () => runAsync((async () => {
              try{
                await sanitizePlanJson(p.id);
                logLine("JSON Sanitize: completed.", "ok");
                toast("JSON Sanitize", "Document JSON sanitized.", "ok");
                runAsync(renderLibrary());
              }catch(err){
                logLine(`JSON Sanitize failed: ${err.message || err}`, "warn");
                toast("JSON Sanitize", err.message || "Failed.", "warn");
              }
            })())
          },
          { id: "review", label: "AI Review", onClick: () => runAsync(aiReviewPlan(p.id)) },
          { id: "rename", label: "Rename", onClick: () => runAsync(renamePlanFlow(p.id)) },
          { id: "save-template", label: "Save as Template", onClick: () => runAsync(saveTemplateFlow(p.id)) },
          { id: "duplicate", label: "Duplicate", onClick: () => runAsync(duplicatePlanFlow(p.id)) },
          { id: "delete", label: "Delete", onClick: () => runAsync(deletePlanFlow(p.id)) }
        ];
        showContextMenu(e.clientX, e.clientY, items);
      });
      list.appendChild(el);
    }

    tlist.querySelectorAll("button[data-act]").forEach(btn => {
      btn.addEventListener("click", () => {
        const act = btn.getAttribute("data-act");
        const id = btn.getAttribute("data-id");
        if(act === "create") runAsync(createFromTemplateFlow(id));
        if(act === "rename-template") runAsync(renameTemplateFlow(id));
        if(act === "delete-template") runAsync(deleteTemplateFlow(id));
      });
    });

    list.querySelectorAll("button[data-act]").forEach(btn => {
      btn.addEventListener("click", () => {
        const act = btn.getAttribute("data-act");
        const id = btn.getAttribute("data-id");
        if(act === "open") runAsync(openPlanById(id));
      });
    });
  }

  /* ---------- Editor rendering ---------- */
  function currentTest(){
    if(!state.currentPlan || !state.currentTestId) return null;
    return state.currentPlan.tests.find(t => t.id === state.currentTestId) || null;
  }

  function updateSaveAllIndicator(){
    const plan = state.currentPlan;
    const saveAllBtn = $("saveAllBtn");
    if(!saveAllBtn || !plan) return;
    const dirty = !!plan.tests?.some(t => t.modified);
    saveAllBtn.classList.toggle("attn", dirty);
  }

  function renderEditor(){
    const plan = state.currentPlan;
    if(!plan){ showLibrary(); return; }

    $("planBadgeName").textContent = plan.name || "(Unnamed Plan)";
    $("planBadgeSub").textContent = `${plan.tests.length} sections`;

    updateAiUI();
    const aiModelEl = $("aiChatModel");
    if(aiModelEl) aiModelEl.textContent = state.prefs.ai_model || "gpt-4.1-mini";
    const permSlider = $("aiPermSlider");
    const permLabel = $("aiPermLabel");
    if(permSlider){
      const permVal = normalizeAiChatPermission(state.prefs.ai_chat_permission ?? 1);
      permSlider.value = String(permVal);
      if(permLabel) permLabel.textContent = aiChatPermissionLabel(permVal);
    }
    const delBtn = $("btnDeleteTest");
    if(delBtn) delBtn.disabled = !state.currentTestId;

    renderTestsList();
    renderForm();
    renderReviewNotes();
    refreshMarkdownUI();
    drawFlowchart();
  }

  function renderReviewNotes(){
    const test = currentTest();
    const notes = $("reviewNotes");
    if(!notes) return;
    if(!test){
      notes.value = "";
      notes.disabled = true;
      return;
    }
    notes.disabled = false;
    if(!test.data._ai) test.data._ai = ensureAiMeta(null, Object.keys(test.data).filter(k => k !== "_ai"));
    notes.value = test.data._ai.notes || "";
    notes.oninput = () => {
      test.data._ai.notes = notes.value;
      test.modified = true;
      if(!test._dirtyFields) test._dirtyFields = {};
      test._dirtyFields["_ai.notes"] = true;
      $("dirtyHint").style.display = "";
      renderTestsList();
    };
  }

  function renderTestsList(){
    const plan = state.currentPlan;
    const q = ($("testSearch").value || "").toLowerCase().trim();
    const wrap = $("testsList");
    wrap.innerHTML = "";

    if(state.currentTestTemplate){
      const listTitle = $("testListTitle");
      if(listTitle) listTitle.textContent = "Template List";
      const templates = (state.templateListCache || []).filter(t => t.id !== "__blank__");
      const filtered = templates.filter(t => !q || (t.name || "").toLowerCase().includes(q));
      if(!filtered.length){
        wrap.innerHTML = `<div class="muted" style="padding:10px 2px;">No templates found.</div>`;
        return;
      }
      for(const t of filtered){
        const row = document.createElement("div");
        row.className = "testRow";
        row.innerHTML = `
          <div class="top">
            <div class="tno">${escapeHtml(t.file || "")}</div>
            <div class="tag">Template</div>
          </div>
          <div class="tname">${escapeHtml(t.name)}</div>
        `;
        row.addEventListener("click", () => {
          runAsync(openTestTemplateEditor(t, state.currentTestTemplate.basePlanId));
        });
        wrap.appendChild(row);
      }
      return;
    }

    const listTitle = $("testListTitle");
    if(listTitle) listTitle.textContent = "List";

    const tests = (plan.tests || []).slice().sort((a,b) => (a.order||0) - (b.order||0));
    for(const t of tests){
      const d = t.data || {};
      const tno = (d.section_no || "").trim() || "(no section_no)";
      const name = (d.section_title || "").trim() || "(no section_title)";
      const type = (d.section_type || "").trim() || "(no section_type)";
      if(q && !(tno.toLowerCase().includes(q) || name.toLowerCase().includes(q))) continue;

      const row = document.createElement("div");
      const review = getReviewStatus(t.id);
      row.className = "testRow"
        + (t.id === state.currentTestId ? " active" : "")
        + (review ? ` review-${review}` : "");
      row.setAttribute("draggable", "true");
      row.setAttribute("data-id", t.id);
      row.innerHTML = `
        <div class="top">
          <div class="tno">${escapeHtml(tno)}</div>
          <div class="tag ${t.modified ? "dirty" : ""}">${t.modified ? "Modified" : "Saved"}</div>
        </div>
        <div class="tname">${escapeHtml(name)}</div>
        <div class="sub">
          <span class="tag">${escapeHtml(type)}</span>
          ${(() => {
            const label1 = String(d.param1_label || "").trim() || "-";
            const key1 = String(d.param1_value || "").trim();
            const value1Raw = key1 ? d[key1] : "";
            const value1 = (value1Raw == null || String(value1Raw).trim() === "") ? "-" : value1Raw;
            if(label1 === "-" && String(value1) === "-") return `<span class="tag param-tag" data-param="1" title="Double-click to edit">---</span>`;
            return `<span class="tag param-tag" data-param="1" title="Double-click to edit">${escapeHtml(label1)}: ${escapeHtml(String(value1))}</span>`;
          })()}
          ${(() => {
            const label2 = String(d.param2_label || "").trim() || "-";
            const key2 = String(d.param2_value || "").trim();
            const value2Raw = key2 ? d[key2] : "";
            const value2 = (value2Raw == null || String(value2Raw).trim() === "") ? "-" : value2Raw;
            if(label2 === "-" && String(value2) === "-") return `<span class="tag param-tag" data-param="2" title="Double-click to edit">---</span>`;
            return `<span class="tag param-tag" data-param="2" title="Double-click to edit">${escapeHtml(label2)}: ${escapeHtml(String(value2))}</span>`;
          })()}
        </div>
      `;
      row.addEventListener("click", () => {
        state.currentTestId = t.id;
        renderEditor();
      });
      row.addEventListener("dragstart", (e) => {
        row.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", t.id);
      });
      row.addEventListener("dragend", () => {
        row.classList.remove("dragging");
        wrap.querySelectorAll(".testRow.dragover").forEach(el => el.classList.remove("dragover"));
      });
      row.addEventListener("dragover", (e) => {
        e.preventDefault();
        row.classList.add("dragover");
      });
      row.addEventListener("dragleave", () => {
        row.classList.remove("dragover");
      });
      row.addEventListener("drop", (e) => {
        e.preventDefault();
        row.classList.remove("dragover");
        const dragId = e.dataTransfer.getData("text/plain");
        if(!dragId || dragId === t.id) return;
        reorderTests(dragId, t.id);
      });
      row.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const items = [
          {
            id: "save_template",
            label: "Save as Test Template",
            onClick: async () => {
              if(!state.planRootHandle){
                toast("Templates", "Set a Library Folder to use list item templates.", "warn");
                return;
              }
              const name = prompt("Template name:", t.data?.section_title || "New Test Template");
              if(name === null) return;
              const ok = await createTestTemplateFromData(state.currentPlan, name, t.data);
              if(ok) toast("Templates", "Template created.", "ok");
              else toast("Templates", "Template creation failed.", "warn");
            }
          },
          {
            id: "duplicate_below",
            label: "Duplicate (insert below)",
            onClick: () => duplicateTestBelow(t.id)
          },
          {
            id: "delete_test",
            label: "Delete",
            onClick: () => deleteTestById(t.id)
          }
        ];
        showContextMenu(e.clientX, e.clientY, items);
      });
      row.querySelectorAll(".param-tag").forEach(tag => {
        tag.addEventListener("dblclick", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const which = Number(tag.getAttribute("data-param") || "1");
          openParamEditDialog(t, which);
        });
      });
      wrap.appendChild(row);
    }
    updateSaveAllIndicator();
  }

  async function reorderTests(dragId, targetId){
    const plan = state.currentPlan;
    if(!plan) return;
    const ordered = (plan.tests || []).slice().sort((a,b) => (a.order||0) - (b.order||0));
    const ids = ordered.map(t => t.id);
    const from = ids.indexOf(dragId);
    const to = ids.indexOf(targetId);
    if(from < 0 || to < 0 || from === to) return;
    ids.splice(from, 1);
    ids.splice(to, 0, dragId);
    const byId = new Map((plan.tests || []).map(t => [t.id, t]));
    ids.forEach((id, idx) => {
      const t = byId.get(id);
      if(t) t.order = idx + 1;
    });
    plan.updated = nowIsoDate();
    generatePlanMarkdown(plan);
    if(state.currentTemplateId){
      await Templates.saveTemplate(plan);
      logLine("Reordered list items (template).", "ok");
    }else{
      await Store.savePlan(plan);
      logLine("Reordered list items.", "ok");
    }
    renderTestsList();
    renderEditor();
  }

  function getMatrixSchema(test, fieldKey){
    if(!test?.data?._ai) return null;
    const schema = test.data._ai.field_schema?.[fieldKey];
    return (schema && typeof schema === "object") ? schema : null;
  }

  function normalizeMatrixValue(value, schema){
    const src = (value && typeof value === "object" && !Array.isArray(value)) ? value : {};
    const schemaRows = Array.isArray(schema?.rows) ? schema.rows : [];
    const schemaCols = Array.isArray(schema?.cols) ? schema.cols : [];
    const rows = Array.isArray(src.rows) ? [...src.rows] : schemaRows.map(r => r.id);
    const cols = Array.isArray(src.cols) ? [...src.cols] : schemaCols.map(c => c.id);
    const rowLabels = (src.row_labels && typeof src.row_labels === "object") ? { ...src.row_labels } : {};
    const colLabels = (src.col_labels && typeof src.col_labels === "object") ? { ...src.col_labels } : {};
    const cells = (src.cells && typeof src.cells === "object") ? { ...src.cells } : {};
    const cellPrompts = (src.cell_prompts && typeof src.cell_prompts === "object") ? { ...src.cell_prompts } : {};
    const schemaCellPrompts = (schema?.cell_prompts && typeof schema.cell_prompts === "object") ? schema.cell_prompts : null;
    if(schemaCellPrompts){
      for(const [k,v] of Object.entries(schemaCellPrompts)){
        if(!(k in cellPrompts)) cellPrompts[k] = v;
      }
    }
    for(const r of schemaRows){
      if(r?.id && !(r.id in rowLabels)) rowLabels[r.id] = r.label || r.id;
      if(r?.id && !rows.includes(r.id)) rows.push(r.id);
    }
    for(const c of schemaCols){
      if(c?.id && !(c.id in colLabels)) colLabels[c.id] = c.label || c.id;
      if(c?.id && !cols.includes(c.id)) cols.push(c.id);
    }
    const colWidths = (src.col_widths && typeof src.col_widths === "object") ? { ...src.col_widths } : {};
    return { rows, cols, row_labels: rowLabels, col_labels: colLabels, cells, cell_prompts: cellPrompts, col_widths: colWidths };
  }

  function applyMatrixCellUpdates(matrix, schema, cells){
    if(!matrix || !cells || typeof cells !== "object") return;
    for(const [cellKey, cellVal] of Object.entries(cells)){
      const val = sanitizeAiText(cellVal);
      if(!val) continue;
      const parts = String(cellKey).split("::");
      const rowId = parts[0] || "";
      const colId = parts[1] || "";
      if(rowId && !matrix.rows.includes(rowId)) matrix.rows.push(rowId);
      if(colId && !matrix.cols.includes(colId)) matrix.cols.push(colId);
      if(rowId && !matrix.row_labels[rowId]) matrix.row_labels[rowId] = rowId;
      if(colId && !matrix.col_labels[colId]) matrix.col_labels[colId] = colId;
      matrix.cells[cellKey] = val;
      if(matrix.cell_prompts) delete matrix.cell_prompts[cellKey];
      if(schema?.cell_prompts) delete schema.cell_prompts[cellKey];
    }
  }

  function normalizeMatrixColId(rawKey){
    const normKey = (s) => String(s || "").toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
    const nk = normKey(rawKey);
    if(["ref_des","refdes","ref_desig","ref_designators","refdesignators","ref"].includes(nk)) return "refdes";
    if(["part_type","parttype","type","category","part_category","part"].includes(nk)) return "description";
    if(["value_description","value_desc","valuedescription","value","description_value","value_description_"].includes(nk)) return "value";
    if(["qty","quantity","quant"].includes(nk)) return "qty";
    if(["mpn","mpn_1","manufacturer_part_number","mfr_pn","manufacturer_pn","supplier_pn","spn"].includes(nk)) return "mpn_1";
    if(["mfr","manufacturer","mfr_1","manufacturer_1","supplier"].includes(nk)) return "mfr_1";
    if(nk === "line_item") return "item";
    return nk;
  }

  function normalizeMatrixPayloadStructure(payload){
    if(!payload || typeof payload !== "object") return payload;
    const out = { ...payload };
    if(Array.isArray(payload.cols)){
      out.cols = payload.cols.map(c => normalizeMatrixColId(c)).filter(Boolean);
    }
    if(payload.col_labels && typeof payload.col_labels === "object"){
      const nextLabels = {};
      for(const [k, v] of Object.entries(payload.col_labels)){
        const id = normalizeMatrixColId(k);
        if(!id) continue;
        nextLabels[id] = v;
      }
      out.col_labels = nextLabels;
    }
    if(payload.col_prompts && typeof payload.col_prompts === "object"){
      const nextPrompts = {};
      for(const [k, v] of Object.entries(payload.col_prompts)){
        const id = normalizeMatrixColId(k);
        if(!id) continue;
        nextPrompts[id] = v;
      }
      out.col_prompts = nextPrompts;
    }
    if(payload.cells && typeof payload.cells === "object"){
      const nextCells = {};
      for(const [k, v] of Object.entries(payload.cells)){
        const parts = String(k).split("::");
        if(parts.length < 2){ continue; }
        let rowId = parts[0];
        let colId = normalizeMatrixColId(parts[1]);
        if(/^\d+$/.test(rowId)) rowId = String(rowId).padStart(3, "0");
        if(!colId) continue;
        nextCells[`${rowId}::${colId}`] = v;
      }
      out.cells = nextCells;
    }
    return out;
  }

  function applyMatrixPayload(currentMatrix, schema, nextObj){
    if(Array.isArray(nextObj)){
      return applyMatrixArrayPayload(currentMatrix, schema, nextObj);
    }
    const payload = normalizeMatrixPayloadStructure((nextObj && typeof nextObj === "object" && !Array.isArray(nextObj)) ? nextObj : {});
    const hasStructure = ("rows" in payload) || ("cols" in payload) || ("row_labels" in payload) || ("col_labels" in payload);
    let merged;
    if(payload.cells && !hasStructure){
      merged = currentMatrix;
      applyMatrixCellUpdates(merged, schema, payload.cells || {});
    }else{
      const base = {
        rows: Array.isArray(payload.rows) ? payload.rows : currentMatrix.rows,
        cols: Array.isArray(payload.cols) ? payload.cols : currentMatrix.cols,
        row_labels: { ...currentMatrix.row_labels, ...(payload.row_labels || {}) },
        col_labels: { ...currentMatrix.col_labels, ...(payload.col_labels || {}) },
        cells: { ...currentMatrix.cells }
      };
      merged = normalizeMatrixValue(base, schema);
      if(payload.cells) applyMatrixCellUpdates(merged, schema, payload.cells || {});
      if(Array.isArray(payload.rows) || Array.isArray(payload.cols)) pruneMatrixToShape(merged);
      if(schema && typeof schema === "object"){
        if(Array.isArray(payload.rows)){
          schema.rows = payload.rows.map((id) => ({
            id,
            label: (payload.row_labels && payload.row_labels[id]) || merged.row_labels?.[id] || id
          }));
        }
        if(Array.isArray(payload.cols)){
          schema.cols = payload.cols.map((id) => ({
            id,
            label: (payload.col_labels && payload.col_labels[id]) || merged.col_labels?.[id] || id
          }));
        }
        if(payload.col_prompts && typeof payload.col_prompts === "object"){
          if(!schema.col_prompts) schema.col_prompts = {};
          for(const [cid, prompt] of Object.entries(payload.col_prompts)){
            const val = String(prompt ?? "").trim();
            if(!val) continue;
            schema.col_prompts[cid] = val;
          }
        }
      }
    }
    return merged;
  }

  function extractMatrixCellPathUpdates(set, fieldKey){
    const cells = {};
    if(!set || typeof set !== "object") return cells;
    const prefixes = [
      `matrix_template.cells.`,
      `matrix.cells.`,
      `${fieldKey}.cells.`,
      `${String(fieldKey).replace(/_matrix$/i, "")}_matrix.cells.`
    ];
    const nestedKeys = [
      "matrix_template.cells",
      "matrix.cells",
      `${fieldKey}.cells`,
      `${String(fieldKey).replace(/_matrix$/i, "")}_matrix.cells`
    ];
    for(const nk of nestedKeys){
      if(!(nk in set)) continue;
      const block = set[nk];
      if(!block || typeof block !== "object") continue;
      for(const [rowIdRaw, colsObj] of Object.entries(block)){
        if(!colsObj || typeof colsObj !== "object") continue;
        let rowId = String(rowIdRaw || "");
        if(/^\d+$/.test(rowId)) rowId = String(rowId).padStart(3, "0");
        for(const [colRaw, valRaw] of Object.entries(colsObj)){
          const colId = normalizeMatrixColId(colRaw);
          if(!colId) continue;
          const cellKey = `${rowId}::${colId}`;
          const val = sanitizeAiText(valRaw);
          if(!val) continue;
          cells[cellKey] = val;
        }
      }
    }
    for(const [k, v] of Object.entries(set)){
      const key = String(k || "");
      const prefix = prefixes.find(p => key.startsWith(p));
      if(!prefix) continue;
      const rest = key.slice(prefix.length);
      const parts = rest.split(".").filter(Boolean);
      if(parts.length < 2) continue;
      let rowId = parts[0];
      let colId = parts[1];
      if(/^\d+$/.test(rowId)) rowId = String(rowId).padStart(3, "0");
      colId = normalizeMatrixColId(colId);
      const cellKey = `${rowId}::${colId}`;
      const val = sanitizeAiText(v);
      if(!val) continue;
      cells[cellKey] = val;
    }
    return cells;
  }

  function applyMatrixArrayPayload(currentMatrix, schema, rowsArr){
    const rowsInput = Array.isArray(rowsArr) ? rowsArr : [];
    const normKey = (s) => String(s || "").toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
    const titleFromKey = (s) => {
      const raw = String(s || "").replace(/[_\-]+/g, " ").trim();
      if(!raw) return "";
      return raw.split(/\s+/).map(w => w ? (w[0].toUpperCase() + w.slice(1)) : "").join(" ");
    };
    const isRowMetaKey = (k) => {
      const nk = normKey(k);
      return ["line_item","item","row","row_id","rowid","id","row_label","rowlabel"].includes(nk);
    };
    const aliasKey = (k) => normalizeMatrixColId(k);
    const colIdMap = new Map();
    for(const id of currentMatrix.cols || []){
      colIdMap.set(normKey(id), id);
    }
    for(const [id, label] of Object.entries(currentMatrix.col_labels || {})){
      colIdMap.set(normKey(label), id);
    }
    const colOrder = [];
    const colLabelMap = {};
    const rowIds = [];
    const rowLabels = {};
    const cells = {};
    for(let idx = 0; idx < rowsInput.length; idx++){
      const rowObj = rowsInput[idx] && typeof rowsInput[idx] === "object" ? rowsInput[idx] : {};
      let rowId = rowObj.line_item ?? rowObj.item ?? rowObj.row ?? rowObj.row_id ?? rowObj.id ?? rowObj.rowid ?? "";
      if(rowId === "") rowId = idx + 1;
      if(typeof rowId === "number" && Number.isFinite(rowId)){
        rowId = String(Math.trunc(rowId)).padStart(3, "0");
      }
      rowId = String(rowId).trim() || String(idx + 1).padStart(3, "0");
      rowIds.push(rowId);
      const rowLabel = rowObj.row_label ?? rowObj.rowlabel ?? rowObj.item ?? rowId;
      rowLabels[rowId] = String(rowLabel ?? rowId);
      for(const [rawKey, rawVal] of Object.entries(rowObj)){
        if(isRowMetaKey(rawKey)) continue;
        const keyNorm = aliasKey(rawKey);
        if(!keyNorm) continue;
        let colId = colIdMap.get(keyNorm);
        if(!colId){
          colId = keyNorm;
          colIdMap.set(keyNorm, colId);
        }
        if(!colLabelMap[colId]){
          const label = String(rawKey || "").trim();
          if(label) colLabelMap[colId] = label;
        }
        if(!colOrder.includes(colId)) colOrder.push(colId);
        const cellKey = `${rowId}::${colId}`;
        const val = sanitizeAiText(rawVal);
        if(!val) continue;
        cells[cellKey] = val;
      }
    }
    if(colOrder.includes("description") && colOrder.includes("value")){
      colOrder.sort((a, b) => {
        const order = ["item","refdes","qty","description","value","package","mfr_1","mpn_1","mfr_2","mpn_2","mfr_3","mpn_3","notes"];
        const ai = order.indexOf(a);
        const bi = order.indexOf(b);
        if(ai === -1 && bi === -1) return a.localeCompare(b);
        if(ai === -1) return 1;
        if(bi === -1) return -1;
        return ai - bi;
      });
    }
    const colLabels = {};
    for(const colId of colOrder){
      const existing = currentMatrix.col_labels?.[colId];
      const mapped = colLabelMap[colId];
      colLabels[colId] = mapped || existing || titleFromKey(colId) || colId;
    }
    const merged = normalizeMatrixValue({
      rows: rowIds,
      cols: colOrder,
      row_labels: rowLabels,
      col_labels: colLabels,
      cells: {}
    }, schema);
    applyMatrixCellUpdates(merged, schema, cells);
    pruneMatrixToShape(merged);
    if(schema && typeof schema === "object"){
      schema.rows = rowIds.map((id) => ({ id, label: merged.row_labels?.[id] || id }));
      schema.cols = colOrder.map((id) => ({ id, label: merged.col_labels?.[id] || id }));
      const nextPrompts = {};
      for(const colId of colOrder){
        if(colId === "refdes") nextPrompts[colId] = "Reference designators (e.g., R1,R2,C5).";
        else if(colId === "description") nextPrompts[colId] = "Part type (e.g., capacitor, resistor, connector).";
        else if(colId === "value") nextPrompts[colId] = "Value or description from schematic partlist.";
        else if(schema.col_prompts && schema.col_prompts[colId]) nextPrompts[colId] = schema.col_prompts[colId];
      }
      schema.col_prompts = nextPrompts;
    }
    return merged;
  }

  function pruneMatrixToShape(matrix){
    if(!matrix) return;
    const rows = new Set(matrix.rows || []);
    const cols = new Set(matrix.cols || []);
    const prunedCells = {};
    for(const [cellKey, cellVal] of Object.entries(matrix.cells || {})){
      const [r, c] = String(cellKey).split("::");
      if(rows.has(r) && cols.has(c)) prunedCells[cellKey] = cellVal;
    }
    const prunedRowLabels = {};
    for(const [k, v] of Object.entries(matrix.row_labels || {})){
      if(rows.has(k)) prunedRowLabels[k] = v;
    }
    const prunedColLabels = {};
    for(const [k, v] of Object.entries(matrix.col_labels || {})){
      if(cols.has(k)) prunedColLabels[k] = v;
    }
    const prunedColWidths = {};
    for(const [k, v] of Object.entries(matrix.col_widths || {})){
      if(cols.has(k)) prunedColWidths[k] = v;
    }
    const prunedPrompts = {};
    for(const [k, v] of Object.entries(matrix.cell_prompts || {})){
      const [r, c] = String(k).split("::");
      if(rows.has(r) && cols.has(c)) prunedPrompts[k] = v;
    }
    matrix.cells = prunedCells;
    matrix.row_labels = prunedRowLabels;
    matrix.col_labels = prunedColLabels;
    if(matrix.col_widths) matrix.col_widths = prunedColWidths;
    if(matrix.cell_prompts) matrix.cell_prompts = prunedPrompts;
  }

  function ensureMatrixField(test, fieldKey){
    if(!test || !fieldKey) return { matrix: { rows: [], cols: [], row_labels: {}, col_labels: {}, cells: {} }, schema: null };
    const schema = getMatrixSchema(test, fieldKey);
    const normalized = normalizeMatrixValue(test.data?.[fieldKey], schema);
    if(schema && schema.cell_prompts && (!normalized.cell_prompts || Object.keys(normalized.cell_prompts).length === 0)){
      normalized.cell_prompts = cloneJsonValue(schema.cell_prompts);
    }
    test.data[fieldKey] = normalized;
    if(schema && (!schema.cell_prompts || Object.keys(schema.cell_prompts || {}).length === 0)){
      if(normalized.cell_prompts && Object.keys(normalized.cell_prompts).length){
        schema.cell_prompts = cloneJsonValue(normalized.cell_prompts);
      }
    }
    return { matrix: normalized, schema };
  }

  function showMatrixCellPromptEditor(test, fieldKey, cellKey){
    if(!test || !fieldKey || !cellKey) return;
    if(!test.data._ai) test.data._ai = ensureAiMeta(null, Object.keys(test.data).filter(k => k !== "_ai"));
    if(!test.data._ai.field_schema) test.data._ai.field_schema = {};
    if(!test.data._ai.field_schema[fieldKey]) test.data._ai.field_schema[fieldKey] = {};
    if(!test.data._ai.field_schema[fieldKey].cell_prompts){
      test.data._ai.field_schema[fieldKey].cell_prompts = {};
    }
    const { matrix } = ensureMatrixField(test, fieldKey);
    const [rowId, colId] = String(cellKey).split("::");
    const rowLabel = matrix.row_labels?.[rowId] || rowId || "";
    const colLabel = matrix.col_labels?.[colId] || colId || "";
    const prompts = test.data._ai.field_schema[fieldKey].cell_prompts;
    const current = prompts[cellKey] || "";
    const title = `Cell Prompt: ${rowLabel} × ${colLabel}`;
    showModal(title, (body, footer) => {
      body.innerHTML = `
        <div class="label">Prompt</div>
        <textarea class="input" id="cellPromptInput" rows="4" spellcheck="false" placeholder="Optional guidance for this specific cell.">${escapeHtml(current)}</textarea>
        <div class="hint">Leave blank to clear the cell prompt.</div>
      `;
      footer.innerHTML = `
        <button class="btn" id="cellPromptClose">Close</button>
        <button class="btn primary" id="cellPromptSave">Save</button>
      `;
      const closeBtn = footer.querySelector("#cellPromptClose");
      const saveBtn = footer.querySelector("#cellPromptSave");
      const inputEl = body.querySelector("#cellPromptInput");
      if(closeBtn) closeBtn.addEventListener("click", hideModal);
      if(saveBtn) saveBtn.addEventListener("click", () => {
        if(!inputEl) return;
        const val = inputEl.value.trim();
        const { matrix } = ensureMatrixField(test, fieldKey);
        if(val){
          prompts[cellKey] = val;
          if(!matrix.cell_prompts) matrix.cell_prompts = {};
          matrix.cell_prompts[cellKey] = val;
        }else{
          delete prompts[cellKey];
          if(matrix.cell_prompts) delete matrix.cell_prompts[cellKey];
        }
        test.data[fieldKey] = matrix;
        test.modified = true;
        if(!test._dirtyFields) test._dirtyFields = {};
        test._dirtyFields[fieldKey] = true;
        $("dirtyHint").style.display = "";
        updateSaveAllIndicator();
        renderForm();
        hideModal();
      });
    });
  }

  function matrixCellKey(rowId, colId){
    return `${rowId}::${colId}`;
  }

  function makeMatrixId(label, existingIds){
    const base = String(label || "row").trim().toUpperCase().replace(/[^A-Z0-9]+/g, "_").replace(/^_+|_+$/g, "");
    const existing = new Set(existingIds || []);
    let id = base || "ROW";
    let n = 2;
    while(existing.has(id)){
      id = `${base || "ROW"}_${n}`;
      n += 1;
    }
    return id;
  }

  function buildMatrixWidget(test, fieldKey, locked){
    const { matrix } = ensureMatrixField(test, fieldKey);
    if(!test._matrixView) test._matrixView = {};
    if(!test._matrixView[fieldKey]) test._matrixView[fieldKey] = { scale: 1 };
    const view = test._matrixView[fieldKey];
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const minColWidth = 80;
    if(!matrix.col_widths || typeof matrix.col_widths !== "object") matrix.col_widths = {};

    const wrap = document.createElement("div");
    wrap.className = "matrixWrap";

    const toolbar = document.createElement("div");
    toolbar.className = "matrixToolbar";
    const expandLabel = state.matrixExpanded ? "Collapse" : "Expand";
    toolbar.innerHTML = `
      <button class="btn" data-action="import-csv">Import CSV</button>
      <button class="btn" data-action="export-csv">Export CSV</button>
      <button class="btn" data-action="expand">${expandLabel}</button>
      <span class="matrixZoomControls">
        <button class="btn" data-action="zoom-in">Zoom In</button>
        <button class="btn" data-action="zoom-out">Zoom Out</button>
        <button class="btn" data-action="zoom-reset">Reset</button>
      <span class="tag">Zoom ${Math.round(view.scale * 100)}%</span>
      </span>
      <input class="input matrixSearch" type="search" placeholder="Search BOM…" aria-label="Search matrix" />
      <button class="btn" data-action="search-zoom">Zoom to Matches</button>
    `;
    wrap.appendChild(toolbar);

    const viewport = document.createElement("div");
    viewport.className = "matrixViewport";
    const canvas = document.createElement("div");
    canvas.className = "matrixCanvas";
    canvas.style.transform = `scale(${view.scale})`;

    const table = document.createElement("table");
    table.className = "matrixTable";
    const applyColumnWidths = () => {
      for(const colId of matrix.cols){
        const width = Number(matrix.col_widths?.[colId]);
        if(!width || Number.isNaN(width)) continue;
        const safe = Math.max(minColWidth, Math.round(width));
        const th = table.querySelector(`th[data-col="${cssEscape(colId)}"]`);
        if(th){
          th.style.width = `${safe}px`;
          th.style.minWidth = `${safe}px`;
        }
        table.querySelectorAll(`td[data-col="${cssEscape(colId)}"]`).forEach(td => {
          td.style.width = `${safe}px`;
          td.style.minWidth = `${safe}px`;
        });
        table.querySelectorAll(`input[data-matrix-col="${cssEscape(colId)}"]`).forEach(input => {
          input.style.minWidth = `${safe}px`;
        });
      }
    };
    const headRow = document.createElement("tr");
    const corner = document.createElement("th");
    corner.className = "matrixCorner";
    corner.textContent = "Row";
    headRow.appendChild(corner);
    for(const colId of matrix.cols){
      const th = document.createElement("th");
      th.setAttribute("data-col", colId);
      th.textContent = matrix.col_labels?.[colId] || colId;
      if(matrix.col_widths?.[colId]){
        const safe = Math.max(minColWidth, Math.round(Number(matrix.col_widths[colId])));
        if(Number.isFinite(safe)){
          th.style.width = `${safe}px`;
          th.style.minWidth = `${safe}px`;
        }
      }
      const resizer = document.createElement("div");
      resizer.className = "matrixColResizer";
      resizer.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const startX = e.clientX;
        const startWidth = th.getBoundingClientRect().width || minColWidth;
        const onMove = (evt) => {
          const next = Math.max(minColWidth, Math.round(startWidth + (evt.clientX - startX)));
          matrix.col_widths[colId] = next;
          applyColumnWidths();
        };
        const onUp = () => {
          document.removeEventListener("pointermove", onMove);
          document.removeEventListener("pointerup", onUp);
          requestRerender();
        };
        document.addEventListener("pointermove", onMove);
        document.addEventListener("pointerup", onUp);
      });
      th.appendChild(resizer);
      headRow.appendChild(th);
    }
    table.appendChild(headRow);

    for(const rowId of matrix.rows){
      const tr = document.createElement("tr");
      const rowLabel = document.createElement("td");
      rowLabel.className = "matrixRowLabel";
      rowLabel.setAttribute("data-row", rowId);
      rowLabel.textContent = matrix.row_labels?.[rowId] || rowId;
      tr.appendChild(rowLabel);
      for(const colId of matrix.cols){
        const td = document.createElement("td");
        const input = document.createElement("input");
        input.type = "text";
        input.className = "matrixInput";
        if(locked) input.disabled = true;
        const key = matrixCellKey(rowId, colId);
        input.value = matrix.cells?.[key] ?? "";
        input.setAttribute("data-matrix-field", fieldKey);
        input.setAttribute("data-matrix-cell", key);
        input.setAttribute("data-matrix-col", colId);
        const cellStatus = test._matrixCellStatus?.[fieldKey]?.[key] || "";
        if(cellStatus) input.classList.add(`ai-${cellStatus}`);
        if(test._dirtyMatrixCells?.[fieldKey]?.has(key)) input.classList.add("matrixDirty");
        if(test.data?._ai?.field_schema?.[fieldKey]?.cell_prompts?.[key]) input.classList.add("matrixPrompt");
        td.setAttribute("data-row", rowId);
        td.setAttribute("data-col", colId);
        input.addEventListener("input", () => {
          if(locked) return;
          matrix.cells[key] = input.value;
          if(!test._dirtyMatrixCells) test._dirtyMatrixCells = {};
          if(!test._dirtyMatrixCells[fieldKey]) test._dirtyMatrixCells[fieldKey] = new Set();
          test._dirtyMatrixCells[fieldKey].add(key);
          input.classList.add("matrixDirty");
          test.data[fieldKey] = matrix;
          test.modified = true;
          if(!test._dirtyFields) test._dirtyFields = {};
          test._dirtyFields[fieldKey] = true;
          $("dirtyHint").style.display = "";
          updateSaveAllIndicator();
        });
        input.addEventListener("click", (e) => {
          const clicks = normalizeUiClicks(state.prefs.ui_clicks ?? 4);
          if(e.detail !== clicks) return;
          e.preventDefault();
          e.stopPropagation();
          showMatrixCellPromptEditor(test, fieldKey, key);
        });
        td.appendChild(input);
        tr.appendChild(td);
      }
      table.appendChild(tr);
    }

    applyColumnWidths();
    canvas.appendChild(table);
    viewport.appendChild(canvas);
    wrap.appendChild(viewport);

    const updateZoomTag = () => {
      const tag = toolbar.querySelector(".tag");
      if(tag) tag.textContent = `Zoom ${Math.round(view.scale * 100)}%`;
      canvas.style.transform = `scale(${view.scale})`;
    };

    const applyMatrixSearch = (query) => {
      const term = String(query || "").trim().toLowerCase();
      const inputs = table.querySelectorAll(".matrixInput");
      if(!term){
        inputs.forEach(input => input.classList.remove("matrixMatch"));
        view.searchBounds = null;
        return;
      }
      const matches = [];
      inputs.forEach(input => {
        const cellKey = input.getAttribute("data-matrix-cell") || "";
        const [rowId, colId] = cellKey.split("::");
        const rowLabel = (matrix.row_labels?.[rowId] || rowId || "").toLowerCase();
        const colLabel = (matrix.col_labels?.[colId] || colId || "").toLowerCase();
        const val = String(input.value || "").toLowerCase();
        const hit = val.includes(term) || rowLabel.includes(term) || colLabel.includes(term);
        input.classList.toggle("matrixMatch", !!hit);
        if(hit) matches.push(input);
      });
      if(!matches.length){
        view.searchBounds = null;
        return;
      }
      const canvasRect = canvas.getBoundingClientRect();
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      matches.forEach(input => {
        const r = input.getBoundingClientRect();
        const x = (r.left - canvasRect.left) / view.scale;
        const y = (r.top - canvasRect.top) / view.scale;
        const w = r.width / view.scale;
        const h = r.height / view.scale;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + w);
        maxY = Math.max(maxY, y + h);
      });
      view.searchBounds = { minX, minY, maxX, maxY };
    };

    const requestRerender = () => {
      test.modified = true;
      if(!test._dirtyFields) test._dirtyFields = {};
      test._dirtyFields[fieldKey] = true;
      $("dirtyHint").style.display = "";
      updateSaveAllIndicator();
      renderForm();
      renderTestsList();
    };

    const insertRowAt = (idx, label) => {
      const id = makeMatrixId(label, matrix.rows);
      matrix.rows.splice(idx, 0, id);
      matrix.row_labels[id] = label;
      for(const colId of matrix.cols){
        const key = matrixCellKey(id, colId);
        if(!(key in matrix.cells)) matrix.cells[key] = "";
      }
    };
    const insertColAt = (idx, label) => {
      const id = makeMatrixId(label, matrix.cols);
      matrix.cols.splice(idx, 0, id);
      matrix.col_labels[id] = label;
      if(!matrix.col_widths || typeof matrix.col_widths !== "object") matrix.col_widths = {};
      if(!(id in matrix.col_widths)) matrix.col_widths[id] = 140;
      for(const rowId of matrix.rows){
        const key = matrixCellKey(rowId, id);
        if(!(key in matrix.cells)) matrix.cells[key] = "";
      }
    };
    const deleteRow = (rowId) => {
      matrix.rows = matrix.rows.filter(r => r !== rowId);
      if(matrix.row_labels) delete matrix.row_labels[rowId];
      for(const colId of matrix.cols){
        const key = matrixCellKey(rowId, colId);
        if(matrix.cells) delete matrix.cells[key];
      }
    };
    const deleteCol = (colId) => {
      matrix.cols = matrix.cols.filter(c => c !== colId);
      if(matrix.col_labels) delete matrix.col_labels[colId];
      if(matrix.col_widths) delete matrix.col_widths[colId];
      for(const rowId of matrix.rows){
        const key = matrixCellKey(rowId, colId);
        if(matrix.cells) delete matrix.cells[key];
      }
    };

    const showMatrixControls = state.prefs.bom_matrix_controls !== false;
    const zoomControls = toolbar.querySelector(".matrixZoomControls");
    if(zoomControls) zoomControls.style.display = showMatrixControls ? "" : "none";

    toolbar.querySelectorAll("button").forEach(btn => {
      const action = btn.getAttribute("data-action");
      btn.addEventListener("click", () => {
        if(action === "expand"){
          state.matrixExpanded = !state.matrixExpanded;
          const grid = document.querySelector(".gridEditor");
          if(grid) grid.classList.toggle("matrixExpanded", state.matrixExpanded);
          renderForm();
          return;
        }
        if(action === "import-csv"){
          if(locked) return;
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".csv,.tsv,text/csv,text/tab-separated-values";
          input.onchange = async () => {
            const file = input.files?.[0];
            if(!file) return;
            try{
              const text = await file.text();
              const parsed = parseDelimitedTable(text);
              if(parsed.headers.length < 1 || parsed.rows.length < 1){
                toast("Matrix CSV", "CSV must include a header row and at least one data row.", "warn");
                return;
              }
              const cols = parsed.headers.map(h => ({ id: makeMatrixId(h, []), label: h }));
              const rows = parsed.rows.map(r => ({ id: makeMatrixId(r.label, []), label: r.label }));
              const rowLabels = rows.reduce((acc, r) => { acc[r.id] = r.label; return acc; }, {});
              const colLabels = cols.reduce((acc, c) => { acc[c.id] = c.label; return acc; }, {});
              const cells = {};
              parsed.rows.forEach((r, rIdx) => {
                cols.forEach((c, cIdx) => {
                  const value = r.values[cIdx] ?? "";
                  const key = matrixCellKey(rows[rIdx].id, c.id);
                  cells[key] = value;
                });
              });
              matrix.rows = rows.map(r => r.id);
              matrix.cols = cols.map(c => c.id);
              matrix.row_labels = rowLabels;
              matrix.col_labels = colLabels;
              matrix.cells = cells;
              if(!test.data._ai.field_schema) test.data._ai.field_schema = {};
              test.data._ai.field_schema[fieldKey] = { rows, cols };
              requestRerender();
              toast("Matrix CSV", `Imported ${rows.length} row(s) × ${cols.length} column(s).`, "ok");
            }catch(err){
              toast("Matrix CSV", err.message || "Failed to import CSV.", "warn");
            }
          };
          input.click();
          return;
        }
        if(action === "export-csv"){
          const header = ["Row", ...matrix.cols.map(c => matrix.col_labels?.[c] || c)];
          const lines = [header];
          for(const rowId of matrix.rows){
            const rowLabel = matrix.row_labels?.[rowId] || rowId;
            const rowVals = matrix.cols.map(colId => {
              const key = matrixCellKey(rowId, colId);
              return matrix.cells?.[key] ?? "";
            });
            lines.push([rowLabel, ...rowVals]);
          }
          const csv = lines
            .map(cols => cols.map(val => {
              const s = String(val ?? "");
              if(/[",\r\n]/.test(s)) return `"${s.replace(/"/g, "\"\"")}"`;
              return s;
            }).join(","))
            .join("\r\n");
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          const base = String(test.data?.section_no || "matrix").replace(/[^\w\-]+/g, "_");
          a.href = url;
          a.download = `${base}_${fieldKey}.csv`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          return;
        }
        if(action === "zoom-in"){
          view.scale = clamp(view.scale * 1.1, 0.4, 2.5);
          updateZoomTag();
          return;
        }
        if(action === "zoom-out"){
          view.scale = clamp(view.scale / 1.1, 0.4, 2.5);
          updateZoomTag();
          return;
        }
        if(action === "zoom-reset"){
          view.scale = 1;
          updateZoomTag();
          return;
        }
        if(action === "search-zoom"){
          if(!view.searchBounds){
            toast("Matrix Search", "No matches to zoom.", "warn");
            return;
          }
          const pad = 24;
          const { minX, minY, maxX, maxY } = view.searchBounds;
          const boundsW = Math.max(1, maxX - minX);
          const boundsH = Math.max(1, maxY - minY);
          const viewportW = viewport.clientWidth;
          const viewportH = viewport.clientHeight;
          const scale = clamp(Math.min(
            (viewportW - pad * 2) / boundsW,
            (viewportH - pad * 2) / boundsH
          ), 0.4, 2.5);
          view.scale = scale;
          updateZoomTag();
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          viewport.scrollLeft = Math.max(0, centerX * view.scale - viewportW / 2);
          viewport.scrollTop = Math.max(0, centerY * view.scale - viewportH / 2);
          return;
        }
      });
    });
    const searchInput = toolbar.querySelector(".matrixSearch");
    if(searchInput){
      searchInput.addEventListener("input", () => applyMatrixSearch(searchInput.value));
    }

    viewport.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      if(locked) return;
      const rowEl = e.target.closest("[data-row]");
      const colEl = e.target.closest("[data-col]");
      const rowId = rowEl?.getAttribute("data-row") || "";
      const colId = colEl?.getAttribute("data-col") || "";
      const rowIdx = rowId ? matrix.rows.indexOf(rowId) : -1;
      const colIdx = colId ? matrix.cols.indexOf(colId) : -1;
      const items = [
        {
          id: "insert_row_before",
          label: "Insert Row Before",
          onClick: () => {
            if(rowIdx < 0) return;
            const label = prompt("Row label");
            if(!label) return;
            insertRowAt(rowIdx, label);
            requestRerender();
          }
        },
        {
          id: "insert_row_after",
          label: "Insert Row After",
          onClick: () => {
            if(rowIdx < 0) return;
            const label = prompt("Row label");
            if(!label) return;
            insertRowAt(rowIdx + 1, label);
            requestRerender();
          }
        },
        {
          id: "insert_col_before",
          label: "Insert Column Before",
          onClick: () => {
            if(colIdx < 0) return;
            const label = prompt("Column label");
            if(!label) return;
            insertColAt(colIdx, label);
            requestRerender();
          }
        },
        {
          id: "insert_col_after",
          label: "Insert Column After",
          onClick: () => {
            if(colIdx < 0) return;
            const label = prompt("Column label");
            if(!label) return;
            insertColAt(colIdx + 1, label);
            requestRerender();
          }
        },
        {
          id: "delete_row",
          label: "Delete Row",
          onClick: () => {
            if(rowIdx < 0) return;
            if(!confirm(`Delete row "${matrix.row_labels?.[rowId] || rowId}"?`)) return;
            deleteRow(rowId);
            requestRerender();
          }
        },
        {
          id: "delete_col",
          label: "Delete Column",
          onClick: () => {
            if(colIdx < 0) return;
            if(!confirm(`Delete column "${matrix.col_labels?.[colId] || colId}"?`)) return;
            deleteCol(colId);
            requestRerender();
          }
        }
      ];
      showContextMenu(e.clientX, e.clientY, items);
    });

    let dragging = false;
    let startX = 0;
    let startY = 0;
    let startScrollLeft = 0;
    let startScrollTop = 0;
    viewport.addEventListener("mousedown", (e) => {
      const allowPan = e.button === 1 || (e.button === 0 && state.matrixPanKey);
      if(!allowPan) return;
      dragging = true;
      viewport.classList.add("dragging");
      startX = e.clientX;
      startY = e.clientY;
      startScrollLeft = viewport.scrollLeft;
      startScrollTop = viewport.scrollTop;
      e.preventDefault();
    });
    window.addEventListener("mousemove", (e) => {
      if(!dragging) return;
      viewport.scrollLeft = startScrollLeft - (e.clientX - startX);
      viewport.scrollTop = startScrollTop - (e.clientY - startY);
    });
    window.addEventListener("mouseup", () => {
      if(!dragging) return;
      dragging = false;
      viewport.classList.remove("dragging");
    });
    viewport.addEventListener("wheel", (e) => {
      if(!e.ctrlKey) return;
      e.preventDefault();
      const delta = e.deltaY < 0 ? 1.1 : 0.9;
      view.scale = clamp(view.scale * delta, 0.4, 2.5);
      updateZoomTag();
    }, { passive: false });

    const hint = document.createElement("div");
    hint.className = "matrixHint";
    hint.textContent = "Tip: Ctrl + wheel to zoom, middle mouse or Space + drag to pan.";
    wrap.appendChild(hint);

    return wrap;
  }

  function parseDelimitedTable(raw){
    const text = String(raw || "").trim();
    if(!text) return { headers: [], rows: [] };
    const lines = text.split(/\r?\n/).filter(line => line.trim().length);
    if(!lines.length) return { headers: [], rows: [] };
    const sample = lines.slice(0, 3).join("\n");
    const commaCount = (sample.match(/,/g) || []).length;
    const tabCount = (sample.match(/\t/g) || []).length;
    const delim = tabCount > commaCount ? "\t" : ",";
    const parseLine = (line) => {
      const out = [];
      let cur = "";
      let inQuotes = false;
      for(let i = 0; i < line.length; i += 1){
        const ch = line[i];
        if(ch === "\""){
          if(inQuotes && line[i + 1] === "\""){ cur += "\""; i += 1; }
          else inQuotes = !inQuotes;
        }else if(ch === delim && !inQuotes){
          out.push(cur.trim());
          cur = "";
        }else{
          cur += ch;
        }
      }
      out.push(cur.trim());
      return out;
    };
    const headerCells = parseLine(lines[0]).slice(1);
    const headers = headerCells.map(h => h || "Column");
    const rows = lines.slice(1).map(line => {
      const cells = parseLine(line);
      const label = cells[0] || "Row";
      return { label, values: cells.slice(1) };
    });
    return { headers, rows };
  }

  function renderForm(){
    const test = currentTest();
    const plan = state.currentPlan;
    const grid = $("formGrid");
    grid.innerHTML = "";

    if(!test){
      $("editorSub").textContent = "No test selected";
      $("dirtyHint").style.display = "none";
      return;
    }

    updateSaveAllIndicator();

    const tmplSub = $("templateEditSub");
    if(state.currentTestTemplate){
      $("editorSub").textContent = "";
      if(tmplSub){
        const tname = String(state.currentTestTemplate.name || "").trim();
        tmplSub.textContent = /^todo:/i.test(tname) ? "Template editing" : `Template: ${tname}`;
        tmplSub.style.display = "";
      }
    }else{
      $("editorSub").textContent = "";
      if(tmplSub) tmplSub.style.display = "none";
    }
    $("dirtyHint").style.display = test.modified ? "" : "none";
    const newBtn = $("btnNewTest");
    if(newBtn) newBtn.textContent = state.currentTestTemplate ? "Tests" : "New List Item";
    const tmplBtn = $("btnManageTestTemplates");
    if(tmplBtn){
      tmplBtn.disabled = !!state.currentTestTemplate;
      tmplBtn.title = state.currentTestTemplate ? "Already editing templates" : "";
    }
    updateSaveAllIndicator();

    const fields = getFieldKeys(test);
    const computeRpn = () => {
      const s = Number(test.data.severity || "");
      const o = Number(test.data.occurrence || "");
      const d = Number(test.data.detection || "");
      if(!Number.isFinite(s) || !Number.isFinite(o) || !Number.isFinite(d)) return "";
      if(s <= 0 || o <= 0 || d <= 0) return "";
      return String(Math.round(s * o * d));
    };
    for(const k of fields){
      if(["param1_label","param1_value","param2_label","param2_value"].includes(k)) continue;
      if(state.matrixExpanded && ["section_title","section_no","section_type"].includes(k)) continue;
      let type = String(test.data?._ai?.field_types?.[k] || "text").toLowerCase();
      if(type.includes("textarea") || type.includes("multi")) type = "textarea";
        const isSelect = type.includes("select");
        const isComputed = type.includes("computed") || k === "rpn";
        const isMatrix = type.includes("matrix");
        const isTextArea = type === "textarea";
        if(!isSelect && !isComputed && !isTextArea && !isMatrix) type = "text";
      const full = isTextArea || isMatrix;

      const cell = document.createElement("div");
      cell.className = full ? "full" : "";
      cell.setAttribute("data-field", k);

      const head = document.createElement("div");
      head.className = "fieldHead";
      const LABEL_OVERRIDES = {
        section_no: "Test No",
        section_title: "Test Name",
        uut_pn: "UUT P/N",
        last_section_no: "Last Test No",
        section_type: "Test Type",
        test_equipment: "Test Equipment",
        purpose: "Purpose",
        scope: "Scope",
        setup: "Setup",
        procedure: "Procedure",
        measurement: "Measurement",
        parameter: "Parameter",
        ll: "Lower Limit (ll)",
        tv: "Target Value (tv)",
        ul: "Upper Limit (ul)",
        units: "Units",
        in_tol_conclusion: "In-Tol Conclusion",
        in_tol_next_step: "In-Tol Next Step",
        oot_low_conclusion: "OOT Low Conclusion",
        oot_low_unable_adjust: "OOT Low Unable to Adjust Conclusion",
        oot_low_next_step: "OOT Low Next Step",
        oot_high_conclusion: "OOT High Conclusion",
        oot_high_unable_adjust: "OOT High Unable to Adjust Conclusion",
        oot_high_next_step: "OOT High Next Step"
      };
      const labelText = (test.data?._ai?.field_labels?.[k] || LABEL_OVERRIDES[k] || k);
        const maturity = getFieldMaturity(test, k);
      head.innerHTML = `
          <div class="label" data-field="${escapeHtml(k)}">${escapeHtml(labelText)}</div>
          <span class="tag" data-maturity="${k}" title="${escapeHtml(maturityDescription(maturity))}">M${maturity}</span>
        `;
      const maturityTag = head.querySelector(`[data-maturity="${k}"]`);
      if(test._dirtyFields?.[`_ai.maturity.${k}`]) maturityTag.classList.add("maturity-dirty");
      if(state.matrixExpanded) head.style.display = "none";
      const locked = Number(maturity) >= 4 || isComputed;
      const dragEnabled = isTestEditorUnlocked();
      if(dragEnabled){
        head.classList.add("drag-handle");
        head.setAttribute("draggable", "true");
      }

      const labelEl = head.querySelector(`[data-field]`);
      if(labelEl){
        labelEl.addEventListener("click", (e) => {
          const clicks = normalizeUiClicks(state.prefs.ui_clicks ?? 4);
          if(e.detail !== clicks) return;
          e.preventDefault();
          runAsync(editFieldMetaFlow(k));
        });
      }

      if(isMatrix){
        const matrixControl = buildMatrixWidget(test, k, locked);
        cell.appendChild(head);
        cell.appendChild(matrixControl);
        grid.appendChild(cell);
        continue;
      }

      const input = document.createElement(isTextArea ? "textarea" : "input");
      const isParamValue = (k === "param1_value" || k === "param2_value");
      let control = input;
      if(isParamValue){
        const select = document.createElement("select");
        select.className = "select";
        const keysForValues = getFieldKeys(test).filter(key =>
          !["_ai","param1_label","param1_value","param2_label","param2_value"].includes(key)
        );
        select.innerHTML = keysForValues.map(key => {
          const lbl = test.data?._ai?.field_labels?.[key] || key;
          return `<option value="${escapeHtml(key)}">${escapeHtml(lbl)}</option>`;
        }).join("");
        control = select;
      }else if(isSelect){
        const select = document.createElement("select");
        select.className = "select";
        const options = Array.isArray(test.data?._ai?.field_options?.[k]) && test.data._ai.field_options[k].length
          ? test.data._ai.field_options[k]
          : (["severity","occurrence","detection"].includes(k) ? ["1","2","3","4","5","6","7","8","9","10"] : []);
        const optionHtml = [`<option value="">—</option>`].concat(
          options.map(v => `<option value="${escapeHtml(String(v))}">${escapeHtml(String(v))}</option>`)
        ).join("");
        select.innerHTML = optionHtml;
        control = select;
      }else{
        control.className = "input";
        if(!isTextArea) control.type = "text";
      }
      control.value = isComputed ? computeRpn() : (test.data[k] ?? "");
      control.setAttribute("data-field", k);

        const s = getSuggestStatus(test.id, k);
        if(s) input.classList.add(`ai-${s}`);
        if(test._dirtyFields?.[k]) control.classList.add("dirty-field");
        if(locked){
          control.disabled = true;
          control.classList.add("locked-field");
          control.title = isComputed ? "Auto-computed" : "Locked (M4)";
        }

        const handleChange = () => {
          test.data[k] = control.value;
          test.modified = true;
          if(!test._dirtyFields) test._dirtyFields = {};
          test._dirtyFields[k] = true;
          control.classList.add("dirty-field");
          $("dirtyHint").style.display = "";
          updateSaveAllIndicator();
          setSuggestStatus(test.id, k, "");
          setFieldMaturity(test, k, 3);
          if(maturityTag) maturityTag.textContent = "M3";
          if(["severity","occurrence","detection"].includes(k)){
            const nextRpn = computeRpn();
            if("rpn" in test.data){
              test.data.rpn = nextRpn;
              test.modified = true;
              test._dirtyFields["rpn"] = true;
              setFieldMaturity(test, "rpn", 4);
            }
          }
          renderTestsList();
          renderForm();
        };
        if(!locked){
          control.addEventListener("input", handleChange);
          control.addEventListener("change", handleChange);
        }
        const handlePersonalityClick = (e) => {
          if(!state.prefs.ai_personality_dialog) return;
          if(e && typeof e.preventDefault === "function") e.preventDefault();
          if(e && typeof e.stopPropagation === "function") e.stopPropagation();
          openPersonalityDialog(test, k);
        };
        control.addEventListener("click", (e) => {
          const clicks = normalizeUiClicks(state.prefs.ui_clicks ?? 4);
          if(e.detail !== clicks) return;
          handlePersonalityClick(e);
        });
        control.addEventListener("focus", () => {
          state.focusField = k;
        });

      if(!test._selectedFields) test._selectedFields = new Set();
      if(test._selectedFields.has(k)) cell.classList.add("fieldSelected");
      cell.addEventListener("click", (e) => {
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
        if(tag === "input" || tag === "textarea" || tag === "select") return;
        const multi = e.ctrlKey || e.metaKey;
        const range = e.shiftKey;
        const onHeaderControl = e.target && (e.target.closest("[data-maturity]") || e.target.closest("[data-field]"));
        if(onHeaderControl && !(multi || range)) return;
        if(onHeaderControl && (multi || range)){
          if(e.stopPropagation) e.stopPropagation();
          if(e.preventDefault) e.preventDefault();
        }
        const keysInOrder = getFieldKeys(test).filter(key => !["_ai","param1_label","param1_value","param2_label","param2_value"].includes(key));
        if(!test._lastSelectedField) test._lastSelectedField = k;
        if(range){
          const a = keysInOrder.indexOf(test._lastSelectedField);
          const b = keysInOrder.indexOf(k);
          if(a >= 0 && b >= 0){
            const [start, end] = a < b ? [a, b] : [b, a];
            if(!multi) test._selectedFields.clear();
            for(const key of keysInOrder.slice(start, end + 1)) test._selectedFields.add(key);
          }
        }else{
          if(!multi) test._selectedFields.clear();
          if(test._selectedFields.has(k)) test._selectedFields.delete(k);
          else test._selectedFields.add(k);
          test._lastSelectedField = k;
        }
        renderForm();
      });

      cell.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        state.focusField = k;
      const selected = test._selectedFields ? Array.from(test._selectedFields) : [];
      const items = [
        {
          id: "add_after",
          label: "Add Field After",
          onClick: () => runAsync(addFieldFlow(k, "after"))
        },
        {
          id: "add_before",
          label: "Add Field Before",
          onClick: () => runAsync(addFieldFlow(k, "before"))
        },
        ...(selected.length ? [{
          id: "clear_selected",
          label: "Clear Selection",
          onClick: () => { test._selectedFields.clear(); renderForm(); }
        }] : []),
        ...(selected.length > 1 ? [{
          id: "delete_selected",
          label: `Delete Selected (${selected.length})`,
          onClick: () => deleteFieldsByKeys(test, selected)
        }] : []),
        {
          id: "delete_field",
          label: "Delete Field",
          onClick: () => deleteFieldByKey(test, k)
        },
          {
            id: "save_test",
            label: "Save Test",
            onClick: () => runAsync(saveCurrentTest())
          },
          {
            id: "ai_suggest_field",
            label: "AI Suggest this Field",
            onClick: () => aiSuggestFocusedField(k)
          }
        ];
          showContextMenu(e.clientX, e.clientY, items);
        });
        cell.addEventListener("dblclick", (e) => {
          if(!state.prefs.ai_personality_dialog) return;
          const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
          if(tag === "input" || tag === "textarea" || tag === "select"){
            handlePersonalityClick(e);
          }
        });

      if(dragEnabled){
        head.addEventListener("dragstart", (e) => {
          e.dataTransfer?.setData("text/plain", k);
          head.classList.add("dragging");
        });
        head.addEventListener("dragend", () => {
          head.classList.remove("dragging");
          grid.querySelectorAll(".drag-target").forEach(el => el.classList.remove("drag-target"));
        });
        cell.addEventListener("dragover", (e) => {
          e.preventDefault();
          cell.classList.add("drag-target");
        });
        cell.addEventListener("dragleave", () => {
          cell.classList.remove("drag-target");
        });
        cell.addEventListener("drop", (e) => {
          e.preventDefault();
          cell.classList.remove("drag-target");
          const fromKey = e.dataTransfer?.getData("text/plain") || "";
          const toKey = cell.getAttribute("data-field") || "";
          if(!fromKey || !toKey || fromKey === toKey) return;
          reorderFieldByKey(test, fromKey, toKey);
          $("dirtyHint").style.display = "";
          renderForm();
        });
      }

      cell.appendChild(head);
      cell.appendChild(control);
      grid.appendChild(cell);
      }

      grid.querySelectorAll("[data-maturity]").forEach(el => {
        el.addEventListener("click", () => {
          const field = el.getAttribute("data-maturity");
          const clicks = normalizeMaturityClicks(state.prefs.ai_maturity_clicks ?? 4);
          if(clicks === 2){
            openMaturityQuick(test, field, el);
          }else{
            openMaturityDialog(test, field);
          }
        });
      });
    }

  /* ---------- Flowchart (placeholder skeleton) ---------- */
  function applyFlowTransform(){
    const svg = $("flowSvg");
    const g = svg?.querySelector("#flowViewport");
    if(!g) return;
    g.setAttribute("transform", `translate(${state.flow.x} ${state.flow.y}) scale(${state.flow.scale})`);
  }

  function insertFieldAfter(test, afterKey, newKey, value){
    const data = test.data || {};
    const keys = Object.keys(data).filter(k => k !== "_ai");
    const out = {};
    let inserted = false;
    if(keys.length){
      for(const k of keys){
        out[k] = data[k];
        if(afterKey && k === afterKey){
          out[newKey] = value;
          inserted = true;
        }
      }
    }
    if(!inserted) out[newKey] = value;
    out._ai = data._ai || ensureAiMeta(null, Object.keys(out).filter(k => k !== "_ai"));
    return out;
  }

  function reorderFieldByKey(test, fromKey, toKey){
    if(!test || !fromKey || !toKey || fromKey === toKey) return;
    const data = test.data || {};
    const keys = Object.keys(data).filter(k => k !== "_ai");
    if(!keys.includes(fromKey) || !keys.includes(toKey)) return;
    const nextKeys = keys.filter(k => k !== fromKey);
    const idx = nextKeys.indexOf(toKey);
    nextKeys.splice(Math.max(idx, 0), 0, fromKey);
    const next = {};
    for(const k of nextKeys) next[k] = data[k];
    next._ai = data._ai || ensureAiMeta(null, Object.keys(next).filter(k => k !== "_ai"));
    test.data = next;
    test.modified = true;
    if(!test._dirtyFields) test._dirtyFields = {};
    test._dirtyFields[fromKey] = true;
  }

  function insertFieldBefore(test, beforeKey, newKey, value){
    const data = test.data || {};
    const keys = Object.keys(data).filter(k => k !== "_ai");
    const out = {};
    let inserted = false;
    if(keys.length){
      for(const k of keys){
        if(beforeKey && k === beforeKey && !inserted){
          out[newKey] = value;
          inserted = true;
        }
        out[k] = data[k];
      }
    }
    if(!inserted) out[newKey] = value;
    out._ai = data._ai || ensureAiMeta(null, Object.keys(out).filter(k => k !== "_ai"));
    return out;
  }

  async function addFieldFlow(anchorKey = "", position = "after"){
    const test = currentTest();
    if(!test) return;

    showModal("Add Field", (body, footer) => {
      body.innerHTML = `
        <div class="label">Form Label</div>
        <input class="input" id="newFieldLabel" placeholder="Field Label" />
        <div class="hr"></div>
        <div class="label">Data Label (JSON key)</div>
        <input class="input" id="newFieldName" placeholder="field_name" />
        <div class="hr"></div>
        <div class="label">Field Type</div>
        <select class="select" id="newFieldType">
          <option value="text">Text (single line)</option>
          <option value="textarea">Text (multi-line)</option>
          <option value="matrix">Matrix (table)</option>
        </select>
        <div class="hr"></div>
        <div class="label">Field Prompt (AI guidance)</div>
        <textarea class="input" id="newFieldPrompt" spellcheck="false"></textarea>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelAddField">Cancel</button>
        <button class="btn primary" id="confirmAddField">Add Field</button>
      `;
      $("cancelAddField").onclick = hideModal;
      $("confirmAddField").onclick = () => {
        const label = $("newFieldLabel").value.trim();
        const name = $("newFieldName").value.trim();
        const prompt = $("newFieldPrompt").value.trim();
        if(!name){ toast("Missing name", "Enter a data label.", "warn"); return; }
        if(test.data[name] !== undefined){
          toast("Duplicate field", "That field already exists.", "warn");
          return;
        }
        const type = $("newFieldType").value || "text";
        const anchor = anchorKey || state.focusField || "";
        const value = type === "matrix"
          ? { rows: [], cols: [], row_labels: {}, col_labels: {}, cells: {} }
          : "";
        if(position === "before") test.data = insertFieldBefore(test, anchor, name, value);
        else test.data = insertFieldAfter(test, anchor, name, value);
        if(!test.data._ai) test.data._ai = ensureAiMeta(null, Object.keys(test.data).filter(k => k !== "_ai"));
        if(!test.data._ai.maturity) test.data._ai.maturity = {};
        test.data._ai.maturity[name] = 0;
        if(!test.data._ai.field_labels) test.data._ai.field_labels = {};
        test.data._ai.field_labels[name] = label || name;
        if(!test.data._ai.field_prompts) test.data._ai.field_prompts = {};
        test.data._ai.field_prompts[name] = prompt;
          if(!test.data._ai.field_types) test.data._ai.field_types = {};
          test.data._ai.field_types[name] = type;
          if(type === "matrix"){
            if(!test.data._ai.field_schema) test.data._ai.field_schema = {};
            if(!test.data._ai.field_schema[name]) test.data._ai.field_schema[name] = { rows: [], cols: [] };
          }
          if(!test.data._ai.review_personalities || typeof test.data._ai.review_personalities !== "object"){
            test.data._ai.review_personalities = buildDefaultReviewPersonalities(Object.keys(test.data).filter(k => k !== "_ai"), getPlanReviewPersonas(state.currentPlan));
          }
          for(const persona of Object.values(test.data._ai.review_personalities)){
            if(!persona.field_comments || typeof persona.field_comments !== "object") persona.field_comments = {};
            if(!(name in persona.field_comments)) persona.field_comments[name] = "";
          }
          test.modified = true;
        if(!test._dirtyFields) test._dirtyFields = {};
        test._dirtyFields[name] = true;
        state.focusField = name;
        hideModal();
        renderForm();
        renderTestsList();
      };
      setTimeout(() => $("newFieldLabel").focus(), 20);
    });
  }

  function deleteFieldByKey(test, fieldKey){
    if(!test || !fieldKey) return;
    const data = test.data || {};
    if(!(fieldKey in data)) return;
    showModal("Delete Field", (body2, footer2) => {
      body2.innerHTML = `
        <div class="muted" style="line-height:1.4;">
          Delete <span class="tag">${escapeHtml(fieldKey)}</span>? This removes the field from the test data and AI metadata.
        </div>
      `;
      footer2.innerHTML = `
        <button class="btn" id="cancelDeleteField">Cancel</button>
        <button class="btn danger" id="confirmDeleteField">Delete</button>
      `;
      $("cancelDeleteField").onclick = hideModal;
      $("confirmDeleteField").onclick = () => {
        const next = {};
        const keys = Object.keys(data).filter(k => k !== "_ai");
        for(const k of keys){
          if(k !== fieldKey) next[k] = data[k];
        }
        next._ai = data._ai || ensureAiMeta(null, Object.keys(next).filter(k => k !== "_ai"));
          if(next._ai?.maturity) delete next._ai.maturity[fieldKey];
          if(next._ai?.field_labels) delete next._ai.field_labels[fieldKey];
          if(next._ai?.field_types) delete next._ai.field_types[fieldKey];
          if(next._ai?.field_prompts) delete next._ai.field_prompts[fieldKey];
          if(next._ai?.field_schema) delete next._ai.field_schema[fieldKey];
          if(next._ai?.review_personalities && typeof next._ai.review_personalities === "object"){
            for(const persona of Object.values(next._ai.review_personalities)){
              if(persona?.field_comments) delete persona.field_comments[fieldKey];
            }
          }
          test.data = next;
        test.modified = true;
        if(test._dirtyFields) delete test._dirtyFields[fieldKey];
        hideModal();
        renderForm();
        renderTestsList();
      };
    });
  }

  function deleteFieldsByKeys(test, fieldKeys){
    if(!test || !Array.isArray(fieldKeys) || !fieldKeys.length) return;
    const data = test.data || {};
    const keys = fieldKeys.filter(k => k && k in data);
    if(!keys.length) return;
    showModal("Delete Fields", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.4;">
          Delete ${keys.length} field(s)?
          <div style="margin-top:8px; font-size:11px; color:var(--muted);">${escapeHtml(keys.join(", "))}</div>
        </div>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelDeleteFields">Cancel</button>
        <button class="btn danger" id="confirmDeleteFields">Delete</button>
      `;
      $("cancelDeleteFields").onclick = hideModal;
      $("confirmDeleteFields").onclick = () => {
        const next = {};
        const all = Object.keys(data).filter(k => k !== "_ai");
        for(const k of all){
          if(!keys.includes(k)) next[k] = data[k];
        }
        next._ai = data._ai || ensureAiMeta(null, Object.keys(next).filter(k => k !== "_ai"));
        for(const k of keys){
          if(next._ai?.maturity) delete next._ai.maturity[k];
          if(next._ai?.field_labels) delete next._ai.field_labels[k];
          if(next._ai?.field_types) delete next._ai.field_types[k];
          if(next._ai?.field_prompts) delete next._ai.field_prompts[k];
          if(next._ai?.field_schema) delete next._ai.field_schema[k];
          if(next._ai?.review_personalities && typeof next._ai.review_personalities === "object"){
            for(const persona of Object.values(next._ai.review_personalities)){
              if(persona?.field_comments) delete persona.field_comments[k];
            }
          }
        }
        test.data = next;
        test.modified = true;
        if(test._dirtyFields){
          for(const k of keys) delete test._dirtyFields[k];
        }
        if(test._selectedFields){
          for(const k of keys) test._selectedFields.delete(k);
        }
        hideModal();
        renderForm();
        renderTestsList();
      };
    });
  }

  function openParamEditDialog(test, which){
    if(!test || !test.data) return;
    const labelKey = which === 2 ? "param2_label" : "param1_label";
    const valueKey = which === 2 ? "param2_value" : "param1_value";
    const defaultLabel = which === 2 ? "Target Value" : "Units";
    const defaultValue = which === 2 ? "tv" : "units";
    const currentLabel = String(test.data[labelKey] ?? defaultLabel);
    const currentValue = String(test.data[valueKey] ?? defaultValue);
    const keysForValues = getFieldKeys(test).filter(key =>
      !["_ai","param1_label","param1_value","param2_label","param2_value"].includes(key)
    );
    if(!keysForValues.includes(currentValue)) keysForValues.unshift(currentValue);

    showModal(which === 2 ? "Edit Parameter 2" : "Edit Parameter 1", (body, footer) => {
      const options = keysForValues.map(key => {
        const lbl = test.data?._ai?.field_labels?.[key] || key;
        const selected = key === currentValue ? " selected" : "";
        return `<option value="${escapeHtml(key)}"${selected}>${escapeHtml(lbl)}</option>`;
      }).join("");
      body.innerHTML = `
        <div class="label">Label</div>
        <input class="input" id="paramEditLabel" value="${escapeHtml(currentLabel)}" />
        <div class="hr"></div>
        <div class="label">Value Source</div>
        <select class="select" id="paramEditValue">${options}</select>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelParamEdit">Cancel</button>
        <button class="btn primary" id="confirmParamEdit">Save</button>
      `;
      $("cancelParamEdit").onclick = hideModal;
      $("confirmParamEdit").onclick = () => {
        const newLabel = $("paramEditLabel").value.trim();
        const newValue = $("paramEditValue").value || defaultValue;
        test.data[labelKey] = newLabel;
        test.data[valueKey] = newValue;
        setFieldMaturity(test, labelKey, 3);
        setFieldMaturity(test, valueKey, 3);
        test.modified = true;
        if(!test._dirtyFields) test._dirtyFields = {};
        test._dirtyFields[labelKey] = true;
        test._dirtyFields[valueKey] = true;
        hideModal();
        renderTestsList();
        if(state.currentTestId === test.id) renderEditor();
      };
      setTimeout(() => $("paramEditLabel").focus(), 20);
    });
  }

  async function editFieldMetaFlow(fieldKey){
    const test = currentTest();
    if(!test || !fieldKey) return;

    showModal("Edit Field", (body, footer) => {
      const currentLabel = test.data?._ai?.field_labels?.[fieldKey] || fieldKey;
      const currentType = test.data?._ai?.field_types?.[fieldKey] || "text";
      const currentPrompt = test.data?._ai?.field_prompts?.[fieldKey] || "";
      body.innerHTML = `
        <div class="label">Form Label</div>
        <input class="input" id="editFieldLabel" value="${escapeHtml(currentLabel)}" />
        <div class="hr"></div>
        <div class="label">Data Label (JSON key)</div>
        <input class="input" id="editFieldKey" value="${escapeHtml(fieldKey)}" />
        <div class="hr"></div>
        <div class="label">Field Type</div>
        <select class="select" id="editFieldType">
          <option value="text">Text (single line)</option>
          <option value="textarea">Text (multi-line)</option>
          <option value="matrix">Matrix (table)</option>
        </select>
        <div class="hr"></div>
        <div class="label">Field Prompt (AI guidance)</div>
        <textarea class="input" id="editFieldPrompt" spellcheck="false">${escapeHtml(currentPrompt)}</textarea>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelRenameField">Cancel</button>
        <button class="btn danger" id="deleteField">Delete</button>
        <button class="btn primary" id="confirmRenameField">Save</button>
      `;
      $("cancelRenameField").onclick = hideModal;
      $("editFieldType").value = currentType;
      $("deleteField").onclick = () => deleteFieldByKey(test, fieldKey);
      $("confirmRenameField").onclick = () => {
        const newLabel = $("editFieldLabel").value.trim();
        const newKey = $("editFieldKey").value.trim();
        const newType = $("editFieldType").value || "text";
        const newPrompt = $("editFieldPrompt").value.trim();
        if(!newKey){ toast("Missing name", "Enter a data label.", "warn"); return; }

        const data = test.data || {};
        if(newKey !== fieldKey && data[newKey] !== undefined){
          toast("Duplicate field", "That field already exists.", "warn");
          return;
        }

        const keys = Object.keys(data).filter(k => k !== "_ai");
        const out = {};
        for(const k of keys){
          if(k === fieldKey) out[newKey] = data[k];
          else out[k] = data[k];
        }
        out._ai = data._ai || ensureAiMeta(null, Object.keys(out).filter(k => k !== "_ai"));
        if(!out._ai.field_labels) out._ai.field_labels = {};
        if(newLabel) out._ai.field_labels[newKey] = newLabel;
        else delete out._ai.field_labels[newKey];
        if(!out._ai.field_prompts) out._ai.field_prompts = {};
        if(newPrompt) out._ai.field_prompts[newKey] = newPrompt;
        else delete out._ai.field_prompts[newKey];
        if(out._ai.review_personalities && typeof out._ai.review_personalities === "object"){
          for(const persona of Object.values(out._ai.review_personalities)){
            if(!persona) continue;
            if(!persona.field_comments || typeof persona.field_comments !== "object") persona.field_comments = {};
            if(newKey !== fieldKey){
              if(fieldKey in persona.field_comments){
                persona.field_comments[newKey] = persona.field_comments[fieldKey];
                delete persona.field_comments[fieldKey];
              }else if(!(newKey in persona.field_comments)){
                persona.field_comments[newKey] = "";
              }
            }else if(!(newKey in persona.field_comments)){
              persona.field_comments[newKey] = "";
            }
          }
        }

        if(out._ai?.maturity && out._ai.maturity[fieldKey] != null){
          out._ai.maturity[newKey] = out._ai.maturity[fieldKey];
          delete out._ai.maturity[fieldKey];
        }else{
          if(!out._ai.maturity) out._ai.maturity = {};
          out._ai.maturity[newKey] = 0;
        }
        if(out._ai?.field_types && out._ai.field_types[fieldKey] != null){
          out._ai.field_types[newKey] = out._ai.field_types[fieldKey];
          delete out._ai.field_types[fieldKey];
        }
        if(!out._ai.field_types) out._ai.field_types = {};
        out._ai.field_types[newKey] = newType;
        if(out._ai?.field_schema && out._ai.field_schema[fieldKey] != null && newKey !== fieldKey){
          out._ai.field_schema[newKey] = out._ai.field_schema[fieldKey];
          delete out._ai.field_schema[fieldKey];
        }
        if(!out._ai.field_schema) out._ai.field_schema = {};
        if(newType === "matrix"){
          if(!out._ai.field_schema[newKey]) out._ai.field_schema[newKey] = { rows: [], cols: [] };
          if(!(out[newKey] && typeof out[newKey] === "object" && !Array.isArray(out[newKey]))){
            out[newKey] = { rows: [], cols: [], row_labels: {}, col_labels: {}, cells: {} };
          }
        }else if(out._ai.field_schema[newKey]){
          delete out._ai.field_schema[newKey];
        }
        if(out._ai?.field_prompts && out._ai.field_prompts[fieldKey] != null && newKey !== fieldKey){
          out._ai.field_prompts[newKey] = out._ai.field_prompts[fieldKey];
          delete out._ai.field_prompts[fieldKey];
        }
        if(out._ai?.field_labels && out._ai.field_labels[fieldKey] != null && newKey !== fieldKey){
          out._ai.field_labels[newKey] = out._ai.field_labels[fieldKey];
          delete out._ai.field_labels[fieldKey];
        }
        test.data = out;
        if(test._dirtyFields && test._dirtyFields[fieldKey]){
          test._dirtyFields[newKey] = true;
          delete test._dirtyFields[fieldKey];
        }
        test.modified = true;
        state.focusField = newKey;
        hideModal();
        renderForm();
        renderTestsList();
      };
      const typeSelect = $("editFieldType");
      if(typeSelect) typeSelect.value = currentType;
      setTimeout(() => $("editFieldLabel").focus(), 20);
    });
  }

  function fitFlowToView(){
    const svg = $("flowSvg");
    const g = svg?.querySelector("#flowViewport");
    if(!svg || !g) return;
    const vb = svg.viewBox.baseVal;
    const viewW = vb && vb.width ? vb.width : 900;
    const viewH = vb && vb.height ? vb.height : 520;
    const bbox = g.getBBox();
    if(!bbox || !bbox.width || !bbox.height) return;
    const pad = 0.92;
    const scale = Math.min(viewW / bbox.width, viewH / bbox.height) * pad;
    state.flow.scale = Math.max(0.2, Math.min(3, scale));
    state.flow.x = -bbox.x + (viewW / state.flow.scale - bbox.width) / 2;
    state.flow.y = -bbox.y + (viewH / state.flow.scale - bbox.height) / 2;
    applyFlowTransform();
  }

  function drawFlowchart(){
    const svg = $("flowSvg");
    if(!svg) return;
    svg.innerHTML = "";
    const plan = state.currentPlan;
    if(!plan) return;

    let W = 900;
    const NS = "http://www.w3.org/2000/svg";
    const make = (tag, attrs={}) => {
      const el = document.createElementNS(NS, tag);
      for(const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
      return el;
    };
    const normKey = (val) => String(val || "").trim().toUpperCase();
    const isEndPass = (val) => /END\s*PASS/i.test(String(val || ""));
    const isEndFail = (val) => /END\s*FAIL/i.test(String(val || ""));

    const g = make("g", { id:"flowViewport" });
    svg.appendChild(g);

    // Title removed

    // Vertical nodes + right-side routing to avoid crossing blocks
    const boxW = 260, boxH = 54, gap = 14, x = 22;
    const gutterX = x + boxW + 80;
    const grid = 16;
    let y = 58;

    const tests = (plan.tests||[]).slice().sort((a,b) => (a.order||0)-(b.order||0));
    const nodes = [];
    for(const t of tests.slice(0,12)){ // show first N in skeleton
      const d = t.data || {};
      const label1 = (d.section_no || "(no section_no)").trim();
      const label2 = (d.section_title || "(no section_title)").trim();
      const node = { id: t.id, testNo: label1, data: d, x, y, w: boxW, h: boxH };
      nodes.push(node);
      y += boxH + gap;
    }

    const H = Math.max(520, y + 80);

    const byTestNo = {};
    for(const n of nodes){
      const key = normKey(n.testNo);
      if(key && key !== "(NO section_no)") byTestNo[key] = n;
    }

    const endW = 200;
    const endX = x;
    const endY = y + 24;
    const endPass = { x: endX, y: endY, w: endW, h: 44, label: "END PASS" };
    W = Math.max(W, endX + endW + 40);
    svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

    // Subtle grid for alignment
    const gridGroup = make("g", { opacity: "0.14" });
    for(let gx = 0; gx <= W; gx += grid){
      gridGroup.appendChild(make("line", {
        x1:String(gx), y1:"0", x2:String(gx), y2:String(H),
        stroke:"rgba(167,179,200,.15)", "stroke-width":"1"
      }));
    }
    for(let gy = 0; gy <= H; gy += grid){
      gridGroup.appendChild(make("line", {
        x1:"0", y1:String(gy), x2:String(W), y2:String(gy),
        stroke:"rgba(167,179,200,.15)", "stroke-width":"1"
      }));
    }
    g.appendChild(gridGroup);

    const snap = (v) => Math.round(v / grid) * grid;

    // Note: arrows removed per request.

    const endNodes = [endPass];
    for(const en of endNodes){
      const r = make("rect", {
        x:String(en.x), y:String(en.y),
        rx:"10", ry:"10",
        width:String(en.w), height:String(en.h),
        fill:"rgba(152,255,167,.08)",
        stroke:"rgba(152,255,167,.30)",
        "stroke-width":"1.5"
      });
      const t = make("text", {
        x:String(en.x + 12), y:String(en.y + 26),
        fill:"rgba(231,237,247,.95)",
        "font-size":"12",
        "font-family":"var(--mono)"
      });
      t.textContent = en.label;
      g.appendChild(r);
      g.appendChild(t);
    }

    for(const n of nodes){
      const r = make("rect", {
        x:String(n.x), y:String(n.y),
        rx:"12", ry:"12",
        width:String(n.w), height:String(n.h),
        fill:"rgba(124,196,255,.08)",
        stroke:"rgba(124,196,255,.30)",
        "stroke-width":"1.5"
      });
      g.appendChild(r);

      const txt = make("text", {
        x:String(n.x+12), y:String(n.y+20),
        fill:"rgba(231,237,247,.95)",
        "font-size":"12",
        "font-family":"var(--mono)"
      });

      const t1 = make("tspan", {x:String(n.x+12), dy:"0"});
      t1.textContent = n.testNo;
      txt.appendChild(t1);

      const name = (n.data?.section_title || "(no section_title)").trim();
      const t2 = make("tspan", {x:String(n.x+12), dy:"14", fill:"rgba(167,179,200,.95)"});
      t2.textContent = name.length > 32 ? name.slice(0,32) + "…" : name;
      txt.appendChild(t2);

      g.appendChild(txt);
    }
    fitFlowToView();
  }

  /* ---------- Plan ops ---------- */
  async function openPlanById(id){
    try{
      const plan = await Store.loadPlan(id);
      // normalize plan + tests
      plan.slug = plan.slug || slugifyPlanName(plan.name || "plan");
      plan.tests = (plan.tests || []).map((t, idx) => ({
        id: t.id || uid(),
        order: (t.order ?? idx+1),
        modified: !!t.modified,
        data: normalizeTestData(t.data)
      }));
      plan.userNotes = plan.userNotes ?? extractUserNotes(plan.markdown || "");
      if(!plan.markdown) generatePlanMarkdown(plan);
      state.currentPlan = plan;
      state.currentTemplateId = null;
      state.currentTestTemplate = null;
      state.templateEditReturnPlanId = null;
      state.currentTestId = plan.tests[0]?.id || null;

      logLine(`Opened document: ${plan.name}`, "ok");
      toast("Document opened", plan.name, "ok");
      showEditor();
    }catch(e){
      logLine(`Open failed: ${e.message || e}`, "bad");
      toast("Open failed", e.message || String(e), "bad");
    }
  }

  function createNewPlanFlow(){
    let mdText = "";
    let mdName = "";
    let mdInfoEl = null;
    showModal("Create New", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          Creates a new document.
        </div>
        <div class="hr"></div>
        <div class="label">Name</div>
        <input class="input" id="newPlanName" placeholder="e.g., Capacitor Thermal Stress Validation" />
        <div class="row" style="margin-top:8px;">
          <div>
            <div class="label">Goal</div>
            <input class="input" id="newPlanGoal" placeholder="Single-line goal statement" />
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div>
            <div class="label">Scope</div>
            <textarea class="input" id="newPlanScope" rows="3" placeholder="Brief scope description"></textarea>
          </div>
        </div>
        <div class="hint">Slug rules: lowercase, spaces -> underscores, remove non [a-z0-9_], collapse underscores.</div>
        <div class="hr"></div>
        <div class="row" style="margin-top:8px;">
          <div>
            <div class="label">Source Markdown (optional)</div>
            <input class="input" id="newPlanMdFile" type="file" accept=".md,.markdown,text/markdown" />
            <div class="hint" id="newPlanMdInfo">No markdown selected.</div>
          </div>
        </div>
        <div class="hint">AI model: ${escapeHtml(state.prefs.ai_model || "gpt-4.1-mini")}</div>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelNewPlan">Cancel</button>
        <button class="btn" id="confirmNewPlanBlank">Create Manually</button>
        <button class="btn primary" id="confirmNewPlanAi">Create with AI</button>
      `;
      $("cancelNewPlan").onclick = hideModal;
      const setCreateBusy = (busy, label) => {
        const cancelBtn = $("cancelNewPlan");
        const blankBtn = $("confirmNewPlanBlank");
        const aiBtn = $("confirmNewPlanAi");
        if(cancelBtn) cancelBtn.disabled = !!busy;
        if(blankBtn) blankBtn.disabled = !!busy;
        if(aiBtn){
          aiBtn.disabled = !!busy;
          aiBtn.textContent = busy ? (label || "Creating…") : "Create with AI";
        }
      };
      $("confirmNewPlanBlank").onclick = async () => {
        const name = $("newPlanName").value.trim();
        if(!name){ toast("Missing name", "Enter a document name.", "warn"); return; }

        const plan = {
          id: uid(),
          name,
          slug: slugifyPlanName(name),
          created: nowIsoDate(),
          updated: nowIsoDate(),
          tests: [],
          markdown: "",
          goal: $("newPlanGoal").value.trim(),
          scope: $("newPlanScope").value.trim(),
          review_personalities: getPlanReviewPersonas(null),
          userNotes: "Add plan-level notes here (equipment, safety, lab setup, etc.)."
        };
        generatePlanMarkdown(plan);
        await Store.savePlan(plan);

        hideModal();
        logLine(`Created document: ${plan.name}`, "ok");
        toast("Document created", plan.name, "ok");
        runAsync(renderLibrary());
        state.currentPlan = plan;
        state.currentTemplateId = null;
        state.currentTestTemplate = null;
        state.templateEditReturnPlanId = null;
        state.currentTestId = plan.tests[0]?.id || null;
        showEditor();
        renderEditor();
      };
      const mdInput = $("newPlanMdFile");
      mdInfoEl = $("newPlanMdInfo");
      if(mdInput){
        mdInput.addEventListener("change", () => {
          const file = mdInput.files?.[0];
          if(!file){
            mdText = "";
            mdName = "";
            if(mdInfoEl) mdInfoEl.textContent = "No markdown selected.";
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            mdText = String(reader.result || "");
            mdName = file.name || "markdown";
            if(mdInfoEl) mdInfoEl.textContent = `Loaded: ${mdName} (${mdText.length} chars)`;
          };
          reader.onerror = () => {
            mdText = "";
            mdName = "";
            if(mdInfoEl) mdInfoEl.textContent = "Failed to read markdown file.";
          };
          reader.readAsText(file);
        });
      }

      $("confirmNewPlanAi").onclick = async () => {
        const name = $("newPlanName").value.trim();
        if(!name){ toast("Missing name", "Enter a document name.", "warn"); return; }
        const uutPn = $("newPlanUutPn") ? ($("newPlanUutPn").value || "").trim() : "";
        const deviceType = $("newPlanDeviceType") ? ($("newPlanDeviceType").value || "").trim() : "";
        const countInput = $("newPlanTestCount");
        const count = Math.max(1, Number(countInput ? countInput.value : 5) || 5);
        const goal = $("newPlanGoal")?.value?.trim() || "";
        const scope = $("newPlanScope")?.value?.trim() || "";
        const mdFileInput = $("newPlanMdFile");
        const mdFile = mdFileInput?.files?.[0] || null;
        if(mdFile){
          const reader = new FileReader();
          reader.onload = () => {
            mdText = String(reader.result || "");
            mdName = mdFile.name || "markdown";
          };
          reader.readAsText(mdFile);
        }
        setCreateBusy(true, "Creating…");
        const progress = showAiCreateProgress("~30–90 seconds");
        logLine("AI Create: started. Please wait…", "ok");
        toast("AI Create", "Started. Please wait…", "ok");
        try{
          const plan = {
            id: uid(),
            name,
            slug: slugifyPlanName(name),
            created: nowIsoDate(),
            updated: nowIsoDate(),
            tests: [],
            markdown: "",
            goal,
            scope,
            userNotes: "Add plan-level notes here (equipment, safety, lab setup, etc.)."
          };

          const key = getAiKey();
          const model = state.prefs.ai_model || "gpt-4.1-mini";
          let usedAi = false;
          if(state.prefs.ai_enabled && (USE_PROXY || key)){
            try{
              logLine(`AI Create: using model "${model}".`, "ok");
              const mdData = mdText ? extractSchematicMarkdownData(mdText) : null;
              const matrixTemplate = mdData?.partlistHeaders?.length
                ? buildMatrixTemplateFromPartlist(mdData.partlistHeaders, mdData.partlistRowCount || mdData.partlist?.length || 0)
                : null;
              const payload = {
                plan_name: name,
                uut_pn: uutPn,
                device_type: deviceType,
                goal,
                scope,
                test_count: count,
                source_markdown_name: mdName,
                source_markdown_text: mdText || "",
                partlist_headers: mdData?.partlistHeaders || [],
                partlist_row_count: mdData?.partlistRowCount || 0,
                matrix_template: matrixTemplate,
                pin_interface_descriptions: mdData?.pinout || [],
                test_point_list: mdData?.testPoints || [],
                netlist: mdData?.netlist || [],
                partlist: mdData?.partlist || [],
                circuit_identification: mdData?.circuitId || []
              };
                const resp = await fetch(apiUrl("/create"), {
                  method: "POST",
                  headers: apiHeaders(),
                  body: JSON.stringify({
                  model,
                  input: [
                    { role:"system", content:getAiPrompt(null, "create_plan", { testCount: count, schemaKeys: Object.keys(TEST_SCHEMA_DEFAULT).filter(k=>k!=="_ai").join(", ") }) },
                    { role:"user", content: JSON.stringify(payload) }
                  ],
                  max_output_tokens: 1400
                })
              });
              if(resp.ok){
                const data = await resp.json();
                const raw = extractResponseText(data);
                let parsed = null;
                if(typeof raw === "string"){
                  const candidates = [];
                  const balanced = extractBalancedJsonObject(raw);
                  if(balanced) candidates.push(balanced);
                  candidates.push(raw);
                  for(const cand of candidates){
                    const repaired = repairJsonText(cand);
                    const strict = tryParseJson(repaired);
                    if(strict){ parsed = strict; break; }
                  }
                  if(!parsed){
                    const fallbackCandidate = repairJsonText(candidates[0] || raw);
                    parsed = safeParseJson(fallbackCandidate, "AI Create");
                  }
                }else if(raw && typeof raw === "object"){
                  parsed = raw;
                }
                if(parsed && parsed.__fromFallback){
                  const rawText = sanitizeAiText(String(raw || ""));
                  logLine(`AI Create parse fallback used. Raw response: ${rawText.slice(0, 800)}`, "warn");
                }
                if(!parsed || (typeof parsed === "object" && !Array.isArray(parsed.tests) && !parsed.plan)){
                  const rawText = sanitizeAiText(String(raw || ""));
                  logLine(`AI Create parse failed. Raw response: ${rawText.slice(0, 800)}`, "warn");
                }
                if(parsed?.plan){
                  if(!plan.goal && typeof parsed.plan.goal === "string") plan.goal = sanitizeAiText(parsed.plan.goal);
                  if(!plan.scope && typeof parsed.plan.scope === "string") plan.scope = sanitizeAiText(parsed.plan.scope);
                }
                const list = Array.isArray(parsed?.tests) ? parsed.tests : [];
                const cleaned = list.map(t => ({
                  section_no: String(t?.section_no || "").trim(),
                  section_title: String(t?.section_title || "").trim(),
                  set: t?.set && typeof t.set === "object" ? t.set : {}
                })).filter(t => t.section_no);
                if(cleaned.length){
                  for(const [idx, item] of cleaned.entries()){
                    const testNo = item.section_no || String(idx + 1).padStart(3, "0");
                    const set = { ...item.set };
                    if(item.section_title && !set.section_title) set.section_title = item.section_title;
                    if(testNo && !set.section_no) set.section_no = testNo;
                    const baseData = normalizeTestData(set);
                    for(const [k, v] of Object.entries(set)){
                      const fieldType = String(baseData?._ai?.field_types?.[k] || "").toLowerCase();
                      if(!fieldType.includes("matrix")) continue;
                      if(!v || typeof v !== "object" || Array.isArray(v)) continue;
                      const schema = baseData?._ai?.field_schema?.[k] || null;
                      const currentMatrix = normalizeMatrixValue(baseData[k], schema);
                      baseData[k] = applyMatrixPayload(currentMatrix, schema, v);
                    }
                    if(uutPn && !baseData.uut_pn) baseData.uut_pn = uutPn;
                    plan.tests.push({
                      id: uid(),
                      order: idx + 1,
                      modified: true,
                      data: baseData
                    });
                  }
                  usedAi = true;
                }
              }
            }catch(e){
              logLine(`AI Create failed: ${e.message || e}`, "warn");
            }
          }

          if(!plan.tests.length){
            for(let i = 1; i <= count; i++){
              const testNo = String(i).padStart(3, "0");
              const baseData = normalizeTestData({});
              baseData.section_no = testNo;
              baseData.uut_pn = uutPn;
              plan.tests.push({
                id: uid(),
                order: i,
                modified: true,
                data: baseData
              });
            }
          }else if(plan.tests.length < count){
            const start = plan.tests.length + 1;
            for(let i = start; i <= count; i++){
              const testNo = String(i).padStart(3, "0");
              const baseData = normalizeTestData({});
              baseData.section_no = testNo;
              baseData.uut_pn = uutPn;
              plan.tests.push({
                id: uid(),
                order: i,
                modified: true,
                data: baseData
              });
            }
          }

          generatePlanMarkdown(plan);
          const aiAvailable = key && state.prefs.ai_enabled;
          if(!aiAvailable){
            const all = loadPlans();
            const idx = all.findIndex(x => x.id === plan.id);
            if(idx >= 0) all[idx] = structuredClone(plan);
            else all.push(structuredClone(plan));
            localStorage.setItem(Store.key, JSON.stringify(all));
          }else{
            await Store.savePlan(plan);
          }

          progress.close();
          hideModal();
          const testMsg = `${plan.tests.length} item${plan.tests.length === 1 ? "" : "s"}`;
          logLine(`Created document: ${plan.name}${usedAi ? " (AI assist)" : ""} — ${testMsg}.`, "ok");
          if(!aiAvailable){
            logLine("AI unavailable. Saved to browser store.", "warn");
            toast("Document created", `${plan.name} (${testMsg}) — saved to browser store`, "warn");
          }else{
            toast("Document created", usedAi ? `${plan.name} (${testMsg}) — AI assist` : `${plan.name} (${testMsg})`, "ok");
          }
          runAsync(renderLibrary());
          state.currentPlan = plan;
          state.currentTemplateId = null;
          state.currentTestTemplate = null;
          state.templateEditReturnPlanId = null;
          state.currentTestId = plan.tests[0]?.id || null;
          showEditor();
          renderEditor();
        }catch(e){
          progress.close();
          logLine(`AI Create failed: ${e.message || e}`, "warn");
          toast("AI Create", e.message || "Failed.", "warn");
        }finally{
          setCreateBusy(false);
        }
      };

      setTimeout(() => $("newPlanName").focus(), 20);
    });
  }

  async function renamePlanFlow(planId){
    const base = state.plansCache.find(p => p.id === planId);
    if(!base) return;
    const plan = await Store.loadPlan(planId).catch(() => null);
    const mdMeta = extractPlanMetaFromMarkdown(plan?.markdown || "");
    const goalVal = plan?.goal ?? base.goal ?? mdMeta.goal ?? "";
    const scopeVal = plan?.scope ?? base.scope ?? mdMeta.scope ?? "";

    showModal("Rename Document", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          Updates the document name and regenerates markdown while preserving the notes block.
        </div>
        <div class="hr"></div>
        <div class="label">New Document Name</div>
        <input class="input" id="renamePlanName" value="${escapeHtml(base.name)}" />
        <div class="row" style="margin-top:8px;">
          <div>
            <div class="label">Goal</div>
            <input class="input" id="renamePlanGoal" value="${escapeHtml(goalVal)}" />
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div>
            <div class="label">Scope</div>
            <textarea class="input" id="renamePlanScope" rows="3">${escapeHtml(scopeVal)}</textarea>
          </div>
        </div>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelRename">Cancel</button>
        <button class="btn primary" id="confirmRename">Save</button>
      `;
      $("cancelRename").onclick = hideModal;
      $("confirmRename").onclick = async () => {
        const newName = sanitizeAiText($("renamePlanName").value.trim());
        if(!newName){ toast("Missing name", "Enter a document name.", "warn"); return; }

        const live = await Store.loadPlan(planId);
        const oldNotes = live.userNotes ?? extractUserNotes(live.markdown || "");
        live.name = newName;
        live.slug = slugifyPlanName(newName);
        live.goal = sanitizeAiText($("renamePlanGoal").value.trim());
        live.scope = sanitizeAiText($("renamePlanScope").value.trim());
        live.userNotes = oldNotes;
        if(useFileSystemStore()){
          try{
            const desiredFolder = makePlanFolderName(live);
            const newFolder = await fsRenamePlanFolder(live, desiredFolder);
            if(newFolder) live.folder = newFolder;
          }catch(e){
            logLine(`Rename folder failed (FS). ${e.message || e}`, "warn");
          }
        }
        generatePlanMarkdown(live);
        await Store.savePlan(live);

        hideModal();
        logLine(`Renamed document: ${newName}`, "ok");
        toast("Document renamed", newName, "ok");
        runAsync(renderLibrary());
      };
      setTimeout(() => $("renamePlanName").focus(), 20);
    });
  }

  async function openTemplateById(id){
    try{
      const tpl = await Templates.loadTemplate(id);
      tpl.slug = tpl.slug || slugifyPlanName(tpl.name || "template");
      tpl.tests = (tpl.tests || []).map((t, idx) => ({
        id: t.id || uid(),
        order: (t.order ?? idx+1),
        modified: !!t.modified,
        data: normalizeTestData(t.data)
      }));
      tpl.userNotes = tpl.userNotes ?? extractUserNotes(tpl.markdown || "");
      if(!tpl.markdown) generatePlanMarkdown(tpl);

      state.currentPlan = tpl;
      state.currentTemplateId = id;
      state.currentTestTemplate = null;
      state.templateEditReturnPlanId = null;
      state.currentTestId = tpl.tests[0]?.id || null;

      logLine(`Opened template: ${tpl.name}`, "ok");
      toast("Template opened", tpl.name, "ok");
      showEditor();
    }catch(e){
      logLine(`Open template failed: ${e.message || e}`, "bad");
      toast("Open failed", e.message || String(e), "bad");
    }
  }

  async function duplicatePlanFlow(planId){
    const base = state.plansCache.find(p => p.id === planId);
    if(!base) return;

    showModal("Duplicate Document", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          Creates a new document with a copy of all tests and notes. The duplicate gets a new ID and folder.
        </div>
        <div class="hr"></div>
        <div class="label">New Document Name</div>
        <input class="input" id="duplicatePlanName" value="${escapeHtml(`Copy of ${base.name || "Document"}`)}" />
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelDuplicate">Cancel</button>
        <button class="btn primary" id="confirmDuplicate">Duplicate</button>
      `;
      $("cancelDuplicate").onclick = hideModal;
      $("confirmDuplicate").onclick = async () => {
        const newName = $("duplicatePlanName").value.trim();
        if(!newName){ toast("Missing name", "Enter a document name.", "warn"); return; }

        const plan = await Store.loadPlan(planId);
        const copy = structuredClone(plan);
        copy.id = uid();
        copy.name = newName;
        copy.slug = slugifyPlanName(newName);
        copy.folder = null;
        copy.created = nowIsoDate();
        copy.updated = nowIsoDate();
        copy.userNotes = plan.userNotes ?? extractUserNotes(plan.markdown || "");
        copy.tests = (plan.tests || []).map((t, idx) => ({
          id: uid(),
          order: t.order ?? (idx + 1),
          modified: false,
          data: structuredClone(t.data || {})
        }));
        generatePlanMarkdown(copy);
        await Store.savePlan(copy);

        hideModal();
        logLine(`Duplicated document: ${newName}`, "ok");
        toast("Document duplicated", newName, "ok");
        runAsync(renderLibrary());
      };
      setTimeout(() => $("duplicatePlanName").focus(), 20);
    });
  }

  async function saveTemplateFlow(planId){
    const base = state.plansCache.find(p => p.id === planId);
    if(!base) return;

    showModal("Save as Template", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          Saves a template copy to the templates folder and browser store.
        </div>
        <div class="hr"></div>
        <div class="label">Template Name</div>
        <input class="input" id="templateName" value="${escapeHtml(base.name || "Template")}" />
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelTemplate">Cancel</button>
        <button class="btn primary" id="confirmTemplate">Save Template</button>
      `;
      $("cancelTemplate").onclick = hideModal;
      $("confirmTemplate").onclick = async () => {
        const newName = $("templateName").value.trim();
        if(!newName){ toast("Missing name", "Enter a template name.", "warn"); return; }

        const plan = await Store.loadPlan(planId);
        const copy = structuredClone(plan);
        copy.id = uid();
        copy.name = newName;
        copy.slug = slugifyPlanName(newName);
        copy.folder = null;
        copy.created = nowIsoDate();
        copy.updated = nowIsoDate();
        copy.userNotes = plan.userNotes ?? extractUserNotes(plan.markdown || "");
        copy.tests = (plan.tests || []).map((t, idx) => ({
          id: uid(),
          order: t.order ?? (idx + 1),
          modified: false,
          data: structuredClone(t.data || {})
        }));
        generatePlanMarkdown(copy);
        await Templates.saveTemplate(copy);

        hideModal();
        logLine(`Saved template: ${newName}`, "ok");
        toast("Template saved", newName, "ok");
        runAsync(renderLibrary());
      };
      setTimeout(() => $("templateName").focus(), 20);
    });
  }

  async function createFromTemplateFlow(templateId){
    const base = state.templatesCache.find(t => t.id === templateId);
    if(!base) return;

    showModal("Create Document from Template", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          Creates a new document from the selected template.
        </div>
        <div class="hr"></div>
        <div class="label">New Document Name</div>
        <input class="input" id="createFromTemplateName" value="${escapeHtml(base.name || "New Document")}" />
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelCreateFromTemplate">Cancel</button>
        <button class="btn primary" id="confirmCreateFromTemplate">Create</button>
      `;
      $("cancelCreateFromTemplate").onclick = hideModal;
      $("confirmCreateFromTemplate").onclick = async () => {
        const newName = $("createFromTemplateName").value.trim();
        if(!newName){ toast("Missing name", "Enter a document name.", "warn"); return; }

        const tpl = await Templates.loadTemplate(templateId);
        const copy = structuredClone(tpl);
        copy.id = uid();
        copy.name = newName;
        copy.slug = slugifyPlanName(newName);
        copy.folder = null;
        copy.created = nowIsoDate();
        copy.updated = nowIsoDate();
        copy.userNotes = tpl.userNotes ?? extractUserNotes(tpl.markdown || "");
        copy.tests = (tpl.tests || []).map((t, idx) => ({
          id: uid(),
          order: t.order ?? (idx + 1),
          modified: false,
          data: structuredClone(t.data || {})
        }));
        generatePlanMarkdown(copy);
        await Store.savePlan(copy);

        hideModal();
        logLine(`Created document from template: ${newName}`, "ok");
        toast("Document created", newName, "ok");
        await openPlanById(copy.id);
      };
      setTimeout(() => $("createFromTemplateName").focus(), 20);
    });
  }

  async function renameTemplateFlow(templateId){
    const base = state.templatesCache.find(t => t.id === templateId);
    if(!base) return;

    showModal("Rename Template", (body, footer) => {
      body.innerHTML = `
        <div class="label">New Template Name</div>
        <input class="input" id="renameTemplateName" value="${escapeHtml(base.name)}" />
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelRenameTemplate">Cancel</button>
        <button class="btn primary" id="confirmRenameTemplate">Rename</button>
      `;
      $("cancelRenameTemplate").onclick = hideModal;
      $("confirmRenameTemplate").onclick = async () => {
        const newName = $("renameTemplateName").value.trim();
        if(!newName){ toast("Missing name", "Enter a template name.", "warn"); return; }

        const tpl = await Templates.loadTemplate(templateId);
        tpl.name = newName;
        tpl.slug = slugifyPlanName(newName);
        tpl.userNotes = tpl.userNotes ?? extractUserNotes(tpl.markdown || "");
        generatePlanMarkdown(tpl);
        await Templates.saveTemplate(tpl);

        hideModal();
        logLine(`Renamed template: ${newName}`, "ok");
        toast("Template renamed", newName, "ok");
        runAsync(renderLibrary());
      };
      setTimeout(() => $("renameTemplateName").focus(), 20);
    });
  }

  async function deleteTemplateFlow(templateId){
    const base = state.templatesCache.find(t => t.id === templateId);
    if(!base) return;

    showModal("Delete Template", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          <strong>Warning:</strong> This permanently deletes the template.
        </div>
        <div class="hr"></div>
        <div class="hint">Template: <span class="tag">${escapeHtml(base.name)}</span></div>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelDelTemplate">Cancel</button>
        <button class="btn danger" id="confirmDelTemplate">Delete</button>
      `;
      $("cancelDelTemplate").onclick = hideModal;
      $("confirmDelTemplate").onclick = async () => {
        await Templates.deleteTemplate(templateId);
        hideModal();
        logLine(`Deleted template: ${base.name}`, "warn");
        toast("Template deleted", base.name, "warn");
        runAsync(renderLibrary());
      };
    });
  }

  async function deletePlanFlow(planId){
    const base = state.plansCache.find(p => p.id === planId);
    if(!base) return;

    showModal("Delete Document", (body, footer) => {
      body.innerHTML = `
        <div class="muted" style="line-height:1.45;">
          <strong>Warning:</strong> This permanently deletes the document (folder + files if File System is enabled).
        </div>
        <div class="hr"></div>
        <div class="row">
          <div>
            <div class="label">Type DELETE to confirm</div>
            <input class="input" id="delConfirm" placeholder="DELETE" />
          </div>
        </div>
        <div class="hint">Document: <span class="tag">${escapeHtml(base.name)}</span></div>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelDel">Cancel</button>
        <button class="btn danger" id="confirmDel" disabled>Delete</button>
      `;
      $("cancelDel").onclick = hideModal;

      $("delConfirm").addEventListener("input", () => {
        $("confirmDel").disabled = $("delConfirm").value.trim().toUpperCase() !== "DELETE";
      });

      $("confirmDel").onclick = async () => {
        await Store.deletePlan(planId);
        hideModal();
        logLine(`Deleted document: ${base.name}`, "warn");
        toast("Document deleted", base.name, "warn");
        runAsync(renderLibrary());
      };
    });
  }

  /* ---------- Test ops ---------- */
  async function newTest(){
    const plan = state.currentPlan;
    if(!plan) return;

    const templates = await getAvailableTestTemplates(plan);
    const mode = state.prefs.new_test_template_mode || "default";
    let chosen = null;
    if(mode === "choose"){
      chosen = await pickTestTemplate(templates);
      if(!chosen) return;
    }else{
      const defId = state.prefs.new_test_template_default || "__blank__";
      chosen = templates.find(t => t.id === defId) || templates[0];
    }

    const nextOrder = (plan.tests?.reduce((m,t)=>Math.max(m, t.order||0), 0) || 0) + 1;
    const t = {
      id: uid(),
      order: nextOrder,
      modified: true,
      data: normalizeTestData(chosen?.data ? structuredClone(chosen.data) : {})
    };
    plan.tests.push(t);
    state.currentTestId = t.id;

    logLine(`Created new list item (unsaved)${chosen?.name ? ` from "${chosen.name}"` : ""}.`, "ok");
    toast("New list item", chosen?.name ? `List item created from "${chosen.name}".` : "List item created (unsaved).", "ok");
    renderEditor();
  }

  function deleteTestById(testId){
    const plan = state.currentPlan;
    if(!plan) return;
    const test = (plan.tests || []).find(t => t.id === testId);
    if(!test) return;

    showModal("Delete List Item", (body, footer) => {
      const d = test.data || {};
      body.innerHTML = `
        <div class="muted">Deletes the selected list item from this document.</div>
        <div class="hr"></div>
        <div class="muted">Item: <span class="tag">${escapeHtml(d.section_no || "(no id)")}</span> ${escapeHtml(d.section_title || "(no name)")}</div>
      `;
      footer.innerHTML = `
        <button class="btn" id="cancelDelTest">Cancel</button>
        <button class="btn danger" id="confirmDelTest">Delete</button>
      `;
      $("cancelDelTest").onclick = hideModal;
      $("confirmDelTest").onclick = () => {
        plan.tests = plan.tests.filter(x => x.id !== test.id);
        state.currentTestId = plan.tests[0]?.id || null;
        hideModal();
        logLine("Deleted list item.", "warn");
        toast("List item deleted", "Removed from document.", "warn");
        renderEditor();
      };
    });
  }

  function deleteCurrentTest(){
    const test = currentTest();
    if(!test) return;
    deleteTestById(test.id);
  }

  function duplicateTestBelow(testId){
    const plan = state.currentPlan;
    if(!plan) return;
    const ordered = (plan.tests || []).slice().sort((a,b) => (a.order||0) - (b.order||0));
    const idx = ordered.findIndex(t => t.id === testId);
    if(idx < 0) return;
    const source = ordered[idx];
    const clone = {
      id: uid(),
      order: source.order || (idx + 1),
      modified: true,
      data: normalizeTestData(structuredClone(source.data || {}))
    };
    ordered.splice(idx + 1, 0, clone);
    ordered.forEach((t, i) => { t.order = i + 1; });
    plan.tests = ordered;
    state.currentTestId = clone.id;
    logLine(`Duplicated list item ${source.data?.section_no || source.id.slice(0,6)}.`, "ok");
    toast("Duplicate", "Inserted copy below.", "ok");
    renderEditor();
  }

  function normalizeCurrentTest(){
    const test = currentTest();
    if(!test) return;
    test.data = normalizeTestData(test.data);
    test.modified = true;
    $("dirtyHint").style.display = "";
    renderForm();
    renderTestsList();
    logLine("Normalized list item schema.", "ok");
    toast("Normalized", "Schema keys ensured + values coerced.", "ok");
  }

  function showCurrentJsonModal(){
    const test = currentTest();
    if(!test) return;
    showModal("Current Test JSON", (body, footer) => {
      body.innerHTML = `
        <div class="muted">Normalized schema view:</div>
        <pre style="margin:10px 0 0; padding:12px; border:1px solid rgba(42,52,71,.7); border-radius:14px; background:rgba(255,255,255,.02); overflow:auto; font-family:var(--mono); font-size:11px; line-height:1.35;">${escapeHtml(JSON.stringify(normalizeTestData(test.data), null, 2))}</pre>
      `;
      footer.innerHTML = `<button class="btn" id="closeJson">Close</button>`;
      $("closeJson").onclick = hideModal;
    });
  }

  async function saveCurrentTest(){
    const plan = state.currentPlan;
    const test = currentTest();
    if(!plan || !test) return;

    // normalize
    test.data = normalizeTestData(test.data);
    if(!test.data._ai) test.data._ai = ensureAiMeta(null, Object.keys(test.data).filter(k => k !== "_ai"));
    test.data._ai.last_human_reviewed = nowIsoTimestamp();

    if(state.currentTestTemplate){
      const basePlan = await Store.loadPlan(state.currentTestTemplate.basePlanId).catch(() => null);
      if(!basePlan){
        toast("Templates", "Base document not found.", "warn");
        return;
      }
      const templatesDir = await fsEnsureTestTemplatesDir(basePlan, true);
      if(!templatesDir){
        toast("Templates", "Library folder not set or unavailable.", "warn");
        return;
      }
      const payload = { data: normalizeTestData(test.data) };
      await fsWriteText(templatesDir, state.currentTestTemplate.file, JSON.stringify(payload, null, 2), "application/json");
      test.modified = false;
      test._dirtyFields = {};
      test._dirtyMatrixCells = {};
      $("dirtyHint").style.display = "none";
      renderEditor();
      logLine(`Saved list item template: ${state.currentTestTemplate.file}`, "ok");
      toast("Templates", "Template saved.", "ok");
      return;
    }

    test.modified = false;
    test._dirtyFields = {};
    test._dirtyMatrixCells = {};
    plan.updated = nowIsoDate();
    generatePlanMarkdown(plan);
    if(state.currentTemplateId){
      await Templates.saveTemplate(plan);
      logLine("Saved template.", "ok");
      toast("Saved", "Template saved.", "ok");
      runAsync(renderLibrary());
    }else{
      await Store.savePlan(plan);
      logLine("Saved item + document.", "ok");
      toast("Saved", "List item saved (and document markdown regenerated).", "ok");
    }

    if(state.aiReviewStatus) delete state.aiReviewStatus[test.id];
    if(state.aiSuggestStatus && state.aiSuggestStatus[test.id]) delete state.aiSuggestStatus[test.id];
    renderTestsList();
    renderEditor();
  }

  async function saveAll(){
    const plan = state.currentPlan;
    if(!plan) return;

    // normalize across all tests
    for(const t of plan.tests){
      t.data = normalizeTestData(t.data);
      if(!t.data._ai) t.data._ai = ensureAiMeta(null, Object.keys(t.data).filter(k => k !== "_ai"));
      t.data._ai.last_human_reviewed = nowIsoTimestamp();
      t.modified = false;
      t._dirtyFields = {};
      t._dirtyMatrixCells = {};
    }

    plan.updated = nowIsoDate();
    generatePlanMarkdown(plan);
    if(state.currentTestTemplate){
      const test = currentTest();
      if(test) await saveCurrentTest();
      return;
    }
    if(state.currentTemplateId){
      await Templates.saveTemplate(plan);
    }else{
      await Store.savePlan(plan);
    }

    logLine("Saved document.", "ok");
    toast("Save All", "Saved document.", "ok");
    state.aiReviewStatus = {};
    state.aiSuggestStatus = {};
    renderTestsList();
    renderEditor();
  }

  function downloadCurrentTestJson(){
    const test = currentTest();
    if(!test) return;
    const fn = `${(test.data.section_no || "test").replace(/[^a-zA-Z0-9_-]/g,"_")}.json`;
    downloadText(fn, JSON.stringify(normalizeTestData(test.data), null, 2), "application/json");
    logLine(`Downloaded item JSON: ${fn}`, "ok");
  }

  function refreshMarkdownUI(){
    const plan = state.currentPlan;
    if(!plan) return;
    if(!plan.markdown) generatePlanMarkdown(plan);
    const notes = $("notesArea");
    const preview = $("mdPreview");
    const goal = $("mdPlanGoal");
    const scope = $("mdPlanScope");
    const guidance = $("mdAiReviewGuidance");
    const promptsWrap = $("mdAiPromptsWrap");
    const prompts = $("mdAiPrompts");
    const personasWrap = $("mdPersonasWrap");
    if(!notes || !preview) return;
    const mdMeta = extractPlanMetaFromMarkdown(plan.markdown || "");
    if(!plan.goal && mdMeta.goal) plan.goal = mdMeta.goal;
    if(!plan.scope && mdMeta.scope) plan.scope = mdMeta.scope;
    if(!plan.ai_review_guidance && mdMeta.aiReviewGuidance) plan.ai_review_guidance = mdMeta.aiReviewGuidance;
    if(goal) goal.value = plan.goal ?? "";
    if(scope) scope.value = plan.scope ?? "";
    if(guidance) guidance.value = plan.ai_review_guidance ?? "";
    if(promptsWrap){
      const merged = { ...DEFAULT_AI_PROMPTS, ...(plan.ai_prompts || {}) };
      const entries = [
        ["review_persona", "Review Persona Prompt"],
        ["review_field", "Review Field Prompt"],
        ["chat_edit", "AI Chat Edit Prompt"],
        ["create_plan", "AI Create Document Prompt"],
        ["suggest_field", "Suggest Field Prompt"],
        ["suggest_field_strict", "Suggest Field (Strict) Prompt"],
        ["suggest_limits_note", "Suggest Limits Note"]
      ];
      promptsWrap.innerHTML = entries.map(([key,label]) => `
        <div class="label" style="margin-top:10px;">${escapeHtml(label)}</div>
        <textarea class="input" data-prompt-key="${escapeHtml(key)}" rows="3" spellcheck="false"></textarea>
      `).join("");
      promptsWrap.querySelectorAll("[data-prompt-key]").forEach(el => {
        const key = el.getAttribute("data-prompt-key");
        el.value = merged[key] ?? "";
      });
    }
    if(personasWrap){
      const defs = getPlanReviewPersonas(plan);
      const rows = Object.entries(defs).map(([id,p]) => `
        <div class="item" style="align-items:stretch;">
          <div class="left" style="flex:1;">
            <div class="label">ID</div>
            <input class="input" data-persona-id value="${escapeHtml(id)}" />
            <div class="label" style="margin-top:8px;">Label</div>
            <input class="input" data-persona-label value="${escapeHtml(p.label || id)}" />
          </div>
          <div class="left" style="flex:1;">
            <div class="label">Focus</div>
            <textarea class="input" data-persona-focus rows="3" spellcheck="false">${escapeHtml(p.focus || "")}</textarea>
            <div class="label" style="margin-top:8px;">Guidance</div>
            <textarea class="input" data-persona-guidance rows="3" spellcheck="false">${escapeHtml(p.guidance || "")}</textarea>
          </div>
          <div class="actions">
            <button class="btn mini danger" data-persona-delete>Delete</button>
          </div>
        </div>
      `).join("");
      personasWrap.innerHTML = rows || `<div class="muted">No personalities configured.</div>`;
      const addBtn = $("mdAddPersona");
      if(addBtn){
        addBtn.onclick = () => {
          const el = document.createElement("div");
          el.className = "item";
          el.style.alignItems = "stretch";
          el.innerHTML = `
            <div class="left" style="flex:1;">
              <div class="label">ID</div>
              <input class="input" data-persona-id placeholder="persona_id" />
              <div class="label" style="margin-top:8px;">Label</div>
              <input class="input" data-persona-label placeholder="Persona Label" />
            </div>
            <div class="left" style="flex:1;">
              <div class="label">Focus</div>
              <textarea class="input" data-persona-focus rows="3" spellcheck="false" placeholder="What this persona focuses on"></textarea>
              <div class="label" style="margin-top:8px;">Guidance</div>
              <textarea class="input" data-persona-guidance rows="3" spellcheck="false" placeholder="Tone/role guidance"></textarea>
            </div>
            <div class="actions">
              <button class="btn mini danger" data-persona-delete>Delete</button>
            </div>
          `;
          personasWrap.appendChild(el);
          el.querySelector("[data-persona-delete]")?.addEventListener("click", () => el.remove());
        };
      }
      personasWrap.querySelectorAll("[data-persona-delete]").forEach(btn => {
        btn.addEventListener("click", () => btn.closest(".item")?.remove());
      });
    }
    notes.value = plan.userNotes ?? extractUserNotes(plan.markdown);
    preview.textContent = plan.markdown || "";
  }

  function showMarkdownModal(){
    const plan = state.currentPlan;
    if(!plan) return;
    showModal("Overview Editor", (body, footer) => {
      body.innerHTML = `
        <div class="miniTabs" style="margin-bottom:8px;">
          <div class="miniTab active" data-tab="preview">Preview</div>
          <div class="miniTab" data-tab="overview">Overview</div>
          <div class="miniTab" data-tab="prompts">AI Prompts</div>
          <div class="miniTab" data-tab="personalities">Personalities</div>
          <div class="miniTab" data-tab="notes">Notes</div>
        </div>
        <div class="miniTabContent active" data-tab-panel="preview">
          <div class="mdWrap" style="display:flex; flex-direction:column; min-height:0;">
            <div class="mdPreview" id="mdPreview"></div>
          </div>
        </div>
        <div class="miniTabContent" data-tab-panel="overview">
          <div>
            <div class="label">Goal</div>
            <input class="input" id="mdPlanGoal" placeholder="Single-line goal statement" />
            <div class="label" style="margin-top:10px;">Scope</div>
            <textarea class="input" id="mdPlanScope" rows="3" spellcheck="false"></textarea>
            <div class="label" style="margin-top:10px;">AI Review Guidance</div>
            <textarea class="input" id="mdAiReviewGuidance" rows="3" spellcheck="false" placeholder="Style/tone/vibe guidance for AI Review"></textarea>
          </div>
        </div>
        <div class="miniTabContent" data-tab-panel="prompts">
          <div>
            <div class="label">AI Prompt Templates</div>
            <div id="mdAiPromptsWrap"></div>
          </div>
        </div>
        <div class="miniTabContent" data-tab-panel="personalities">
          <div>
            <div class="toolbarRow" style="margin-bottom:8px;">
              <button class="btn mini" id="mdAddPersona">Add Personality</button>
            </div>
            <div id="mdPersonasWrap"></div>
          </div>
        </div>
        <div class="miniTabContent" data-tab-panel="notes">
          <div>
            <div class="label">Notes</div>
            <textarea class="mdArea" id="notesArea" spellcheck="false"></textarea>
          </div>
        </div>
      `;
      footer.innerHTML = `
          <button class="btn" id="closeMdModal">Close</button>
          <button class="btn primary" id="btnApplyNotes">Save</button>
        `;
      $("closeMdModal").onclick = hideModal;
      $("btnApplyNotes").onclick = applyNotes;
      body.querySelectorAll(".miniTab").forEach(tab => {
        tab.addEventListener("click", () => {
          body.querySelectorAll(".miniTab").forEach(t => t.classList.remove("active"));
          tab.classList.add("active");
          const id = tab.getAttribute("data-tab");
          body.querySelectorAll(".miniTabContent").forEach(c => c.classList.remove("active"));
          const panel = body.querySelector(`[data-tab-panel="${id}"]`);
          if(panel) panel.classList.add("active");
        });
      });
      refreshMarkdownUI();
    });
  }

  async function applyNotes(){
    const plan = state.currentPlan;
    if(!plan) return;
    const notes = $("notesArea");
    const goal = $("mdPlanGoal");
    const scope = $("mdPlanScope");
    const guidance = $("mdAiReviewGuidance");
    const promptsWrap = $("mdAiPromptsWrap");
    const personasWrap = $("mdPersonasWrap");
    if(!notes) return;
    if(goal) plan.goal = sanitizeAiText(goal.value.trim());
    if(scope) plan.scope = sanitizeAiText(scope.value.trim());
    if(guidance) plan.ai_review_guidance = sanitizeAiText(guidance.value.trim());
    if(promptsWrap){
      const next = { ...(plan.ai_prompts || {}) };
      promptsWrap.querySelectorAll("[data-prompt-key]").forEach(el => {
        const key = el.getAttribute("data-prompt-key");
        next[key] = String(el.value || "");
      });
      plan.ai_prompts = next;
    }
    if(personasWrap){
      const next = {};
      personasWrap.querySelectorAll(".item").forEach(row => {
        const rawId = row.querySelector("[data-persona-id]")?.value || "";
        const id = normalizePersonaId(rawId);
        if(!id) return;
        const label = sanitizeAiText(row.querySelector("[data-persona-label]")?.value || id);
        const focus = sanitizeAiText(row.querySelector("[data-persona-focus]")?.value || "");
        const guidanceLine = sanitizeAiText(row.querySelector("[data-persona-guidance]")?.value || "");
        next[id] = { label, focus, guidance: guidanceLine };
      });
      plan.review_personalities = next;
      syncPlanReviewPersonalities(plan);
    }
    plan.userNotes = notes.value || "";
    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    refreshMarkdownUI();
    logLine("Applied document notes and regenerated markdown.", "ok");
    toast("Notes applied", "Notes preserved and markdown regenerated.", "ok");
  }

  async function regenerateMd(){
    const plan = state.currentPlan;
    if(!plan) return;
    // preserve notes explicitly
    const notes = $("notesArea");
    const goal = $("mdPlanGoal");
    const scope = $("mdPlanScope");
    const guidance = $("mdAiReviewGuidance");
    if(notes) plan.userNotes = notes.value || plan.userNotes || "";
    if(goal) plan.goal = sanitizeAiText(goal.value.trim());
    if(scope) plan.scope = sanitizeAiText(scope.value.trim());
    if(guidance) plan.ai_review_guidance = sanitizeAiText(guidance.value.trim());
    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    refreshMarkdownUI();
    logLine("Regenerated document markdown.", "ok");
    toast("Markdown regenerated", "Generated sections refreshed. Notes preserved.", "ok");
  }

  function downloadMd(){
    const plan = state.currentPlan;
    if(!plan) return;
    generatePlanMarkdown(plan);
    downloadText(`test_plan_${plan.slug || slugifyPlanName(plan.name)}.md`, plan.markdown || "", "text/markdown");
    logLine("Downloaded document markdown.", "ok");
  }

  /* ---------- Preferences ---------- */
  function openPreferences(){
    showModal("Preferences", (body, footer) => {
      const hasKey = !!getAiKey();
      const cachedModels = state.modelList.length ? state.modelList : loadModelCache();
      body.innerHTML = `
        <div class="label">System</div>
        <div class="row">
          <div>
            <div class="label">AI Status</div>
            <div class="input" style="display:flex;align-items:center;">${USE_PROXY ? "Proxy" : (hasKey ? "Key set" : "Not set")}</div>
          </div>
          <div>
            <div class="label">Document Storage</div>
            <div class="input" id="prefStorageMode" style="display:flex;align-items:center;">${state.planRootHandle ? "File System" : "Browser Store"}</div>
          </div>
          <div>
            <div class="label">Library Folder</div>
            <div class="input" id="prefLibraryFolder" style="display:flex;align-items:center;">${state.planRootHandle ? (state.planRootPath || state.planRootHandle.name || "Selected folder") : "Not set"}</div>
          </div>
        </div>
        <div class="toolbarRow" style="margin-top:6px;">
          <button class="btn attn" id="prefSetPlanRoot">Set Library Folder</button>
        </div>

        <div class="hr"></div>

        <div class="label">AI</div>
        <div class="row">
          <div>
            <div class="label">AI Enabled</div>
            <select class="select" id="prefAiEnabled">
              <option value="false">Off</option>
              <option value="true">On</option>
            </select>
          </div>
          <div>
            <div class="label">AI Model</div>
            <select class="select" id="prefAiModel"></select>
          </div>
        </div>
        <div class="row" style="margin-top:10px;">
          <div style="flex:2;">
            <div class="label">API Base URL</div>
            <input class="input" id="prefApiBase" placeholder="https://minipcb-proxy.yourdomain.workers.dev" />
          </div>
          <div style="flex:1;"></div>
        </div>
        <div class="row" style="margin-top:10px;">
          <div>
            <div class="label">AI Suggest Maturity Max</div>
            <select class="select" id="prefSuggestMax">
              <option value="0">M0</option>
              <option value="1">M1</option>
              <option value="2">M2</option>
            </select>
          </div>
          <div>
            <div class="label">AI Maturity Level Process</div>
            <select class="select" id="prefMaturityClicks">
              <option value="2">2 Click</option>
              <option value="4">4 Click</option>
            </select>
          </div>
          <div>
            <div class="label">Edit/Review Clicks</div>
            <select class="select" id="prefUiClicks">
              <option value="2">2 Click</option>
              <option value="4">4 Click</option>
            </select>
          </div>
          <div>
            <div class="label">Personalities Dialog</div>
            <select class="select" id="prefPersonalityDialog">
              <option value="false">Disabled</option>
              <option value="true">Enabled</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <div class="label">AI Review Debug</div>
            <select class="select" id="prefAiReviewDebug">
              <option value="false">Off</option>
              <option value="true">On (next test only)</option>
            </select>
          </div>
          <div>
            <div class="label">AI Review Pause (ms)</div>
            <input class="input" id="prefAiReviewPause" type="number" min="0" step="50" />
          </div>
          <div>
            <div class="label">AI Review Concurrency</div>
            <input class="input" id="prefAiReviewConcurrency" type="number" min="1" step="1" />
          </div>
        </div>

        <div class="toolbarRow" style="margin-top:6px;">
          <button class="btn" id="prefRefreshModels">Refresh Models</button>
        </div>

        <div class="hr"></div>

        <div class="label">Editor</div>
        <div class="row">
          <div>
            <div class="label">Editor</div>
            <select class="select" id="prefTestEditorLock">
              <option value="locked">Locked</option>
              <option value="unlocked">Unlocked</option>
            </select>
          </div>
          <div>
            <div class="label">BOM Matrix Controls</div>
            <select class="select" id="prefMatrixControls">
              <option value="true">Show</option>
              <option value="false">Hide</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="label">Templates</div>
        <div class="row">
          <div>
            <div class="label">New Test Template Mode</div>
            <select class="select" id="prefNewTestTemplateMode">
              <option value="default">Use default template</option>
              <option value="choose">Choose on every new test</option>
            </select>
          </div>
          <div>
            <div class="label">Default Test Template</div>
            <select class="select" id="prefNewTestTemplateDefault">
              <option value="__blank__">Electronics Test</option>
              <option value="__spec_requirements__">Requirements (Spec)</option>
              <option value="__vm_requirements_table__">Requirements Table (VM)</option>
              <option value="__vm_verification_mapping__">Verification Mapping (VM)</option>
              <option value="__fmea_failure_mode__">Failure Mode (FMEA)</option>
            </select>
            <div class="hint">Templates are read from the current document's tests/templates folder.</div>
          </div>
        </div>
      `;

      $("prefAiEnabled").value = String(state.prefs.ai_enabled);
      const modelSelect = $("prefAiModel");
      const defaultModels = [
        "gpt-5.2","gpt-5.2-pro","gpt-5-mini","gpt-5-nano",
        "gpt-4.1","gpt-4.1-mini","gpt-4.1-nano"
      ];
      const modelList = (cachedModels && cachedModels.length) ? cachedModels : defaultModels;
      modelSelect.innerHTML = modelList.map(m => `<option value="${escapeHtml(m)}">${escapeHtml(m)}</option>`).join("");
      let currentModel = state.prefs.ai_model || "gpt-4.1-mini";
      if(!/^gpt-/i.test(currentModel)) currentModel = "gpt-4.1-mini";
      if(modelSelect && !Array.from(modelSelect.options).some(o => o.value === currentModel)){
        const opt = document.createElement("option");
        opt.value = currentModel;
        opt.textContent = `${currentModel} (current)`;
        modelSelect.appendChild(opt);
      }
      if(modelSelect) modelSelect.value = currentModel;
      const apiBaseInput = $("prefApiBase");
      if(apiBaseInput) apiBaseInput.value = AI_PROXY_BASE || "";
      $("prefSuggestMax").value = String(state.prefs.ai_suggest_maturity_max ?? 2);
      const prefPersonalityDialog = $("prefPersonalityDialog");
      if(prefPersonalityDialog) prefPersonalityDialog.value = state.prefs.ai_personality_dialog ? "true" : "false";
      const prefMaturityClicks = $("prefMaturityClicks");
      const prefUiClicks = $("prefUiClicks");
      if(prefMaturityClicks) prefMaturityClicks.value = String(state.prefs.ai_maturity_clicks ?? 4);
      if(prefUiClicks) prefUiClicks.value = String(state.prefs.ui_clicks ?? 4);
      const prefTestEditorLock = $("prefTestEditorLock");
      if(prefTestEditorLock) prefTestEditorLock.value = state.prefs.test_editor_lock || "locked";
      const prefMatrixControls = $("prefMatrixControls");
      if(prefMatrixControls) prefMatrixControls.value = state.prefs.bom_matrix_controls === false ? "false" : "true";
      $("prefNewTestTemplateMode").value = state.prefs.new_test_template_mode || "default";
      const defaultTemplateSelect = $("prefNewTestTemplateDefault");
      if(defaultTemplateSelect) defaultTemplateSelect.value = state.prefs.new_test_template_default || "__blank__";
      const dbgSel = $("prefAiReviewDebug");
      if(dbgSel) dbgSel.value = state.prefs.ai_review_debug ? "true" : "false";
      const pauseInput = $("prefAiReviewPause");
      if(pauseInput) pauseInput.value = String(state.prefs.ai_review_pause_ms ?? 300);
      const concInput = $("prefAiReviewConcurrency");
      if(concInput) concInput.value = String(state.prefs.ai_review_concurrency ?? 1);
      const prefSetPlanRoot = $("prefSetPlanRoot");
      if(prefSetPlanRoot){
        prefSetPlanRoot.onclick = () => runAsync(setPlanRoot().then(() => {
          const storageField = $("prefStorageMode");
          const folderField = $("prefLibraryFolder");
          if(storageField){
            storageField.textContent = state.planRootHandle ? "File System" : "Browser Store";
          }
          if(folderField){
            folderField.textContent = state.planRootHandle
              ? (state.planRootPath || state.planRootHandle.name || "Selected folder")
              : "Not set";
          }
        }));
      }
      footer.innerHTML = `
        <button class="btn" id="cancelPrefs">Cancel</button>
        <button class="btn primary" id="savePrefsBtn">Save</button>
      `;
      $("cancelPrefs").onclick = hideModal;
      $("prefRefreshModels").onclick = () => {
        if(!USE_PROXY && !getAiKey()){
          toast("Models", "Set an API key first.", "warn");
          return;
        }
        runAsync(refreshAvailableModels().then(list => {
          const selected = $("prefAiModel").value;
          $("prefAiModel").innerHTML = list.map(m => `<option value="${escapeHtml(m)}">${escapeHtml(m)}</option>`).join("");
          const still = list.includes(selected) ? selected : (state.prefs.ai_model || "");
          if(still && !list.includes(still)){
            const opt = document.createElement("option");
            opt.value = still;
            opt.textContent = `${still} (current)`;
            $("prefAiModel").appendChild(opt);
          }
          if(still) $("prefAiModel").value = still;
          toast("Models", `Loaded ${list.length} model(s).`, "ok");
        }));
      };
      $("prefAiModel").addEventListener("change", () => {
        const val = $("prefAiModel").value.trim() || "gpt-4.1-mini";
        state.prefs.ai_model = val;
        savePrefs();
        localStorage.setItem("tb26_prefs", JSON.stringify(state.prefs));
        logLine(`Preferences: ai_model set to ${val}.`, "ok");
        toast("AI Model", `Set to ${val}.`, "ok");
      });
      runAsync(async () => {
        const sel = $("prefNewTestTemplateDefault");
        if(!sel) return;
        const templates = await getAvailableTestTemplates(state.currentPlan);
        sel.innerHTML = templates.map(t => `<option value="${escapeHtml(t.id)}">${escapeHtml(t.name)}</option>`).join("");
        const chosen = state.prefs.new_test_template_default || "__blank__";
        sel.value = templates.some(t => t.id === chosen) ? chosen : "__blank__";
      });
      $("savePrefsBtn").onclick = () => {
        state.prefs.ai_enabled = $("prefAiEnabled").value === "true";
        state.prefs.ai_model = $("prefAiModel").value.trim() || "gpt-4.1-mini";
        const apiBaseVal = $("prefApiBase")?.value?.trim() || "";
        if(apiBaseVal){
          AI_PROXY_BASE = apiBaseVal.replace(/\/+$/,"");
          localStorage.setItem("tb26_api_base", AI_PROXY_BASE);
        }
        // proxy key removed
        state.prefs.ai_suggest_maturity_max = Number($("prefSuggestMax").value);
        state.prefs.ai_maturity_clicks = normalizeMaturityClicks($("prefMaturityClicks").value);
        state.prefs.ui_clicks = normalizeUiClicks($("prefUiClicks").value);
        const prefPersonalityDialog = $("prefPersonalityDialog");
        if(prefPersonalityDialog) state.prefs.ai_personality_dialog = prefPersonalityDialog.value === "true";
        state.prefs.test_editor_lock = $("prefTestEditorLock").value || "locked";
        const prefMatrixControls = $("prefMatrixControls");
        if(prefMatrixControls) state.prefs.bom_matrix_controls = prefMatrixControls.value === "true";
        state.prefs.new_test_template_mode = $("prefNewTestTemplateMode").value;
        state.prefs.new_test_template_default = $("prefNewTestTemplateDefault").value || "__blank__";
        const dbgSel = $("prefAiReviewDebug");
        if(dbgSel) state.prefs.ai_review_debug = dbgSel.value === "true";
        const pauseInput = $("prefAiReviewPause");
        if(pauseInput) state.prefs.ai_review_pause_ms = Math.max(0, Number(pauseInput.value) || 0);
        const concInput = $("prefAiReviewConcurrency");
        if(concInput) state.prefs.ai_review_concurrency = Math.max(1, Number(concInput.value) || 1);
        savePrefs();

        hideModal();
        logLine("Preferences saved.", "ok");
        toast("Preferences", "Saved.", "ok");
        runAsync(renderLibrary());
        if(state.currentPlan) renderEditor();
      };
    });
  }

  async function getAvailableTestTemplates(plan){
    const list = [
      { id: "__blank__", name: "Electronics Test", data: {} },
      {
        id: "__spec_requirements__",
        name: "Requirements (Spec)",
        data: {
          section_title: "Requirements",
          section_no: "SEC-000",
          section_type: "Requirements",
          param1_label: "",
          param1_value: "",
          param2_label: "",
          param2_value: "",
          functional_requirements: "",
          performance_requirements: "",
          environment_conditions: "",
          interfaces: "",
          inputs_outputs: "",
          constraints: "",
          _ai: {
            maturity: {
              section_title: 3,
              section_no: 0,
              section_type: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              functional_requirements: 0,
              performance_requirements: 0,
              environment_conditions: 0,
              interfaces: 0,
              inputs_outputs: 0,
              constraints: 0,
              last_ai_reviewed: 4,
              last_ai_review_model: 4,
              last_human_reviewed: 4,
              notes: 3
            },
            last_ai_reviewed: "2026-01-30T02:58:39.497Z",
            last_ai_review_model: "gpt-4.1-mini",
            last_human_reviewed: "2026-01-30T03:50:51.790Z",
            notes: "",
            review_personalities: {
              quality_assurance: {
                label: "Quality Assurance",
                last_reviewed: "2026-01-30T02:30:14.747Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Validate Section Title for completeness, clarity, and acceptance criteria. Guide: Enter the section title for this specification.",
                  section_no: "Validate Section ID for completeness, clarity, and acceptance criteria. Guide: Enter the section identifier (e.g., SEC-001).",
                  section_type: "Validate Section Type for completeness, clarity, and acceptance criteria. Guide: Describe the section type or category.",
                  param1_label: "Validate Param 1 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Validate Param 1 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Validate Param 2 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Validate Param 2 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 2's value.",
                  functional_requirements: "Validate Functional Requirements for completeness, clarity, and acceptance criteria. Guide: Provide a list of functional requirements. Be technical and correct.",
                  performance_requirements: "Validate Performance Requirements for completeness, clarity, and acceptance criteria. Guide: Provide a list of performance requirements. Make one to three sentences explaining each performance requirement in detail.",
                  environment_conditions: "Validate Environmental / Operating Conditions for completeness, clarity, and acceptance criteria. Guide: Provide the environmental / operating conditions for this specification section.",
                  interfaces: "Validate Interfaces for completeness, clarity, and acceptance criteria. Guide: Provide the interfaces for this specification section.",
                  inputs_outputs: "Validate Inputs / Outputs for completeness, clarity, and acceptance criteria. Guide: Provide the inputs / outputs for this specification section.",
                  constraints: "Validate Constraints / Limitations for completeness, clarity, and acceptance criteria. Guide: Provide the constraints / limitations for this specification section."
                }
              },
              design_engineer: {
                label: "Design Engineer",
                last_reviewed: "2026-01-30T02:30:14.747Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Verify Section Title is technically correct and aligned with design intent. Guide: Enter the section title for this specification.",
                  section_no: "Verify Section ID is technically correct and aligned with design intent. Guide: Enter the section identifier (e.g., SEC-001).",
                  section_type: "Verify Section Type is technically correct and aligned with design intent. Guide: Describe the section type or category.",
                  param1_label: "Verify Param 1 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Verify Param 1 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Verify Param 2 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Verify Param 2 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 2's value.",
                  functional_requirements: "Verify Functional Requirements is technically correct and aligned with design intent. Guide: Provide a list of functional requirements. Be technical and correct.",
                  performance_requirements: "Verify Performance Requirements is technically correct and aligned with design intent. Guide: Provide a list of performance requirements. Make one to three sentences explaining each performance requirement in detail.",
                  environment_conditions: "Verify Environmental / Operating Conditions is technically correct and aligned with design intent. Guide: Provide the environmental / operating conditions for this specification section.",
                  interfaces: "Verify Interfaces is technically correct and aligned with design intent. Guide: Provide the interfaces for this specification section.",
                  inputs_outputs: "Verify Inputs / Outputs is technically correct and aligned with design intent. Guide: Provide the inputs / outputs for this specification section.",
                  constraints: "Verify Constraints / Limitations is technically correct and aligned with design intent. Guide: Provide the constraints / limitations for this specification section."
                }
              },
              reliability_analyst: {
                label: "Reliability Analyst",
                last_reviewed: "2026-01-30T02:30:14.747Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Check Section Title for robustness and failure-mode coverage. Guide: Enter the section title for this specification.",
                  section_no: "Check Section ID for robustness and failure-mode coverage. Guide: Enter the section identifier (e.g., SEC-001).",
                  section_type: "Check Section Type for robustness and failure-mode coverage. Guide: Describe the section type or category.",
                  param1_label: "Check Param 1 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Check Param 1 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Check Param 2 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Check Param 2 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 2's value.",
                  functional_requirements: "Check Functional Requirements for robustness and failure-mode coverage. Guide: Provide a list of functional requirements. Be technical and correct.",
                  performance_requirements: "Check Performance Requirements for robustness and failure-mode coverage. Guide: Provide a list of performance requirements. Make one to three sentences explaining each performance requirement in detail.",
                  environment_conditions: "Check Environmental / Operating Conditions for robustness and failure-mode coverage. Guide: Provide the environmental / operating conditions for this specification section.",
                  interfaces: "Check Interfaces for robustness and failure-mode coverage. Guide: Provide the interfaces for this specification section.",
                  inputs_outputs: "Check Inputs / Outputs for robustness and failure-mode coverage. Guide: Provide the inputs / outputs for this specification section.",
                  constraints: "Check Constraints / Limitations for robustness and failure-mode coverage. Guide: Provide the constraints / limitations for this specification section."
                }
              }
            },
            field_labels: {
              section_title: "Section Title",
              section_no: "Section ID",
              section_type: "Section Type",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              functional_requirements: "Functional Requirements",
              performance_requirements: "Performance Requirements",
              environment_conditions: "Environmental / Operating Conditions",
              interfaces: "Interfaces",
              inputs_outputs: "Inputs / Outputs",
              constraints: "Constraints / Limitations"
            },
            field_prompts: {
              section_title: "Enter the section title for this specification.",
              section_no: "Enter the section identifier (e.g., SEC-001).",
              section_type: "Describe the section type or category.",
              param1_label: "Enter a label for parameter 1 (optional).",
              param1_value: "Select which field should supply parameter 1's value.",
              param2_label: "Enter a label for parameter 2 (optional).",
              param2_value: "Select which field should supply parameter 2's value.",
              functional_requirements: "Provide a list of functional requirements. Be technical and correct.",
              performance_requirements: "Provide a list of performance requirements. Make one to three sentences explaining each performance requirement in detail.",
              environment_conditions: "Provide the environmental / operating conditions for this specification section.",
              interfaces: "Provide the interfaces for this specification section.",
              inputs_outputs: "Provide the inputs / outputs for this specification section.",
              constraints: "Provide the constraints / limitations for this specification section."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              section_type: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              functional_requirements: "textarea",
              performance_requirements: "textarea",
              environment_conditions: "textarea",
              interfaces: "textarea",
              inputs_outputs: "textarea",
              constraints: "textarea"
            }
          }
        }
      },
      {
        id: "__vm_requirements_table__",
        name: "Requirements Table (VM)",
        data: {
          section_title: "Requirements Table",
          section_no: "VM-000",
          section_type: "Requirements Table",
          param1_label: "",
          param1_value: "",
          param2_label: "",
          param2_value: "",
          requirements_table: "REQ-001 | Provide regulated 5V output ±5%\nREQ-002 | Startup within 2 seconds\nREQ-003 | Operate from 9–15 VDC input",
          _ai: {
            maturity: {
              section_title: 3,
              section_no: 3,
              section_type: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              requirements_table: 2,
              last_ai_reviewed: 4,
              last_ai_review_model: 4,
              last_human_reviewed: 4,
              notes: 3
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "2026-01-30T04:01:51.322Z",
            notes: "",
            review_personalities: {
              quality_assurance: {
                label: "Quality Assurance",
                last_reviewed: "2026-01-30T03:30:46.597Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Validate Section Title for completeness, clarity, and acceptance criteria. Guide: Enter the section title for this verification matrix.",
                  section_no: "Validate Section ID for completeness, clarity, and acceptance criteria. Guide: Enter the section identifier (e.g., VM-001).",
                  section_type: "Validate Section Type for completeness, clarity, and acceptance criteria. Guide: Describe the section type or category.",
                  param1_label: "Validate Param 1 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Validate Param 1 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Validate Param 2 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Validate Param 2 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 2's value.",
                  requirements_table: "Validate Requirements Table for completeness, clarity, and acceptance criteria. Guide: Provide the requirements table for this verification matrix section."
                }
              },
              design_engineer: {
                label: "Design Engineer",
                last_reviewed: "2026-01-30T03:30:46.597Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Verify Section Title is technically correct and aligned with design intent. Guide: Enter the section title for this verification matrix.",
                  section_no: "Verify Section ID is technically correct and aligned with design intent. Guide: Enter the section identifier (e.g., VM-001).",
                  section_type: "Verify Section Type is technically correct and aligned with design intent. Guide: Describe the section type or category.",
                  param1_label: "Verify Param 1 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Verify Param 1 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Verify Param 2 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Verify Param 2 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 2's value.",
                  requirements_table: "Verify Requirements Table is technically correct and aligned with design intent. Guide: Provide the requirements table for this verification matrix section."
                }
              },
              reliability_analyst: {
                label: "Reliability Analyst",
                last_reviewed: "2026-01-30T03:30:46.597Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Check Section Title for robustness and failure-mode coverage. Guide: Enter the section title for this verification matrix.",
                  section_no: "Check Section ID for robustness and failure-mode coverage. Guide: Enter the section identifier (e.g., VM-001).",
                  section_type: "Check Section Type for robustness and failure-mode coverage. Guide: Describe the section type or category.",
                  param1_label: "Check Param 1 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Check Param 1 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Check Param 2 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Check Param 2 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 2's value.",
                  requirements_table: "Check Requirements Table for robustness and failure-mode coverage. Guide: Provide the requirements table for this verification matrix section."
                }
              }
            },
            field_labels: {
              section_title: "Section Title",
              section_no: "Section ID",
              section_type: "Section Type",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              requirements_table: "Requirements Table"
            },
            field_prompts: {
              section_title: "Enter the section title for this verification matrix.",
              section_no: "Enter the section identifier (e.g., VM-001).",
              section_type: "Describe the section type or category.",
              param1_label: "Enter a label for parameter 1 (optional).",
              param1_value: "Select which field should supply parameter 1's value.",
              param2_label: "Enter a label for parameter 2 (optional).",
              param2_value: "Select which field should supply parameter 2's value.",
              requirements_table: "Provide the requirements table for this verification matrix section."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              section_type: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              requirements_table: "textarea"
            }
          }
        }
      }
      ,
      {
        id: "__vm_verification_mapping__",
        name: "Verification Mapping (VM)",
        data: {
          section_title: "Verification Mapping",
          section_no: "VM-000",
          section_type: "Verification Mapping",
          param1_label: "",
          param1_value: "",
          param2_label: "",
          param2_value: "",
          verification_mapping: "REQ-001 → Test 003 (Power Voltages), Method: Test, Status: Planned\nREQ-002 → Test 004 (Input Power), Method: Test, Status: Planned\nREQ-003 → Test 004 (Input Power), Method: Test, Status: Planned",
          _ai: {
            maturity: {
              section_title: 3,
              section_no: 3,
              section_type: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              verification_mapping: 2,
              last_ai_reviewed: 4,
              last_ai_review_model: 4,
              last_human_reviewed: 4,
              notes: 3
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "2026-01-30T04:23:45.313Z",
            notes: "",
            review_personalities: {
              quality_assurance: {
                label: "Quality Assurance",
                last_reviewed: "2026-01-30T04:12:33.875Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Validate Section Title for completeness, clarity, and acceptance criteria. Guide: Enter the section title for this verification matrix.",
                  section_no: "Validate Section ID for completeness, clarity, and acceptance criteria. Guide: Enter the section identifier (e.g., VM-001).",
                  section_type: "Validate Section Type for completeness, clarity, and acceptance criteria. Guide: Describe the section type or category.",
                  param1_label: "Validate Param 1 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Validate Param 1 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Validate Param 2 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Validate Param 2 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 2's value.",
                  verification_mapping: "Validate Verification Mapping for completeness, clarity, and acceptance criteria. Guide: Provide the verification mapping for this verification matrix section."
                }
              },
              design_engineer: {
                label: "Design Engineer",
                last_reviewed: "2026-01-30T04:12:33.875Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Verify Section Title is technically correct and aligned with design intent. Guide: Enter the section title for this verification matrix.",
                  section_no: "Verify Section ID is technically correct and aligned with design intent. Guide: Enter the section identifier (e.g., VM-001).",
                  section_type: "Verify Section Type is technically correct and aligned with design intent. Guide: Describe the section type or category.",
                  param1_label: "Verify Param 1 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Verify Param 1 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Verify Param 2 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Verify Param 2 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 2's value.",
                  verification_mapping: "Verify Verification Mapping is technically correct and aligned with design intent. Guide: Provide the verification mapping for this verification matrix section."
                }
              },
              reliability_analyst: {
                label: "Reliability Analyst",
                last_reviewed: "2026-01-30T04:12:33.875Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Check Section Title for robustness and failure-mode coverage. Guide: Enter the section title for this verification matrix.",
                  section_no: "Check Section ID for robustness and failure-mode coverage. Guide: Enter the section identifier (e.g., VM-001).",
                  section_type: "Check Section Type for robustness and failure-mode coverage. Guide: Describe the section type or category.",
                  param1_label: "Check Param 1 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Check Param 1 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Check Param 2 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Check Param 2 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 2's value.",
                  verification_mapping: "Check Verification Mapping for robustness and failure-mode coverage. Guide: Provide the verification mapping for this verification matrix section."
                }
              }
            },
            field_labels: {
              section_title: "Section Title",
              section_no: "Section ID",
              section_type: "Section Type",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              verification_mapping: "Verification Mapping"
            },
            field_prompts: {
              section_title: "Enter the section title for this verification matrix.",
              section_no: "Enter the section identifier (e.g., VM-001).",
              section_type: "Describe the section type or category.",
              param1_label: "Enter a label for parameter 1 (optional).",
              param1_value: "Select which field should supply parameter 1's value.",
              param2_label: "Enter a label for parameter 2 (optional).",
              param2_value: "Select which field should supply parameter 2's value.",
              verification_mapping: "Provide the verification mapping for this verification matrix section."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              section_type: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              verification_mapping: "textarea"
            }
          }
        }
      }
      ,
      {
        id: "__fmea_failure_mode__",
        name: "Failure Mode (FMEA)",
        data: {
          section_title: "Failure Mode 1",
          section_no: "FMEA-000",
          section_type: "Failure Mode",
          param1_label: "",
          param1_value: "",
          param2_label: "",
          param2_value: "",
          item_function: "",
          failure_mode: "",
          effect: "",
          cause: "",
          severity: "",
          occurrence: "",
          detection: "",
          rpn: "",
          current_controls: "",
          recommended_actions: "",
          action_owner_due: "",
          action_status: "",
          verification_method: "",
          acceptance_criteria: "",
          test_plan_reference: "",
          _ai: {
            maturity: {
              section_title: 1,
              section_no: 1,
              section_type: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              item_function: 0,
              failure_mode: 0,
              effect: 0,
              cause: 0,
              severity: 2,
              occurrence: 2,
              detection: 2,
              rpn: 4,
              current_controls: 0,
              recommended_actions: 0,
              action_owner_due: 0,
              action_status: 0,
              verification_method: 0,
              acceptance_criteria: 0,
              test_plan_reference: 0,
              last_ai_reviewed: 4,
              last_ai_review_model: 4,
              last_human_reviewed: 4,
              notes: 3
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "2026-01-30T17:12:06.060Z",
            notes: "",
            review_personalities: {
              quality_assurance: {
                label: "Quality Assurance",
                last_reviewed: "2026-01-30T17:11:13.930Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Validate Section Title for completeness, clarity, and acceptance criteria. Guide: Enter the section title for this FMEA document.",
                  section_no: "Validate Section ID for completeness, clarity, and acceptance criteria. Guide: Enter the section identifier (e.g., FMEA-003).",
                  section_type: "Validate Section Type for completeness, clarity, and acceptance criteria. Guide: Describe the section type or category.",
                  param1_label: "Validate Param 1 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Validate Param 1 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Validate Param 2 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Validate Param 2 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 2's value.",
                  item_function: "Validate Item / Function for completeness, clarity, and acceptance criteria. Guide: Provide the item / function for this failure mode.",
                  failure_mode: "Validate Failure Mode for completeness, clarity, and acceptance criteria. Guide: Provide the failure mode for this failure mode.",
                  effect: "Validate Effect for completeness, clarity, and acceptance criteria. Guide: Provide the effect for this failure mode.",
                  cause: "Validate Cause for completeness, clarity, and acceptance criteria. Guide: Provide the cause for this failure mode.",
                  severity: "Validate Severity for completeness, clarity, and acceptance criteria. Guide: Select a value from 1–10.",
                  occurrence: "Validate Occurrence for completeness, clarity, and acceptance criteria. Guide: Select a value from 1–10.",
                  detection: "Validate Detection for completeness, clarity, and acceptance criteria. Guide: Select a value from 1–10.",
                  rpn: "Validate RPN for completeness, clarity, and acceptance criteria. Guide: Auto-computed from Severity × Occurrence × Detection.",
                  current_controls: "Validate Current Controls for completeness, clarity, and acceptance criteria. Guide: Provide the current controls for this failure mode.",
                  recommended_actions: "Validate Recommended Actions for completeness, clarity, and acceptance criteria. Guide: Provide the recommended actions for this failure mode.",
                  action_owner_due: "Validate Action Owner / Due Date for completeness, clarity, and acceptance criteria. Guide: Provide the action owner / due date for this failure mode.",
                  action_status: "Validate Action Status for completeness, clarity, and acceptance criteria. Guide: Provide the action status for this failure mode.",
                  verification_method: "Validate Verification Method for completeness, clarity, and acceptance criteria. Guide: Provide the verification method for this failure mode.",
                  acceptance_criteria: "Validate Acceptance Criteria for completeness, clarity, and acceptance criteria. Guide: Provide the acceptance criteria for this failure mode.",
                  test_plan_reference: "Validate Test Plan Reference for completeness, clarity, and acceptance criteria. Guide: Provide the test plan reference for this failure mode."
                }
              },
              design_engineer: {
                label: "Design Engineer",
                last_reviewed: "2026-01-30T17:11:13.930Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Verify Section Title is technically correct and aligned with design intent. Guide: Enter the section title for this FMEA document.",
                  section_no: "Verify Section ID is technically correct and aligned with design intent. Guide: Enter the section identifier (e.g., FMEA-003).",
                  section_type: "Verify Section Type is technically correct and aligned with design intent. Guide: Describe the section type or category.",
                  param1_label: "Verify Param 1 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Verify Param 1 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Verify Param 2 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Verify Param 2 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 2's value.",
                  item_function: "Verify Item / Function is technically correct and aligned with design intent. Guide: Provide the item / function for this failure mode.",
                  failure_mode: "Verify Failure Mode is technically correct and aligned with design intent. Guide: Provide the failure mode for this failure mode.",
                  effect: "Verify Effect is technically correct and aligned with design intent. Guide: Provide the effect for this failure mode.",
                  cause: "Verify Cause is technically correct and aligned with design intent. Guide: Provide the cause for this failure mode.",
                  severity: "Verify Severity is technically correct and aligned with design intent. Guide: Select a value from 1–10.",
                  occurrence: "Verify Occurrence is technically correct and aligned with design intent. Guide: Select a value from 1–10.",
                  detection: "Verify Detection is technically correct and aligned with design intent. Guide: Select a value from 1–10.",
                  rpn: "Verify RPN is technically correct and aligned with design intent. Guide: Auto-computed from Severity × Occurrence × Detection.",
                  current_controls: "Verify Current Controls is technically correct and aligned with design intent. Guide: Provide the current controls for this failure mode.",
                  recommended_actions: "Verify Recommended Actions is technically correct and aligned with design intent. Guide: Provide the recommended actions for this failure mode.",
                  action_owner_due: "Verify Action Owner / Due Date is technically correct and aligned with design intent. Guide: Provide the action owner / due date for this failure mode.",
                  action_status: "Verify Action Status is technically correct and aligned with design intent. Guide: Provide the action status for this failure mode.",
                  verification_method: "Verify Verification Method is technically correct and aligned with design intent. Guide: Provide the verification method for this failure mode.",
                  acceptance_criteria: "Verify Acceptance Criteria is technically correct and aligned with design intent. Guide: Provide the acceptance criteria for this failure mode.",
                  test_plan_reference: "Verify Test Plan Reference is technically correct and aligned with design intent. Guide: Provide the test plan reference for this failure mode."
                }
              },
              reliability_analyst: {
                label: "Reliability Analyst",
                last_reviewed: "2026-01-30T17:11:13.930Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Check Section Title for robustness and failure-mode coverage. Guide: Enter the section title for this FMEA document.",
                  section_no: "Check Section ID for robustness and failure-mode coverage. Guide: Enter the section identifier (e.g., FMEA-003).",
                  section_type: "Check Section Type for robustness and failure-mode coverage. Guide: Describe the section type or category.",
                  param1_label: "Check Param 1 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Check Param 1 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Check Param 2 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Check Param 2 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 2's value.",
                  item_function: "Check Item / Function for robustness and failure-mode coverage. Guide: Provide the item / function for this failure mode.",
                  failure_mode: "Check Failure Mode for robustness and failure-mode coverage. Guide: Provide the failure mode for this failure mode.",
                  effect: "Check Effect for robustness and failure-mode coverage. Guide: Provide the effect for this failure mode.",
                  cause: "Check Cause for robustness and failure-mode coverage. Guide: Provide the cause for this failure mode.",
                  severity: "Check Severity for robustness and failure-mode coverage. Guide: Select a value from 1–10.",
                  occurrence: "Check Occurrence for robustness and failure-mode coverage. Guide: Select a value from 1–10.",
                  detection: "Check Detection for robustness and failure-mode coverage. Guide: Select a value from 1–10.",
                  rpn: "Check RPN for robustness and failure-mode coverage. Guide: Auto-computed from Severity × Occurrence × Detection.",
                  current_controls: "Check Current Controls for robustness and failure-mode coverage. Guide: Provide the current controls for this failure mode.",
                  recommended_actions: "Check Recommended Actions for robustness and failure-mode coverage. Guide: Provide the recommended actions for this failure mode.",
                  action_owner_due: "Check Action Owner / Due Date for robustness and failure-mode coverage. Guide: Provide the action owner / due date for this failure mode.",
                  action_status: "Check Action Status for robustness and failure-mode coverage. Guide: Provide the action status for this failure mode.",
                  verification_method: "Check Verification Method for robustness and failure-mode coverage. Guide: Provide the verification method for this failure mode.",
                  acceptance_criteria: "Check Acceptance Criteria for robustness and failure-mode coverage. Guide: Provide the acceptance criteria for this failure mode.",
                  test_plan_reference: "Check Test Plan Reference for robustness and failure-mode coverage. Guide: Provide the test plan reference for this failure mode."
                }
              }
            },
            field_labels: {
              section_title: "Section Title",
              section_no: "Section ID",
              section_type: "Section Type",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              item_function: "Item / Function",
              failure_mode: "Failure Mode",
              effect: "Effect",
              cause: "Cause",
              severity: "Severity",
              occurrence: "Occurrence",
              detection: "Detection",
              rpn: "RPN",
              current_controls: "Current Controls",
              recommended_actions: "Recommended Actions",
              action_owner_due: "Action Owner / Due Date",
              action_status: "Action Status",
              verification_method: "Verification Method",
              acceptance_criteria: "Acceptance Criteria",
              test_plan_reference: "Test Plan Reference"
            },
            field_prompts: {
              section_title: "Enter the section title for this FMEA document.",
              section_no: "Enter the section identifier (e.g., FMEA-003).",
              section_type: "Describe the section type or category.",
              param1_label: "Enter a label for parameter 1 (optional).",
              param1_value: "Select which field should supply parameter 1's value.",
              param2_label: "Enter a label for parameter 2 (optional).",
              param2_value: "Select which field should supply parameter 2's value.",
              item_function: "Provide the item / function for this failure mode.",
              failure_mode: "Provide the failure mode for this failure mode.",
              effect: "Provide the effect for this failure mode.",
              cause: "Provide the cause for this failure mode.",
              severity: "Select a value from 1–10.",
              occurrence: "Select a value from 1–10.",
              detection: "Select a value from 1–10.",
              rpn: "Auto-computed from Severity × Occurrence × Detection.",
              current_controls: "Provide the current controls for this failure mode.",
              recommended_actions: "Provide the recommended actions for this failure mode.",
              action_owner_due: "Provide the action owner / due date for this failure mode.",
              action_status: "Provide the action status for this failure mode.",
              verification_method: "Provide the verification method for this failure mode.",
              acceptance_criteria: "Provide the acceptance criteria for this failure mode.",
              test_plan_reference: "Provide the test plan reference for this failure mode."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              section_type: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              item_function: "text",
              failure_mode: "text",
              effect: "textarea",
              cause: "textarea",
              severity: "select",
              occurrence: "select",
              detection: "select",
              rpn: "computed",
              current_controls: "textarea",
              recommended_actions: "textarea",
              action_owner_due: "text",
              action_status: "text",
              verification_method: "textarea",
              acceptance_criteria: "textarea",
              test_plan_reference: "textarea"
            },
            field_options: {
              severity: ["1","2","3","4","5","6","7","8","9","10"],
              occurrence: ["1","2","3","4","5","6","7","8","9","10"],
              detection: ["1","2","3","4","5","6","7","8","9","10"]
            }
          }
        }
      },
      {
        id: "__bom_table__",
        name: "BOM Table",
        data: {
          section_title: "BOM Table",
          section_no: "BOM-002",
          section_type: "BOM Table",
          param1_label: "",
          param1_value: "",
          param2_label: "",
          param2_value: "",
          bom_matrix: {
            rows: ["001","002","003","004","005"],
            cols: ["item","refdes","qty","description","value","package","mfr_1","mpn_1","mfr_2","mpn_2","mfr_3","mpn_3","notes"],
            row_labels: {
              "001": "001",
              "002": "002",
              "003": "003",
              "004": "004",
              "005": "005"
            },
            col_labels: {
              item: "Item",
              refdes: "RefDes",
              qty: "Qty",
              description: "Description",
              value: "Value",
              package: "Package",
              mfr_1: "Manufacturer 1",
              mpn_1: "Manufacturer P/N 1",
              mfr_2: "Manufacturer 2",
              mpn_2: "Manufacturer P/N 2",
              mfr_3: "Manufacturer 3",
              mpn_3: "Manufacturer P/N 3",
              notes: "Notes"
            },
            cells: {}
          },
          _ai: {
            maturity: {
              section_title: 3,
              section_no: 3,
              section_type: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              bom_matrix: 2,
              last_ai_reviewed: 4,
              last_ai_review_model: 4,
              last_human_reviewed: 4,
              notes: 3
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "",
            notes: "",
            review_personalities: {
              quality_assurance: {
                label: "Quality Assurance",
                last_reviewed: "2026-01-30T20:00:08.974Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Validate Section Title for completeness, clarity, and acceptance criteria. Guide: Enter the section title for this bill of materials.",
                  section_no: "Validate Section ID for completeness, clarity, and acceptance criteria. Guide: Enter the section identifier (e.g., BOM-001).",
                  section_type: "Validate Section Type for completeness, clarity, and acceptance criteria. Guide: Describe the section type or category.",
                  param1_label: "Validate Param 1 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Validate Param 1 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Validate Param 2 Label for completeness, clarity, and acceptance criteria. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Validate Param 2 Value for completeness, clarity, and acceptance criteria. Guide: Select which field should supply parameter 2's value.",
                  bom_matrix: "Validate BOM Matrix for completeness, clarity, and acceptance criteria. Guide: Provide the bill of materials table with items, quantities, and manufacturer details."
                }
              },
              design_engineer: {
                label: "Design Engineer",
                last_reviewed: "2026-01-30T20:00:08.974Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Verify Section Title is technically correct and aligned with design intent. Guide: Enter the section title for this bill of materials.",
                  section_no: "Verify Section ID is technically correct and aligned with design intent. Guide: Enter the section identifier (e.g., BOM-001).",
                  section_type: "Verify Section Type is technically correct and aligned with design intent. Guide: Describe the section type or category.",
                  param1_label: "Verify Param 1 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Verify Param 1 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Verify Param 2 Label is technically correct and aligned with design intent. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Verify Param 2 Value is technically correct and aligned with design intent. Guide: Select which field should supply parameter 2's value.",
                  bom_matrix: "Verify BOM Matrix is technically correct and aligned with design intent. Guide: Provide the bill of materials table with items, quantities, and manufacturer details."
                }
              },
              reliability_analyst: {
                label: "Reliability Analyst",
                last_reviewed: "2026-01-30T20:00:08.974Z",
                model: "seed",
                summary: "Seed review comments generated for all fields.",
                notes: "",
                field_comments: {
                  section_title: "Check Section Title for robustness and failure-mode coverage. Guide: Enter the section title for this bill of materials.",
                  section_no: "Check Section ID for robustness and failure-mode coverage. Guide: Enter the section identifier (e.g., BOM-001).",
                  section_type: "Check Section Type for robustness and failure-mode coverage. Guide: Describe the section type or category.",
                  param1_label: "Check Param 1 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 1 (optional).",
                  param1_value: "Check Param 1 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 1's value.",
                  param2_label: "Check Param 2 Label for robustness and failure-mode coverage. Guide: Enter a label for parameter 2 (optional).",
                  param2_value: "Check Param 2 Value for robustness and failure-mode coverage. Guide: Select which field should supply parameter 2's value.",
                  bom_matrix: "Check BOM Matrix for robustness and failure-mode coverage. Guide: Provide the bill of materials table with items, quantities, and manufacturer details."
                }
              }
            },
            field_labels: {
              section_title: "Section Title",
              section_no: "Section ID",
              section_type: "Section Type",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              bom_matrix: "BOM Matrix"
            },
            field_prompts: {
              section_title: "Enter the section title for this bill of materials.",
              section_no: "Enter the section identifier (e.g., BOM-001).",
              section_type: "Describe the section type or category.",
              param1_label: "Enter a label for parameter 1 (optional).",
              param1_value: "Select which field should supply parameter 1's value.",
              param2_label: "Enter a label for parameter 2 (optional).",
              param2_value: "Select which field should supply parameter 2's value.",
              bom_matrix: "Provide the bill of materials table with items, quantities, and manufacturer details."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              section_type: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              bom_matrix: "matrix"
            },
            field_options: {},
            field_schema: {
              bom_matrix: {
                rows: [
                  { id: "001", label: "001" },
                  { id: "002", label: "002" },
                  { id: "003", label: "003" },
                  { id: "004", label: "004" },
                  { id: "005", label: "005" }
                ],
                cols: [
                  { id: "item", label: "Item" },
                  { id: "refdes", label: "RefDes" },
                  { id: "qty", label: "Qty" },
                  { id: "description", label: "Description" },
                  { id: "value", label: "Value" },
                  { id: "package", label: "Package" },
                  { id: "mfr_1", label: "Manufacturer 1" },
                  { id: "mpn_1", label: "Manufacturer P/N 1" },
                  { id: "mfr_2", label: "Manufacturer 2" },
                  { id: "mpn_2", label: "Manufacturer P/N 2" },
                  { id: "mfr_3", label: "Manufacturer 3" },
                  { id: "mpn_3", label: "Manufacturer P/N 3" },
                  { id: "notes", label: "Notes" }
                ],
                col_prompts: {
                  item: "Item number.",
                  refdes: "Reference designators (e.g., R1,R2,C5).",
                  qty: "Quantity.",
                  description: "Part description.",
                  value: "Part value.",
                  package: "Package or footprint.",
                  mfr_1: "Primary manufacturer.",
                  mpn_1: "Primary manufacturer part number.",
                  mfr_2: "Alternate manufacturer.",
                  mpn_2: "Alternate manufacturer part number.",
                  mfr_3: "Second alternate manufacturer.",
                  mpn_3: "Second alternate manufacturer part number.",
                  notes: "Notes (e.g., DNP, orientation, assembly notes)."
                }
              }
            }
          }
        }
      }
    ];
    if(state.planRootHandle && plan){
      const extra = await fsListTestTemplates(plan);
      for(const t of extra) list.push(t);
    }
    return list;
  }

  function pickTestTemplate(templates){
    return new Promise(resolve => {
      if(!templates || !templates.length){
        toast("Templates", "No list item templates found.", "warn");
        return resolve(null);
      }
      const options = templates.map(t =>
        `<option value="${escapeHtml(t.id)}">${escapeHtml(t.name)}</option>`
      ).join("");
      showModal("Choose List Item Template", (body, footer) => {
        body.innerHTML = `
          <div class="label">Template</div>
          <select class="select" id="testTemplatePick">${options}</select>
          <div class="hint">Templates are loaded from the document's tests/templates folder.</div>
        `;
        footer.innerHTML = `
          <button class="btn" id="cancelTemplatePick">Cancel</button>
          <button class="btn primary" id="confirmTemplatePick">Create Test</button>
        `;
        $("cancelTemplatePick").onclick = () => { hideModal(); resolve(null); };
        $("confirmTemplatePick").onclick = () => {
          const id = $("testTemplatePick").value;
          const chosen = templates.find(t => t.id === id) || templates[0];
          hideModal();
          resolve(chosen);
        };
      });
    });
  }

  async function createTestTemplateFromData(plan, name, data){
    const root = await ensurePlanRootHandle();
    if(!root){
      toast("Templates", "Grant folder access to save templates.", "warn");
      return false;
    }
    const templatesDir = await fsEnsureTestTemplatesDir(plan, true);
    if(!templatesDir){
      toast("Templates", "Library folder not set or unavailable.", "warn");
      return false;
    }
    let baseName = (name || "template").trim();
    if(!baseName) baseName = "template";
    let file = makeTestTemplateFileName(baseName);
    let i = 2;
    while(true){
      try{
        await templatesDir.getFileHandle(file);
        file = makeTestTemplateFileName(`${baseName}_${i++}`);
      }catch{
        break;
      }
    }
    const payload = { data: normalizeTestData(data || {}) };
    try{
      await fsWriteText(templatesDir, file, JSON.stringify(payload, null, 2), "application/json");
      const location = state.currentTemplateId ? "template/tests/templates" : "plan/tests/templates";
      logLine(`Template saved: ${file} (${location})`, "ok");
      return true;
    }catch(e){
      logLine(`Template save failed: ${e.message || e}`, "warn");
      toast("Templates", "Template save failed. Check folder permissions.", "warn");
      return false;
    }
  }

  async function deleteTestTemplate(plan, file){
    const templatesDir = await fsEnsureTestTemplatesDir(plan, false);
    if(!templatesDir) return false;
    try{
      await templatesDir.removeEntry(file);
      return true;
    }catch{
      return false;
    }
  }

  async function refreshTemplateList(){
    if(!state.currentTestTemplate?.basePlanId) return;
    const basePlan = await Store.loadPlan(state.currentTestTemplate.basePlanId).catch(() => null);
    if(!basePlan) return;
    state.templateListCache = await getAvailableTestTemplates(basePlan);
    renderTestsList();
  }

  async function openManageTestTemplates(){
    const plan = state.currentPlan;
    if(!plan){
      toast("Templates", "Open a document first.", "warn");
      return;
    }
    if(!state.planRootHandle){
      toast("Templates", "Set a Library Folder to use list item templates.", "warn");
      return;
    }
    const templates = await getAvailableTestTemplates(plan);
    showModal("Manage Test Templates", (body, footer) => {
      const list = templates.filter(t => t.id !== "__blank__");
      const rows = list.map(t => `
        <div class="item" data-file="${escapeHtml(t.file)}">
          <div class="left">
            <div class="name">${escapeHtml(t.name)}</div>
            <div class="meta"><span class="tag">${escapeHtml(t.file)}</span></div>
          </div>
          <div class="actions">
            <button class="btn mini danger" data-del="${escapeHtml(t.file)}">Delete</button>
          </div>
        </div>
      `).join("");
      const loc = state.currentTemplateId ? "template/tests/templates" : "plan/tests/templates";
      body.innerHTML = `
        <div class="toolbarRow" style="margin-bottom:10px;">
          <button class="btn mini" id="tmplRefresh">Refresh</button>
          <button class="btn mini primary" id="tmplCreateFromCurrent">Create From Current Test</button>
          <button class="btn mini" id="tmplCreateBlank">Create Blank Template</button>
        </div>
        <div class="hint" style="margin-bottom:10px;">Saved in ${escapeHtml(loc)}.</div>
        <div class="list" style="border:1px solid var(--border); border-radius:12px; overflow:hidden;">
          ${rows || `<div class="item"><div class="left"><div class="name">(No templates yet)</div></div></div>`}
        </div>
      `;
      footer.innerHTML = `<button class="btn" id="tmplClose">Close</button>`;
      $("tmplClose").onclick = hideModal;
      $("tmplRefresh").onclick = () => { hideModal(); runAsync(openManageTestTemplates()); };
      $("tmplCreateFromCurrent").onclick = async () => {
        const test = currentTest();
        if(!test){
          toast("Templates", "Select a list item first.", "warn");
          return;
        }
        const name = prompt("Template name:", test.data?.section_title || "New Test Template");
        if(name === null) return;
        const ok = await createTestTemplateFromData(plan, name, test.data);
        if(ok){
          toast("Templates", "Template created.", "ok");
          hideModal();
          runAsync(openManageTestTemplates());
        }
      };
      $("tmplCreateBlank").onclick = async () => {
        const name = prompt("Template name:", "Blank Test Template");
        if(name === null) return;
        const ok = await createTestTemplateFromData(plan, name, {});
        if(ok){
          toast("Templates", "Template created.", "ok");
          hideModal();
          runAsync(openManageTestTemplates());
        }
      };
      body.querySelectorAll("[data-del]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const file = btn.getAttribute("data-del");
          if(!file) return;
          if(!confirm(`Delete template ${file}?`)) return;
          const ok = await deleteTestTemplate(plan, file);
          if(ok){
            toast("Templates", "Template deleted.", "warn");
            hideModal();
            runAsync(openManageTestTemplates());
          }else{
            toast("Templates", "Delete failed.", "warn");
          }
        });
      });
      body.querySelectorAll(".item[data-file]").forEach(row => {
        row.addEventListener("click", async (e) => {
          if(e.target.closest("button")) return;
          const file = row.getAttribute("data-file");
          if(!file) return;
          const chosen = list.find(t => t.file === file);
          if(!chosen) return;
          hideModal();
          await openTestTemplateEditor(chosen, plan.id);
        });
      });
    });
  }

  async function openTestTemplateEditor(template, basePlanId){
    const basePlan = basePlanId ? await Store.loadPlan(basePlanId).catch(() => null) : null;
    if(!basePlan){
      toast("Templates", "Base document not found.", "warn");
      return;
    }
    state.templateEditReturnPlanId = basePlan.id;
    const testData = normalizeTestData(structuredClone(template.data || {}));
    const tempPlan = {
      id: `template_test_${uid()}`,
      name: `Template: ${template.name}`,
      slug: slugifyPlanName(`template_${template.name}`),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      tests: [{ id: uid(), order: 1, modified: true, data: testData }],
      markdown: "",
      userNotes: ""
    };
    state.currentPlan = tempPlan;
    state.currentTemplateId = null;
    state.currentTestId = tempPlan.tests[0].id;
    state.currentTestTemplate = {
      file: template.file,
      name: template.name,
      basePlanId: basePlan.id
    };
    await refreshTemplateList();
    showEditor();
    renderEditor();
    toast("Template edit", `Editing ${template.name}`, "ok");
  }

  /* ---------- API Key (proxy-only UI removed) ---------- */
  const AI_SESSION_KEY = "tb26_ai_key_session";
  const AI_LOCAL_KEY = "tb26_ai_key_local";

  function getAiKey(){
    return sessionStorage.getItem(AI_SESSION_KEY) || localStorage.getItem(AI_LOCAL_KEY) || "";
  }

  async function refreshAvailableModels(){
    const key = getAiKey();
    if(!USE_PROXY && !key) throw new Error("No API key set");
    const resp = await fetch(apiUrl("/models"), {
      method: "GET",
      headers: USE_PROXY ? {} : { "Authorization": `Bearer ${key}` }
    });
    if(!resp.ok){
      const t = await resp.text().catch(()=> "");
      throw new Error(`HTTP ${resp.status}: ${t.slice(0,160)}`);
    }
    const data = await resp.json();
    const ids = (data?.data || []).map(m => m?.id).filter(Boolean);
    const unique = Array.from(new Set(ids)).sort();
    state.modelList = unique;
    saveModelCache(unique);
    return unique;
  }

    function updateAiBadge(){
      $("aiLed").className = "led ok";
      $("aiText").textContent = "Proxy";
      updateAiUI();
    }

    function updateAiUI(){
      const btn = $("btnAiSuggest");
      if(btn){
        btn.disabled = false;
        btn.title = "Suggest text for the focused field";
      }
      const keyText = $("aiKeyText");
      if(keyText) keyText.textContent = "Proxy";
    }

    function extractResponseText(data){
      if(!data) return "";
      if(typeof data.output_text === "string") return data.output_text.trim();
      if(Array.isArray(data.output)){
        let out = "";
        for(const item of data.output){
          const content = item.content || [];
          for(const c of content){
            if(c.type === "output_text" && typeof c.text === "string") out += c.text;
            if(c.type === "text" && typeof c.text === "string") out += c.text;
          }
        }
        return out.trim();
      }
      return "";
    }

    function getFieldMaturity(test, field){
      return Number(test?.data?._ai?.maturity?.[field] ?? 0);
    }

    function setFieldMaturity(test, field, val){
      if(!test?.data) return;
      if(!test.data._ai) test.data._ai = { maturity:{} };
      if(!test.data._ai.maturity) test.data._ai.maturity = {};
      test.data._ai.maturity[field] = Number.isFinite(val) ? val : 0;
    }

    function isTodoValue(val){
      return /to\s*do/i.test(String(val || "")) || /^todo:/i.test(String(val || ""));
    }

    function getSuggestStatus(testId, field){
      return state.aiSuggestStatus?.[testId]?.[field] || "";
    }

    function setSuggestStatus(testId, field, status){
      if(!state.aiSuggestStatus[testId]) state.aiSuggestStatus[testId] = {};
      if(status) state.aiSuggestStatus[testId][field] = status;
      else delete state.aiSuggestStatus[testId][field];
    }

    function fieldsNeedingSuggestion(test){
      const maxMaturity = Number(state.prefs.ai_suggest_maturity_max ?? 2);
      const keys = getFieldKeys(test);
      const out = [];
      for(const k of keys){
        if(["param1_label","param1_value","param2_label","param2_value"].includes(k)) continue;
        const v = (test.data[k] ?? "");
        const m = getFieldMaturity(test, k);
        if(m >= 3) continue; // do not touch M3/M4
        const todo = isTodoValue(v);
        if(todo || m <= maxMaturity){
          if(["ll","tv","ul","units"].includes(k) && String(v).trim().toUpperCase() === "N/A") continue;
          out.push(k);
        }
      }
      return out;
    }

    async function suggestForField(test, field){
      const key = getAiKey();
      if(!USE_PROXY && !key) throw new Error("No API key set");
      if(["ll","tv","ul","units"].includes(field)){
        const cur = String(test.data[field] ?? "").trim().toUpperCase();
        if(cur === "N/A") return { noChange: true, rationale: "Left as N/A." };
      }
      const plan = state.currentPlan || {};
      const mdMeta = extractPlanMetaFromMarkdown(plan?.markdown || "");
      const guidance = plan?.ai_review_guidance || mdMeta.aiReviewGuidance || "";
      const payload = {
        plan: { name: plan.name || "", goal: plan.goal || mdMeta.goal || "", scope: plan.scope || mdMeta.scope || "", ai_review_guidance: guidance },
        section_no: test.data.section_no || "",
        section_title: test.data.section_title || "",
        field,
        current_value: test.data[field] || "",
        field_prompt: test.data?._ai?.field_prompts?.[field] || "",
        field_label: test.data?._ai?.field_labels?.[field] || field,
        context: test.data
      };
      const model = state.prefs.ai_model || "gpt-4.1-mini";
      const current = String(test.data[field] ?? "").trim();

      async function callSuggestion(forceDifferent){
        const isLimitField = ["ll","tv","ul","units"].includes(field);
        const system = forceDifferent
          ? getAiPrompt(plan, "suggest_field_strict")
          : getAiPrompt(plan, "suggest_field");
        const limitsNote = isLimitField
          ? getAiPrompt(plan, "suggest_limits_note")
          : "";
        const resp = await fetch(apiUrl("/suggest"), {
          method: "POST",
          headers: apiHeaders(),
          body: JSON.stringify({
            model,
            input: [
              { role:"system", content: system },
              { role:"user", content: JSON.stringify(payload, null, 2) },
              ...(limitsNote ? [{ role:"system", content: limitsNote }] : [])
            ],
            max_output_tokens: 500
          })
        });
        if(!resp.ok){
          const t = await resp.text().catch(()=> "");
          throw new Error(`HTTP ${resp.status}: ${t.slice(0,160)}`);
        }
        const data = await resp.json();
        const raw = extractResponseText(data);
        if(!raw) throw new Error("No text returned");
        let parsed = null;
        try{
          parsed = JSON.parse(raw);
        }catch{
          // fallback: treat as value, attach generic rationale
          parsed = { value: raw, rationale: "Suggested improvement from AI." };
        }
        let value = parsed.value;
        if(value && typeof value === "object"){
          // force a retry with stricter prompt rather than leaking [object Object]
          if(!forceDifferent) return await callSuggestion(true);
          throw new Error("AI returned non-string value.");
        }
        value = String(value ?? "").trim();
        const rationale = String(parsed.rationale ?? "").trim() || "Suggested improvement from AI.";
        return { value, rationale };
      }

      let result = await callSuggestion(false);
      if(!result.value) throw new Error("No value returned");
      if(result.value.trim() === current){
        result = await callSuggestion(true);
      }
      if(result.value.trim() === current) return { noChange: true, rationale: result.rationale || "No meaningful change returned." };
      result.value = sanitizeAiText(result.value);
      result.rationale = sanitizeAiText(result.rationale);
      return result;
    }

    async function aiSuggestFocusedField(fieldOverride){
      const test = currentTest();
      if(!test){
      toast("AI Suggest", "Select a list item first.", "warn");
        logLine("AI Suggest: no list item selected.", "warn");
        return;
      }
      state.prefs = loadPrefs();
      const key = getAiKey();
      if(!USE_PROXY && !key){
        toast("AI Suggest", "Set an API key first.", "warn");
        logLine("AI Suggest: no API key available.", "warn");
        return;
      }
      const model = state.prefs.ai_model || "gpt-4.1-mini";
      logLine(`AI Suggest: using model "${model}".`, "ok");
      const targets = [];
      if(fieldOverride && Object.prototype.hasOwnProperty.call(test.data || {}, fieldOverride)){
        targets.push(fieldOverride);
      }else{
        const lowMaturity = fieldsNeedingSuggestion(test);
        if(!lowMaturity.length){
          const focused = state.focusField || document.activeElement?.getAttribute?.("data-field");
          if(!focused){
            toast("AI Suggest", "No low-maturity fields found.", "warn");
            logLine("AI Suggest: no low-maturity fields.", "warn");
            return;
          }
          targets.push(focused);
        }else{
          targets.push(...lowMaturity);
        }
      }
      logLine(`AI Suggest: ${targets.length} field(s) queued (maturity <= ${state.prefs.ai_suggest_maturity_max}).`, "ok");
      for(const f of targets) setSuggestStatus(test.id, f, "pending");
      renderForm();
      try{
        const suggestions = [];
        for(const field of targets){
          setSuggestStatus(test.id, field, "working");
          renderForm();
          logLine(`AI Suggest: requesting "${field}"...`, "ok");
          try{
            const res = await suggestForField(test, field);
            setSuggestStatus(test.id, field, "pending");
            if(res && res.noChange){
              suggestions.push({ field, current: test.data[field] || "", proposed: "", noChange: true, rationale: res.rationale || "" });
            }else if(res){
              suggestions.push({ field, current: test.data[field] || "", proposed: sanitizeAiText(res.value), rationale: sanitizeAiText(res.rationale || "") });
            }else{
              suggestions.push({ field, current: test.data[field] || "", proposed: "", noChange: true, rationale: "" });
            }
            renderForm();
            logLine(`AI Suggest: received "${field}".`, "ok");
          }catch(err){
            setSuggestStatus(test.id, field, "");
            renderForm();
            logLine(`AI Suggest: failed "${field}" (${err.message || err}).`, "warn");
            suggestions.push({ field, error: err.message || String(err) });
          }
        }
        showModal("AI Suggestions", (body, footer) => {
          body.innerHTML = suggestions.map((s, idx) => {
            if(s.error){
              return `
                <div class="item" style="margin-bottom:8px;">
                  <div class="left">
                    <div class="name">${escapeHtml(s.field)}</div>
                    <div class="meta"><span class="tag">Error</span> ${escapeHtml(s.error)}</div>
                  </div>
                </div>
              `;
            }
            if(s.noChange){
              return `
                <div class="item" style="margin-bottom:8px;">
                  <div class="left">
                    <div class="name">${escapeHtml(s.field)}</div>
                    <div class="meta"><span class="tag">No change</span> AI returned identical text.</div>
                    ${s.rationale ? `<div class="meta"><span class="tag">Rationale</span> ${escapeHtml(s.rationale)}</div>` : ``}
                  </div>
                </div>
              `;
            }
            return `
              <div class="item" style="margin-bottom:8px; align-items:stretch;">
                <div class="left" style="min-width:0;">
                  <div class="name">${escapeHtml(s.field)}</div>
                  <div class="meta">Current</div>
                  <pre style="white-space:pre-wrap; font-family:var(--mono); font-size:11px; margin:6px 0 0;">${escapeHtml(s.current)}</pre>
                  <div class="meta" style="margin-top:8px;">Improvement</div>
                  <pre style="white-space:pre-wrap; font-family:var(--mono); font-size:11px; margin:6px 0 0;">${escapeHtml(s.proposed)}</pre>
                  <div class="meta" style="margin-top:8px;">Rationale</div>
                  <div class="small">${escapeHtml(s.rationale || "—")}</div>
                </div>
                <div class="actions" style="align-items:flex-start;">
                  <label class="tag"><input type="checkbox" class="ai-accept" data-idx="${idx}" checked /> Accept</label>
                </div>
              </div>
            `;
          }).join("");

          footer.innerHTML = `
            <button class="btn" id="aiRejectAll">Reject All</button>
            <button class="btn primary" id="aiApplySelected">Apply Selected</button>
          `;
          $("aiRejectAll").onclick = () => {
            for(const s of suggestions){
              if(!s.error) setSuggestStatus(test.id, s.field, "");
            }
            renderForm();
            hideModal();
            toast("AI Suggest", "No changes applied.", "warn");
          };
          $("aiApplySelected").onclick = () => {
            const checks = Array.from(body.querySelectorAll(".ai-accept"));
            let applied = 0;
            for(const c of checks){
              if(!c.checked) continue;
              const idx = Number(c.getAttribute("data-idx"));
              const s = suggestions[idx];
              if(!s || s.error) continue;
              test.data[s.field] = sanitizeAiText(s.proposed);
              if(!test.data._ai) test.data._ai = { maturity:{} };
              if(!test.data._ai.maturity) test.data._ai.maturity = {};
              test.data._ai.maturity[s.field] = 2;
              if(!test._dirtyFields) test._dirtyFields = {};
              test._dirtyFields[s.field] = true;
              setSuggestStatus(test.id, s.field, "accepted");
              applied++;
            }
            test.modified = applied > 0 || test.modified;
            if(applied) $("dirtyHint").style.display = "";
            renderForm();
            renderTestsList();
            hideModal();
            toast("AI Suggest", applied ? `Applied ${applied} suggestion(s).` : "No changes applied.", applied ? "ok" : "warn");
            logLine(`AI Suggest: applied ${applied} suggestion(s).`, applied ? "ok" : "warn");
          };
        });
      }catch(e){
        toast("AI Suggest failed", e.message || String(e), "bad");
        logLine(`AI Suggest failed: ${e.message || e}`, "bad");
      }
    }

  /* ---------- Import / Export ---------- */
  async function exportAllPlans(){
    const all = await Store.listPlans();
    downloadText(`test_base_2026_export_${nowIsoDate()}.json`, JSON.stringify(all, null, 2), "application/json");
    logLine("Exported all documents.", "ok");
    toast("Export", "All documents exported as JSON.", "ok");
  }

  function importPlanJson(){
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = "application/json";
    inp.onchange = async () => {
      const file = inp.files?.[0];
      if(!file) return;
      try{
        const txt = await file.text();
        const obj = JSON.parse(txt);

        // Accept either a single plan object or an array of plans
        const plans = Array.isArray(obj) ? obj : [obj];
        for(const p of plans){
          const plan = {
            id: p.id || uid(),
            name: p.name || "Imported Plan",
            slug: p.slug || slugifyPlanName(p.name || "imported_plan"),
            created: p.created || nowIsoDate(),
            updated: nowIsoDate(),
            tests: (p.tests || []).map((t, idx) => ({
              id: t.id || uid(),
              order: (t.order ?? idx+1),
              modified: false,
              data: normalizeTestData(t.data || t)
            })),
            markdown: p.markdown || "",
            userNotes: p.userNotes ?? extractUserNotes(p.markdown || "")
          };
          if(!plan.markdown) generatePlanMarkdown(plan);
          await Store.savePlan(plan);
        }
        logLine(`Imported ${plans.length} document(s).`, "ok");
        toast("Import", `Imported ${plans.length} document(s).`, "ok");
        runAsync(renderLibrary());
      }catch(e){
        logLine(`Import failed: ${e.message || e}`, "bad");
        toast("Import failed", e.message || String(e), "bad");
      }
    };
    inp.click();
  }

  async function seedDemo(){
    const plan = {
      id: uid(),
      name: "Electronics Test Plan",
      slug: slugifyPlanName("Electronics Test Plan"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Simple plan for board bring up.",
      scope: "Inspect and power on the UUT for the first time. Check voltage rails, ability to program, and signs of life.",
      ai_review_guidance: "Concise, professional, and technical-oriented. Use clear, test-lab language and avoid filler.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: DEFAULT_AI_PROMPTS.review_persona,
        review_field: DEFAULT_AI_PROMPTS.review_field,
        chat_edit: "You edit a document. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Respond with strict JSON containing: plan (goal, scope) and tests (array). Provide exactly {{testCount}} sections with 3-digit section_no values and meaningful section_title values. Each test must include a set object using full schema keys: {{schemaKeys}}. Fill purpose/scope/setup/procedure/measurement/parameter and limits/units where applicable. Use source markdown tables (pin interfaces, test points, netlist, partlist) to drive test content. No extra text.",
        suggest_field: DEFAULT_AI_PROMPTS.suggest_field,
        suggest_field_strict: DEFAULT_AI_PROMPTS.suggest_field_strict,
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests: [
        { id: uid(), order: 1, modified:false, data: normalizeTestData({
          section_title: "Visual Inspection",
          section_no: "001",
          uut_pn: "TBD",
          last_section_no: "N/A",
          section_type: "Inspection",
          test_equipment: "ESD-safe workstation, adequate lighting, magnification (loupe/microscope), inspection tools (flashlight, tweezers), camera for defect photos, and current drawings/specifications.",
          purpose: "Verify that the Unit Under Test (UUT) is properly assembled, undamaged, free from contamination or foreign materials, and correctly labeled or marked before conducting any further testing.",
          scope: "Conduct a thorough visual inspection of the Unit Under Test (UUT) to ensure workmanship quality and conformity to applicable drawings and specifications. This includes checking for any physical damage such as cracks, dents, or deformation; presence of contamination, foreign material, corrosion, or signs of overheating; verification that all hardware and parts are present, secure, and correctly aligned; assessment of connectors and contacts for any damage or malfunction; confirmation of the integrity of seals and tamper indicators where applicable; and validation that all labels and markings are present, accurate, and legible.",
          setup: "Gather the Unit Under Test (UUT), current traveler or work order, and all relevant drawings and specifications. Prepare a clean, ESD-safe workstation with sufficient lighting and magnification tools as necessary. Confirm and document the UUT's identification details—including part number, revision, and serial or lot number—before commencing the inspection.",
          procedure: "1) Verify UUT identification: confirm that the part number (P/N) TBD and revision match the traveler/work order; record the P/N, revision, and serial or lot identification.\n2) Ensure ESD controls are properly implemented; conduct the inspection under adequate lighting and utilize magnification if needed.\n3) Examine the UUT and confirm:\n   a) No presence of cracks, chips, dents, gouges, deformation, or any other mechanical damage.\n   b) All hardware and fasteners are present, secure, not cross-threaded or misaligned; threads remain undamaged.\n   c) No signs of corrosion, discoloration, contamination, foreign substances, residue, or moisture.\n   d) Connectors and housings are intact; pins and contacts are not bent, recessed, pushed back, or damaged; latches and retainers are present and functional.\n   e) No indications of overheating, burning, or arcing.\n   f) All required labels and markings are present, accurate, and legible; seals or tamper indicators remain intact when applicable.\n4) If any inspection criterion is not satisfied: document a FAIL status, record each defect with its location and, if available, include photo references; halt further processing pending disposition.\n5) If all criteria are met: document a PASS status and proceed to the next test step.",
          measurement: "Indicate PASS if all visual acceptance criteria are satisfied. If any criterion fails, record FAIL along with detailed defect type, exact location, description of the defect, and reference any photos taken during inspection.",
          parameter: "Visual workmanship and configuration acceptance per applicable drawing/specification: no physical damage, deformation, contamination, foreign material, corrosion, or overheating; all parts present and correct; hardware properly secured and aligned; connectors and contacts undamaged; seals and tamper indicators intact if applicable; labels and markings present, accurate, and legible.",
          signal_pin: "N/A",
          return_pin: "N/A",
          ll: "N/A",
          tv: "N/A",
          ul: "N/A",
          units: "N/A",
          param1_label: "Units",
          param1_value: "units",
          param2_label: "Target Value",
          param2_value: "tv",
          in_tol_conclusion: "The unit passes all visual inspection criteria with no signs of damage, contamination, corrosion, overheating, missing or incorrect parts, loose hardware, or workmanship defects; all required labels and markings are present, accurate, and legible. Result: PASS.",
          in_tol_next_step: "002",
          oot_low_conclusion: "Visual inspection identified one or more nonconformities against acceptance criteria. Result: FAIL (OOT).",
          oot_low_unable_adjust: "Unable to adjust. Next: Record the nonconformance details including defect description, location, and photo reference if available. Tag and segregate the UUT as HOLD, notify Quality and Engineering teams, and follow NCR/MRB procedures for disposition. After corrective actions and disposition are completed, repeat the visual inspection and document the results before proceeding.",
          oot_low_next_step: "Record the nonconformance details including defect description, location, and photo reference if available. Tag and segregate the UUT as HOLD, notify Quality and Engineering teams, and follow NCR/MRB procedures for disposition. After corrective actions and disposition are completed, repeat the visual inspection and document the results before proceeding.",
          oot_high_conclusion: "This is a qualitative inspection; any deviation from the visual acceptance criteria results in a failure. Result: FAIL (OOT).",
          oot_high_unable_adjust: "Unable to adjust. Next: If the visual inspection fails, immediately halt all processing, segregate the unit under test as HOLD, document all nonconformances thoroughly, notify Quality and Engineering departments, and follow NCR/MRB protocols for disposition before attempting re-inspection and resuming further processing.",
          oot_high_next_step: "If the visual inspection fails, immediately halt all processing, segregate the unit under test as HOLD, document all nonconformances thoroughly, notify Quality and Engineering departments, and follow NCR/MRB protocols for disposition before attempting re-inspection and resuming further processing.",
          _ai: {
            maturity: {
              last_ai_reviewed: 2,
              last_ai_review_model: 2,
              last_human_reviewed: 2,
              notes: 2,
              oot_low_next_step: 0,
              section_no: 3,
              uut_pn: 0,
              last_section_no: 3,
              section_type: 3,
              test_equipment: 0,
              purpose: 0,
              scope: 0,
              setup: 0,
              procedure: 0,
              measurement: 0,
              parameter: 0,
              signal_pin: 3,
              return_pin: 3,
              ll: 3,
              tv: 3,
              ul: 3,
              units: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              in_tol_conclusion: 0,
              in_tol_next_step: 3,
              oot_low_conclusion: 0,
              oot_low_unable_adjust: 0,
              oot_high_conclusion: 0,
              oot_high_unable_adjust: 0,
              oot_high_next_step: 0,
              section_title: 3
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "",
            notes: "",
            field_labels: {
              section_title: "Test Name",
              section_no: "Test No",
              uut_pn: "UUT P/N",
              last_section_no: "Last Test No",
              section_type: "Test Type",
              test_equipment: "Test Equipment",
              purpose: "Purpose",
              scope: "Scope",
              setup: "Setup",
              procedure: "Procedure",
              measurement: "Measurement",
              parameter: "Parameter",
              signal_pin: "Signal Pin",
              return_pin: "Return Pin",
              ll: "Lower Limit (ll)",
              tv: "Target Value (tv)",
              ul: "Upper Limit (ul)",
              units: "Units",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              in_tol_conclusion: "In-Tolerance Conclusion",
              in_tol_next_step: "In-Tolerance Next Step",
              oot_low_conclusion: "OOT Low Conclusion",
              oot_low_unable_adjust: "OOT Low Unable to Adjust Conclusion",
              oot_low_next_step: "OOT Low Next Step",
              oot_high_conclusion: "OOT High Conclusion",
              oot_high_unable_adjust: "OOT High Unable to Adjust Conclusion",
              oot_high_next_step: "OOT High Next Step"
            },
            field_prompts: {
              section_title: "Provide a short, descriptive test name.",
              section_no: "Provide the test number (e.g., 001).",
              uut_pn: "",
              last_section_no: "Enter the prior test number that precedes this step (or N/A).",
              section_type: "Specify the test type/category (e.g., Inspection, Functional Verification).",
              test_equipment: "List required test equipment and tools.",
              purpose: "State the objective of this test in one concise paragraph.",
              scope: "Define what is covered/excluded and conditions for this test.",
              setup: "List required equipment, connections, and initial conditions.",
              procedure: "Write a step-by-step procedure; keep it clear and sequential.",
              measurement: "Describe what is measured, how, and with what instruments.",
              parameter: "List key parameters and acceptance references.",
              signal_pin: "Specify the signal pin identifier or N/A.",
              return_pin: "Specify the return pin identifier or N/A.",
              ll: "Enter the lower limit value or N/A.",
              tv: "Enter the target value or N/A.",
              ul: "Enter the upper limit value or N/A.",
              units: "Enter measurement units (e.g., V, A, W) or N/A.",
              param1_label: "Enter the label for Parameter 1 (e.g., Units).",
              param1_value: "Select which field supplies Parameter 1's value.",
              param2_label: "Enter the label for Parameter 2 (e.g., Target Value).",
              param2_value: "Select which field supplies Parameter 2's value.",
              in_tol_conclusion: "Describe pass criteria and expected conclusion when in tolerance.",
              in_tol_next_step: "Specify the next test number or END PASS.",
              oot_low_conclusion: "Describe failure criteria for low out-of-tolerance.",
              oot_low_unable_adjust: "Describe actions when adjustment is not possible after low OOT.",
              oot_low_next_step: "Specify next action/step after low OOT.",
              oot_high_conclusion: "Describe failure criteria for high out-of-tolerance.",
              oot_high_unable_adjust: "Describe actions when adjustment is not possible after high OOT.",
              oot_high_next_step: "Specify next action/step after high OOT."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              uut_pn: "text",
              last_section_no: "text",
              section_type: "text",
              test_equipment: "text",
              purpose: "text",
              scope: "text",
              setup: "text",
              procedure: "text",
              measurement: "text",
              parameter: "text",
              signal_pin: "text",
              return_pin: "text",
              ll: "text",
              tv: "text",
              ul: "text",
              units: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              in_tol_conclusion: "text",
              in_tol_next_step: "text",
              oot_low_conclusion: "text",
              oot_low_unable_adjust: "text",
              oot_low_next_step: "text",
              oot_high_conclusion: "text",
              oot_high_unable_adjust: "text",
              oot_high_next_step: "text"
            }
          }
        }) },
        { id: uid(), order: 2, modified:false, data: normalizeTestData({
          section_title: "Electrical Inspection",
          section_no: "002",
          uut_pn: "TBD",
          last_section_no: "001",
          section_type: "Inspection",
          test_equipment: "Programmable input source or bench supply (per spec), electronic or resistive loads, calibrated DMM, oscilloscope (as needed), test cables/fixtures, and ESD controls.",
          purpose: "Confirm the UUT operates correctly under nominal conditions by performing the functional test procedure and verifying all checks and measurements meet the defined acceptance criteria.",
          scope: "Verifies basic functional operation of the power supply under nominal conditions, including power-up behavior, control/indicator operation, and confirmation that all required outputs are present and within specified limits. Does not include detailed performance characterization, environmental or reliability stress testing, EMI/EMC evaluation, or extended burn-in.",
          setup: "Connect the UUT to the specified input source and to the required load(s) in accordance with the product specification. Verify all required test equipment is within calibration and configured to the appropriate functions and ranges. If thermal stabilization is required, allow the UUT to reach steady-state temperature before testing. Record ambient temperature, input settings, and load conditions.",
          procedure: "1) Verify the UUT part number/serial number (if applicable) and labeling match the work order/test documentation; inspect for obvious damage or missing hardware.\n2) Ensure all required test equipment is within calibration and configured for the required ranges/modes.\n3) Connect the UUT input to the specified source per the product specification; connect each output to the specified load(s). Verify correct polarity, wiring, and test point selection.\n4) Configure measurement instruments to monitor the required parameters (e.g., Vout, Iout) at the specified test points/channels.\n5) Apply input power. Confirm normal power-up behavior and that no fault/indicator conditions are present.\n6) If required, allow the UUT to reach thermal steady state; record ambient temperature and input conditions.\n7) Measure all required output parameter(s) in the specified operating mode(s) and at the specified test point(s).\n8) Compare measured results to the defined acceptance limits. Record readings with units and conditions (channel/test point, input setting, load setting, ambient temperature).\n9) If any parameter is out of tolerance, execute the applicable OOT action and disposition steps and document the results.",
          measurement: "Measure resistances with digital multimeter (DMM).",
          parameter: "Verify the UUT operates per specification: confirm normal power-up/indicators and that all required outputs are present and within defined limits under nominal conditions.",
          signal_pin: "N/A",
          return_pin: "N/A",
          ll: "100",
          tv: "1k",
          ul: "N/A",
          units: "Ω",
          param1_label: "Units",
          param1_value: "units",
          param2_label: "Target Value",
          param2_value: "tv",
          in_tol_conclusion: "All required functional checks and measurements conform to the specified acceptance criteria; the unit under test passes this test.",
          in_tol_next_step: "003",
          oot_low_conclusion: "At least one required measurement is below the specified lower limit; the UUT does not meet acceptance criteria and is nonconforming.",
          oot_low_unable_adjust: "Unable to adjust. Next: 1) Pause testing and verify the setup: confirm wiring/connection integrity, polarity, load setting, and correct test point/channel selection; verify instrument function, range/mode, and calibration status.\n2) Repeat the measurement and record at least three readings along with all relevant operating conditions (input setting, load, mode, ambient temperature).\n3) Swap in known-good cables, adapters/fixtures, and measurement equipment as applicable, then repeat the measurement.\n4) If the result remains below the requirement, quarantine the UUT and open a nonconformance/defect record; notify Engineering/Quality for disposition.\n5) After corrective action or disposition, rerun this test and document final readings and pass/fail outcome.",
          oot_low_next_step: "1) Pause testing and verify the setup: confirm wiring/connection integrity, polarity, load setting, and correct test point/channel selection; verify instrument function, range/mode, and calibration status.\n2) Repeat the measurement and record at least three readings along with all relevant operating conditions (input setting, load, mode, ambient temperature).\n3) Swap in known-good cables, adapters/fixtures, and measurement equipment as applicable, then repeat the measurement.\n4) If the result remains below the requirement, quarantine the UUT and open a nonconformance/defect record; notify Engineering/Quality for disposition.\n5) After corrective action or disposition, rerun this test and document final readings and pass/fail outcome.",
          oot_high_conclusion: "One or more required measurements exceed the specified upper limit; the UUT is nonconforming.",
          oot_high_unable_adjust: "Unable to adjust. Next: 1) Stop and verify the test setup: confirm all connections, the specified load value, and that measurement instruments are configured correctly and within calibration.\n2) Repeat the measurement and record at least three readings, including all relevant operating conditions.\n3) Replace cables/fixtures/instruments with known-good equivalents and repeat the measurement.\n4) If the result remains above the limit, quarantine the UUT, open a nonconformance/defect record, and notify Engineering/Quality for disposition.\n5) After corrective action/disposition, repeat this test and document final results.",
          oot_high_next_step: "1) Stop and verify the test setup: confirm all connections, the specified load value, and that measurement instruments are configured correctly and within calibration.\n2) Repeat the measurement and record at least three readings, including all relevant operating conditions.\n3) Replace cables/fixtures/instruments with known-good equivalents and repeat the measurement.\n4) If the result remains above the limit, quarantine the UUT, open a nonconformance/defect record, and notify Engineering/Quality for disposition.\n5) After corrective action/disposition, repeat this test and document final results.",
          _ai: {
            maturity: {
              last_ai_reviewed: 2,
              last_ai_review_model: 2,
              last_human_reviewed: 2,
              notes: 2,
              oot_high_conclusion: 0,
              section_title: 3,
              section_no: 3,
              uut_pn: 0,
              last_section_no: 3,
              section_type: 3,
              test_equipment: 0,
              purpose: 0,
              scope: 0,
              setup: 0,
              procedure: 0,
              measurement: 0,
              parameter: 0,
              signal_pin: 3,
              return_pin: 3,
              ll: 3,
              tv: 3,
              ul: 3,
              units: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              in_tol_conclusion: 0,
              in_tol_next_step: 3,
              oot_low_conclusion: 0,
              oot_low_unable_adjust: 0,
              oot_low_next_step: 0,
              oot_high_unable_adjust: 0,
              oot_high_next_step: 0
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "",
            notes: "",
            field_labels: {
              section_title: "Test Name",
              section_no: "Test No",
              uut_pn: "UUT P/N",
              last_section_no: "Last Test No",
              section_type: "Test Type",
              test_equipment: "Test Equipment",
              purpose: "Purpose",
              scope: "Scope",
              setup: "Setup",
              procedure: "Procedure",
              measurement: "Measurement",
              parameter: "Parameter",
              signal_pin: "Signal Pin",
              return_pin: "Return Pin",
              ll: "Lower Limit (ll)",
              tv: "Target Value (tv)",
              ul: "Upper Limit (ul)",
              units: "Units",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              in_tol_conclusion: "In-Tolerance Conclusion",
              in_tol_next_step: "In-Tolerance Next Step",
              oot_low_conclusion: "OOT Low Conclusion",
              oot_low_unable_adjust: "OOT Low Unable to Adjust Conclusion",
              oot_low_next_step: "OOT Low Next Step",
              oot_high_conclusion: "OOT High Conclusion",
              oot_high_unable_adjust: "OOT High Unable to Adjust Conclusion",
              oot_high_next_step: "OOT High Next Step"
            },
            field_prompts: {
              section_title: "Provide a short, descriptive test name.",
              section_no: "Provide the test number (e.g., 001).",
              uut_pn: "",
              last_section_no: "Enter the prior test number that precedes this step (or N/A).",
              section_type: "Specify the test type/category (e.g., Inspection, Functional Verification).",
              test_equipment: "List required test equipment and tools.",
              purpose: "State the objective of this test in one concise paragraph.",
              scope: "Define what is covered/excluded and conditions for this test.",
              setup: "List required equipment, connections, and initial conditions.",
              procedure: "Write a step-by-step procedure; keep it clear and sequential.",
              measurement: "Describe what is measured, how, and with what instruments.",
              parameter: "List key parameters and acceptance references.",
              signal_pin: "Specify the signal pin identifier or N/A.",
              return_pin: "Specify the return pin identifier or N/A.",
              ll: "Enter the lower limit value or N/A.",
              tv: "Enter the target value or N/A.",
              ul: "Enter the upper limit value or N/A.",
              units: "Enter measurement units (e.g., V, A, W) or N/A.",
              param1_label: "Enter the label for Parameter 1 (e.g., Units).",
              param1_value: "Select which field supplies Parameter 1's value.",
              param2_label: "Enter the label for Parameter 2 (e.g., Target Value).",
              param2_value: "Select which field supplies Parameter 2's value.",
              in_tol_conclusion: "Describe pass criteria and expected conclusion when in tolerance.",
              in_tol_next_step: "Specify the next test number or END PASS.",
              oot_low_conclusion: "Describe failure criteria for low out-of-tolerance.",
              oot_low_unable_adjust: "Describe actions when adjustment is not possible after low OOT.",
              oot_low_next_step: "Specify next action/step after low OOT.",
              oot_high_conclusion: "Describe failure criteria for high out-of-tolerance.",
              oot_high_unable_adjust: "Describe actions when adjustment is not possible after high OOT.",
              oot_high_next_step: "Specify next action/step after high OOT."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              uut_pn: "text",
              last_section_no: "text",
              section_type: "text",
              test_equipment: "text",
              purpose: "text",
              scope: "text",
              setup: "text",
              procedure: "text",
              measurement: "text",
              parameter: "text",
              signal_pin: "text",
              return_pin: "text",
              ll: "text",
              tv: "text",
              ul: "text",
              units: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              in_tol_conclusion: "text",
              in_tol_next_step: "text",
              oot_low_conclusion: "text",
              oot_low_unable_adjust: "text",
              oot_low_next_step: "text",
              oot_high_conclusion: "text",
              oot_high_unable_adjust: "text",
              oot_high_next_step: "text"
            }
          }
        }) },
        { id: uid(), order: 3, modified:false, data: normalizeTestData({
          section_title: "Power Voltages",
          section_no: "003",
          uut_pn: "TBD",
          last_section_no: "002",
          section_type: "Functional Verification",
          test_equipment: "Programmable AC/DC source, electronic loads, calibrated DMM/DAQ, oscilloscope for ripple/noise (if required), test fixture/harness, and ESD controls.",
          purpose: "Verify the power supply UUT powers up without faults or alarms and maintains regulated output voltage within the specified limits at defined input, load, and environmental conditions for this step.",
          scope: "Applies to the power supply UUT identified by part number and revision. Confirms normal power-up (no faults or alarms) and verifies regulated output voltage at the specified input and load conditions.",
          setup: "Install the UUT in the approved test fixture. Connect a programmable AC/DC source to the UUT input according to the nameplate rating. Connect electronic load(s) to the output(s) under test using the specified sense method (local or remote). Connect a digital multimeter (DMM) or data acquisition system (DAQ) to measure output voltages at specified test points. Connect an oscilloscope only if ripple/noise measurement is required for this step. Verify all instruments are calibrated. Set ambient conditions as specified and allow the UUT to warm up per specification before data recording.",
          procedure: "1) Verify and record UUT part number and revision against traveler and UUT label. 2) Configure input source to the specified nominal input condition (include AC frequency if applicable) and enable input power. 3) Confirm normal power-up, outputs enabled as applicable, and no faults or alarms are indicated. 4) Apply specified load condition(s) for this step to each output under test. 5) Allow UUT to stabilize for the specified dwell time. 6) Measure and record output voltage for each output using the specified sense method and measurement points. 7) Repeat measurements at additional load points and/or input conditions defined in test plan if required.",
          measurement: "Measure output voltages using a digital multimeter (DMM) at specified test points with the required local or remote sense method.",
          parameter: "Output voltage regulation compared against specified limits at defined input and load conditions.",
          signal_pin: "N/A",
          return_pin: "N/A",
          ll: "4.80",
          tv: "5.0",
          ul: "5.2",
          units: "V",
          param1_label: "Units",
          param1_value: "units",
          param2_label: "Target Value",
          param2_value: "tv",
          in_tol_conclusion: "All output voltage measurements are within specified limits with no abnormal operation; the UUT passes this test step.",
          in_tol_next_step: "004",
          oot_low_conclusion: "One or more output voltage measurements fall below the specified lower limit and/or functional requirements are not satisfied; the UUT fails this test step (OOT Low).",
          oot_low_unable_adjust: "Unable to adjust. Next: Stop testing and place the UUT on hold. Verify instrument calibration and measurement configuration including connections, polarity, sense method, load setting, and input source. Repeat measurement once; if still OOT Low, document condition and notify Engineering and Quality teams for troubleshooting and disposition per procedure. Resume testing only after corrective action is approved.",
          oot_low_next_step: "Stop testing and place the UUT on hold. Verify instrument calibration and measurement configuration including connections, polarity, sense method, load setting, and input source. Repeat measurement once; if still OOT Low, document condition and notify Engineering and Quality teams for troubleshooting and disposition per procedure. Resume testing only after corrective action is approved.",
          oot_high_conclusion: "One or more output voltage measurements exceed the specified upper limit and/or functional requirements are not satisfied; the UUT fails this test step (OOT High).",
          oot_high_unable_adjust: "Unable to adjust. Next: Stop testing and place the UUT on hold. Verify instrument calibration and measurement configuration including connections, polarity, sense method, load setting, and input source. Repeat measurement once; if still OOT High, document condition and notify Engineering and Quality teams for troubleshooting and disposition per procedure. Resume testing only after corrective action is approved.",
          oot_high_next_step: "Stop testing and place the UUT on hold. Verify instrument calibration and measurement configuration including connections, polarity, sense method, load setting, and input source. Repeat measurement once; if still OOT High, document condition and notify Engineering and Quality teams for troubleshooting and disposition per procedure. Resume testing only after corrective action is approved.",
          _ai: {
            maturity: {
              last_ai_reviewed: 2,
              last_ai_review_model: 2,
              last_human_reviewed: 2,
              notes: 2,
              section_title: 3,
              section_no: 3,
              uut_pn: 0,
              last_section_no: 3,
              section_type: 3,
              test_equipment: 0,
              purpose: 0,
              scope: 0,
              setup: 0,
              procedure: 0,
              measurement: 0,
              parameter: 0,
              signal_pin: 3,
              return_pin: 3,
              ll: 3,
              tv: 3,
              ul: 3,
              units: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              in_tol_conclusion: 0,
              in_tol_next_step: 3,
              oot_low_conclusion: 0,
              oot_low_unable_adjust: 0,
              oot_low_next_step: 0,
              oot_high_conclusion: 0,
              oot_high_unable_adjust: 0,
              oot_high_next_step: 0
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "",
            notes: "",
            field_labels: {
              section_title: "Test Name",
              section_no: "Test No",
              uut_pn: "UUT P/N",
              last_section_no: "Last Test No",
              section_type: "Test Type",
              test_equipment: "Test Equipment",
              purpose: "Purpose",
              scope: "Scope",
              setup: "Setup",
              procedure: "Procedure",
              measurement: "Measurement",
              parameter: "Parameter",
              signal_pin: "Signal Pin",
              return_pin: "Return Pin",
              ll: "Lower Limit (ll)",
              tv: "Target Value (tv)",
              ul: "Upper Limit (ul)",
              units: "Units",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              in_tol_conclusion: "In-Tolerance Conclusion",
              in_tol_next_step: "In-Tolerance Next Step",
              oot_low_conclusion: "OOT Low Conclusion",
              oot_low_unable_adjust: "OOT Low Unable to Adjust Conclusion",
              oot_low_next_step: "OOT Low Next Step",
              oot_high_conclusion: "OOT High Conclusion",
              oot_high_unable_adjust: "OOT High Unable to Adjust Conclusion",
              oot_high_next_step: "OOT High Next Step"
            },
            field_prompts: {
              section_title: "Provide a short, descriptive test name.",
              section_no: "Provide the test number (e.g., 001).",
              uut_pn: "",
              last_section_no: "Enter the prior test number that precedes this step (or N/A).",
              section_type: "Specify the test type/category (e.g., Inspection, Functional Verification).",
              test_equipment: "List required test equipment and tools.",
              purpose: "State the objective of this test in one concise paragraph.",
              scope: "Define what is covered/excluded and conditions for this test.",
              setup: "List required equipment, connections, and initial conditions.",
              procedure: "Write a step-by-step procedure; keep it clear and sequential.",
              measurement: "Describe what is measured, how, and with what instruments.",
              parameter: "List key parameters and acceptance references.",
              signal_pin: "Specify the signal pin identifier or N/A.",
              return_pin: "Specify the return pin identifier or N/A.",
              ll: "Enter the lower limit value or N/A.",
              tv: "Enter the target value or N/A.",
              ul: "Enter the upper limit value or N/A.",
              units: "Enter measurement units (e.g., V, A, W) or N/A.",
              param1_label: "Enter the label for Parameter 1 (e.g., Units).",
              param1_value: "Select which field supplies Parameter 1's value.",
              param2_label: "Enter the label for Parameter 2 (e.g., Target Value).",
              param2_value: "Select which field supplies Parameter 2's value.",
              in_tol_conclusion: "Describe pass criteria and expected conclusion when in tolerance.",
              in_tol_next_step: "Specify the next test number or END PASS.",
              oot_low_conclusion: "Describe failure criteria for low out-of-tolerance.",
              oot_low_unable_adjust: "Describe actions when adjustment is not possible after low OOT.",
              oot_low_next_step: "Specify next action/step after low OOT.",
              oot_high_conclusion: "Describe failure criteria for high out-of-tolerance.",
              oot_high_unable_adjust: "Describe actions when adjustment is not possible after high OOT.",
              oot_high_next_step: "Specify next action/step after high OOT."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              uut_pn: "text",
              last_section_no: "text",
              section_type: "text",
              test_equipment: "text",
              purpose: "text",
              scope: "text",
              setup: "text",
              procedure: "text",
              measurement: "text",
              parameter: "text",
              signal_pin: "text",
              return_pin: "text",
              ll: "text",
              tv: "text",
              ul: "text",
              units: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              in_tol_conclusion: "text",
              in_tol_next_step: "text",
              oot_low_conclusion: "text",
              oot_low_unable_adjust: "text",
              oot_low_next_step: "text",
              oot_high_conclusion: "text",
              oot_high_unable_adjust: "text",
              oot_high_next_step: "text"
            }
          }
        }) },
        { id: uid(), order: 4, modified:false, data: normalizeTestData({
          section_title: "Input Power",
          section_no: "004",
          uut_pn: "TBD",
          last_section_no: "003",
          section_type: "Functional Verification",
          test_equipment: "AC source or mains feed, electronic/resistive load, calibrated DMM, oscilloscope (if required), safety ground, and test fixture/harness.",
          purpose: "Verify the UUT power supply meets applicable functional performance requirements at this stage of the test flow and record results to support acceptance or rejection.",
          scope: "Verify the UUT powers on and operates within specified electrical limits under defined input and load conditions using calibrated equipment. This test defines required connections, ambient conditions, measurement points, and pass/fail criteria.",
          setup: "Equipment includes AC source or mains feed as applicable, electronic or resistive load, digital multimeter (DMM), oscilloscope if required, safety ground, and ESD controls. Configure the UUT per drawing, BOM, and traveler. Connect input power through specified protection device such as fuse or breaker. Connect load to output terminals with correct polarity. Connect measurement leads at specified test points, using remote sense or Kelvin connections if applicable. Verify all instruments are within calibration; record instrument IDs. Record ambient conditions per work instructions.",
          procedure: "1) Verify UUT part number, configuration, and serial number match traveler; record serial number.\n2) Perform visual check for damage and verify connectors and jumpers are correctly positioned.\n3) Connect input source, output load, and measurement leads as specified.\n4) Set input to specified value or range and enable power.\n5) Allow stabilization per specification or 1–5 minutes if unspecified.\n6) Apply required load conditions, such as no-load, nominal, or maximum rated.\n7) Measure and record required parameters with units at each condition (e.g., output voltage, output current, ripple/noise, line/load regulation, efficiency) using specified instruments; capture oscilloscope evidence if required.\n8) Compare results to applicable limits and record pass/fail.\n9) Power down, remove load, and safely disconnect UUT following handling procedures.",
          measurement: "Record measured values at specified test points under defined input and load conditions, including units, instrument IDs, and relevant settings such as probe attenuation and bandwidth limit for ripple/noise measurements.",
          parameter: "Power supply output performance parameters as required by the product specification for this test, including output voltage under load, output current capability, ripple/noise, line and load regulation, and efficiency.",
          signal_pin: "N/A",
          return_pin: "N/A",
          ll: "2.5",
          tv: "3.0",
          ul: "3.5",
          units: "W",
          param1_label: "Units",
          param1_value: "units",
          param2_label: "Target Value",
          param2_value: "tv",
          in_tol_conclusion: "All required measurements meet specified limits; the Unit Under Test passes Test 004.",
          in_tol_next_step: "005",
          oot_low_conclusion: "One or more required measurements fall below the specified lower limit (OOT-LOW); the Unit Under Test fails Test 004.",
          oot_low_unable_adjust: "Unable to adjust. Next: Place the unit on hold or quarantine. Verify configuration, connections, and instrument settings, including ranges, probes, and sense leads, and confirm calibration status. Repeat the measurement to confirm. If out-of-tolerance low condition persists, document failure data, notify Engineering and Quality, and proceed with troubleshooting, repair, and disposition according to NCR and CAPA processes.",
          oot_low_next_step: "Place the unit on hold or quarantine. Verify configuration, connections, and instrument settings, including ranges, probes, and sense leads, and confirm calibration status. Repeat the measurement to confirm. If out-of-tolerance low condition persists, document failure data, notify Engineering and Quality, and proceed with troubleshooting, repair, and disposition according to NCR and CAPA processes.",
          oot_high_conclusion: "One or more required measurements exceed the specified upper limit (OOT-HIGH); the Unit Under Test fails Test 004.",
          oot_high_unable_adjust: "Unable to adjust. Next: Stop the test and place the unit on hold or quarantine. Verify setup and measurement path including polarity, load settings, probe attenuation, bandwidth limit, and sense wiring; confirm correct limits and units are applied. Repeat the measurement to confirm. If out-of-tolerance high condition persists, document failure data, notify Engineering and Quality, and proceed with troubleshooting, repair, and disposition according to NCR and CAPA processes.",
          oot_high_next_step: "Stop the test and place the unit on hold or quarantine. Verify setup and measurement path including polarity, load settings, probe attenuation, bandwidth limit, and sense wiring; confirm correct limits and units are applied. Repeat the measurement to confirm. If out-of-tolerance high condition persists, document failure data, notify Engineering and Quality, and proceed with troubleshooting, repair, and disposition according to NCR and CAPA processes.",
          _ai: {
            maturity: {
              last_ai_reviewed: 2,
              last_ai_review_model: 2,
              last_human_reviewed: 2,
              notes: 2,
              section_title: 3,
              section_no: 3,
              last_section_no: 3,
              section_type: 3,
              test_equipment: 0,
              ll: 3,
              tv: 3,
              ul: 3,
              units: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              uut_pn: 0,
              purpose: 0,
              scope: 0,
              setup: 0,
              procedure: 0,
              measurement: 0,
              parameter: 0,
              in_tol_conclusion: 0,
              in_tol_next_step: 3,
              oot_low_conclusion: 0,
              oot_low_unable_adjust: 0,
              oot_low_next_step: 0,
              oot_high_conclusion: 0,
              oot_high_unable_adjust: 0,
              oot_high_next_step: 0
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "",
            notes: "",
            field_labels: {
              section_title: "Test Name",
              section_no: "Test No",
              uut_pn: "UUT P/N",
              last_section_no: "Last Test No",
              section_type: "Test Type",
              test_equipment: "Test Equipment",
              purpose: "Purpose",
              scope: "Scope",
              setup: "Setup",
              procedure: "Procedure",
              measurement: "Measurement",
              parameter: "Parameter",
              signal_pin: "Signal Pin",
              return_pin: "Return Pin",
              ll: "Lower Limit (ll)",
              tv: "Target Value (tv)",
              ul: "Upper Limit (ul)",
              units: "Units",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              in_tol_conclusion: "In-Tolerance Conclusion",
              in_tol_next_step: "In-Tolerance Next Step",
              oot_low_conclusion: "OOT Low Conclusion",
              oot_low_unable_adjust: "OOT Low Unable to Adjust Conclusion",
              oot_low_next_step: "OOT Low Next Step",
              oot_high_conclusion: "OOT High Conclusion",
              oot_high_unable_adjust: "OOT High Unable to Adjust Conclusion",
              oot_high_next_step: "OOT High Next Step"
            },
            field_prompts: {
              section_title: "Provide a short, descriptive test name.",
              section_no: "Provide the test number (e.g., 001).",
              uut_pn: "",
              last_section_no: "Enter the prior test number that precedes this step (or N/A).",
              section_type: "Specify the test type/category (e.g., Inspection, Functional Verification).",
              test_equipment: "List required test equipment and tools.",
              purpose: "State the objective of this test in one concise paragraph.",
              scope: "Define what is covered/excluded and conditions for this test.",
              setup: "List required equipment, connections, and initial conditions.",
              procedure: "Write a step-by-step procedure; keep it clear and sequential.",
              measurement: "Describe what is measured, how, and with what instruments.",
              parameter: "List key parameters and acceptance references.",
              signal_pin: "Specify the signal pin identifier or N/A.",
              return_pin: "Specify the return pin identifier or N/A.",
              ll: "Enter the lower limit value or N/A.",
              tv: "Enter the target value or N/A.",
              ul: "Enter the upper limit value or N/A.",
              units: "Enter measurement units (e.g., V, A, W) or N/A.",
              param1_label: "Enter the label for Parameter 1 (e.g., Units).",
              param1_value: "Select which field supplies Parameter 1's value.",
              param2_label: "Enter the label for Parameter 2 (e.g., Target Value).",
              param2_value: "Select which field supplies Parameter 2's value.",
              in_tol_conclusion: "Describe pass criteria and expected conclusion when in tolerance.",
              in_tol_next_step: "Specify the next test number or END PASS.",
              oot_low_conclusion: "Describe failure criteria for low out-of-tolerance.",
              oot_low_unable_adjust: "Describe actions when adjustment is not possible after low OOT.",
              oot_low_next_step: "Specify next action/step after low OOT.",
              oot_high_conclusion: "Describe failure criteria for high out-of-tolerance.",
              oot_high_unable_adjust: "Describe actions when adjustment is not possible after high OOT.",
              oot_high_next_step: "Specify next action/step after high OOT."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              uut_pn: "text",
              last_section_no: "text",
              section_type: "text",
              test_equipment: "text",
              purpose: "text",
              scope: "text",
              setup: "text",
              procedure: "text",
              measurement: "text",
              parameter: "text",
              signal_pin: "text",
              return_pin: "text",
              ll: "text",
              tv: "text",
              ul: "text",
              units: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              in_tol_conclusion: "text",
              in_tol_next_step: "text",
              oot_low_conclusion: "text",
              oot_low_unable_adjust: "text",
              oot_low_next_step: "text",
              oot_high_conclusion: "text",
              oot_high_unable_adjust: "text",
              oot_high_next_step: "text"
            }
          }
        }) },
        { id: uid(), order: 5, modified:false, data: normalizeTestData({
          section_title: "Output Power",
          section_no: "005",
          uut_pn: "TBD",
          last_section_no: "004",
          section_type: "Functional Verification",
          test_equipment: "Electronic load(s), calibrated DMM or power meter, oscilloscope (if required), test fixture/harness, and ESD controls.",
          purpose: "Verify the Unit Under Test (UUT) meets specified output power requirements by executing the defined setup and test procedure, measuring necessary parameters, and recording results to determine pass/fail status.",
          scope: "Perform thorough functional verification of the power supply UUT’s output power under nominal and specified operating conditions. This test excludes environmental, reliability, and regulatory compliance testing unless explicitly included in the plan.",
          setup: "1) Record UUT part number (P/N), revision, and serial number (S/N).\n2) Verify all required test equipment is present, properly configured, and within calibration; document equipment identification and calibration status.\n3) Set ambient test conditions to 23°C ± 5°C, unless otherwise specified, and allow UUT and instruments to stabilize for at least 10 minutes.\n4) Connect UUT to the test fixture or harness per applicable wiring diagrams; verify connector keying, pinouts, and ground continuity.\n5) Ensure UUT is de-energized prior to connection unless power state is specified.\n6) Initialize digital multimeter (DMM) or other measurement instruments, setting the appropriate function and range for the required parameters.\n7) Confirm the test station is in a known-good state with no active faults or alarms and is ready for testing.",
          procedure: "1) Verify preconditions including proper setup, calibration status of equipment, and correct identification of the UUT.\n2) Configure measurement instruments per test requirements.\n3) Perform measurements of specified output power and related parameters according to drawings, schematics, and test point definitions; record measured values with units.\n4) Repeat measurements as necessary; record all readings and calculate required statistics (e.g., average, worst case).\n5) Compare measurement results to defined acceptance criteria to determine pass/fail outcome.\n6) Document all anomalies, retest actions, and attach relevant logs or raw data to the test record.",
          measurement: "Measure output power and related electrical parameters using calibrated digital multimeter (DMM) or appropriate measurement instruments following specified test points and methods.",
          parameter: "Output power and related characteristics measured in accordance with product specifications and test definitions.",
          signal_pin: "N/A",
          return_pin: "N/A",
          ll: "2.0",
          tv: "2.5",
          ul: "3.0",
          units: "W",
          param1_label: "Units",
          param1_value: "units",
          param2_label: "Target Value",
          param2_value: "tv",
          in_tol_conclusion: "All output power measurements are within specified limits and conform to acceptance criteria; the UUT passes the test.",
          in_tol_next_step: "END PASS",
          oot_low_conclusion: "One or more measured parameters fall below specified lower limits, indicating the UUT does not meet requirements; test result is FAIL (OOT Low).",
          oot_low_unable_adjust: "Unable to adjust. Next: Quarantine the unit. Verify setup, connections, instrument configurations, and parameter limits; then repeat measurements. If the low out-of-tolerance condition persists, troubleshoot, correct as required, and retest. Document final disposition.",
          oot_low_next_step: "Quarantine the unit. Verify setup, connections, instrument configurations, and parameter limits; then repeat measurements. If the low out-of-tolerance condition persists, troubleshoot, correct as required, and retest. Document final disposition.",
          oot_high_conclusion: "One or more measured parameters exceed specified upper limits, indicating the UUT does not meet requirements; test result is FAIL (OOT High).",
          oot_high_unable_adjust: "Unable to adjust. Next: Quarantine the unit. Verify setup, connections, instrument configurations, and parameter limits; then repeat measurements. If the high out-of-tolerance condition persists, escalate for engineering review, correct as required, and retest. Document final disposition.",
          oot_high_next_step: "Quarantine the unit. Verify setup, connections, instrument configurations, and parameter limits; then repeat measurements. If the high out-of-tolerance condition persists, escalate for engineering review, correct as required, and retest. Document final disposition.",
          _ai: {
            maturity: {
              last_ai_reviewed: 2,
              last_ai_review_model: 2,
              last_human_reviewed: 2,
              notes: 2,
              section_title: 3,
              section_no: 3,
              last_section_no: 3,
              section_type: 3,
              test_equipment: 0,
              uut_pn: 0,
              purpose: 0,
              scope: 0,
              setup: 0,
              procedure: 0,
              measurement: 0,
              parameter: 0,
              signal_pin: 3,
              return_pin: 3,
              ll: 3,
              tv: 3,
              ul: 3,
              units: 3,
              param1_label: 3,
              param1_value: 3,
              param2_label: 3,
              param2_value: 3,
              in_tol_conclusion: 0,
              in_tol_next_step: 3,
              oot_low_conclusion: 0,
              oot_low_unable_adjust: 0,
              oot_low_next_step: 0,
              oot_high_conclusion: 0,
              oot_high_unable_adjust: 0,
              oot_high_next_step: 0
            },
            last_ai_reviewed: "",
            last_ai_review_model: "",
            last_human_reviewed: "",
            notes: "",
            field_labels: {
              section_title: "Test Name",
              section_no: "Test No",
              uut_pn: "UUT P/N",
              last_section_no: "Last Test No",
              section_type: "Test Type",
              test_equipment: "Test Equipment",
              purpose: "Purpose",
              scope: "Scope",
              setup: "Setup",
              procedure: "Procedure",
              measurement: "Measurement",
              parameter: "Parameter",
              signal_pin: "Signal Pin",
              return_pin: "Return Pin",
              ll: "Lower Limit (ll)",
              tv: "Target Value (tv)",
              ul: "Upper Limit (ul)",
              units: "Units",
              param1_label: "Param 1 Label",
              param1_value: "Param 1 Value",
              param2_label: "Param 2 Label",
              param2_value: "Param 2 Value",
              in_tol_conclusion: "In-Tolerance Conclusion",
              in_tol_next_step: "In-Tolerance Next Step",
              oot_low_conclusion: "OOT Low Conclusion",
              oot_low_unable_adjust: "OOT Low Unable to Adjust Conclusion",
              oot_low_next_step: "OOT Low Next Step",
              oot_high_conclusion: "OOT High Conclusion",
              oot_high_unable_adjust: "OOT High Unable to Adjust Conclusion",
              oot_high_next_step: "OOT High Next Step"
            },
            field_prompts: {
              section_title: "Provide a short, descriptive test name.",
              section_no: "Provide the test number (e.g., 001).",
              uut_pn: "",
              last_section_no: "Enter the prior test number that precedes this step (or N/A).",
              section_type: "Specify the test type/category (e.g., Inspection, Functional Verification).",
              test_equipment: "List required test equipment and tools.",
              purpose: "State the objective of this test in one concise paragraph.",
              scope: "Define what is covered/excluded and conditions for this test.",
              setup: "List required equipment, connections, and initial conditions.",
              procedure: "Write a step-by-step procedure; keep it clear and sequential.",
              measurement: "Describe what is measured, how, and with what instruments.",
              parameter: "List key parameters and acceptance references.",
              signal_pin: "Specify the signal pin identifier or N/A.",
              return_pin: "Specify the return pin identifier or N/A.",
              ll: "Enter the lower limit value or N/A.",
              tv: "Enter the target value or N/A.",
              ul: "Enter the upper limit value or N/A.",
              units: "Enter measurement units (e.g., V, A, W) or N/A.",
              param1_label: "Enter the label for Parameter 1 (e.g., Units).",
              param1_value: "Select which field supplies Parameter 1's value.",
              param2_label: "Enter the label for Parameter 2 (e.g., Target Value).",
              param2_value: "Select which field supplies Parameter 2's value.",
              in_tol_conclusion: "Describe pass criteria and expected conclusion when in tolerance.",
              in_tol_next_step: "Specify the next test number or END PASS.",
              oot_low_conclusion: "Describe failure criteria for low out-of-tolerance.",
              oot_low_unable_adjust: "Describe actions when adjustment is not possible after low OOT.",
              oot_low_next_step: "Specify next action/step after low OOT.",
              oot_high_conclusion: "Describe failure criteria for high out-of-tolerance.",
              oot_high_unable_adjust: "Describe actions when adjustment is not possible after high OOT.",
              oot_high_next_step: "Specify next action/step after high OOT."
            },
            field_types: {
              section_title: "text",
              section_no: "text",
              uut_pn: "text",
              last_section_no: "text",
              section_type: "text",
              test_equipment: "text",
              purpose: "text",
              scope: "text",
              setup: "text",
              procedure: "text",
              measurement: "text",
              parameter: "text",
              signal_pin: "text",
              return_pin: "text",
              ll: "text",
              tv: "text",
              ul: "text",
              units: "text",
              param1_label: "text",
              param1_value: "text",
              param2_label: "text",
              param2_value: "text",
              in_tol_conclusion: "text",
              in_tol_next_step: "text",
              oot_low_conclusion: "text",
              oot_low_unable_adjust: "text",
              oot_low_next_step: "text",
              oot_high_conclusion: "text",
              oot_high_unable_adjust: "text",
              oot_high_next_step: "text"
            }
          }
        }) }
      ],
      markdown: "",
      userNotes: "Demo notes: add equipment list, safety notes, and lab setup here."
    };
    for(const t of plan.tests){
      if(!t.data._ai) t.data._ai = ensureAiMeta(null, Object.keys(t.data).filter(k => k !== "_ai"));
      t.data._ai.field_types = { ...DEFAULT_FIELD_TYPES };
      t.data._ai.review_personalities = buildSeedReviewPersonalitiesForData(t.data);
    }
    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded Electronics Test Plan.", "ok");
    toast("Seeded", "Electronics Test Plan created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedSpecificationsDocument(){
    const sections = [
      {
        title: "Core Metadata",
        id: "SEC-001",
        type: "Core Metadata",
        fields: [
          { key: "spec_title", label: "Spec Title", type: "text", value: "Core Metadata Specification" },
          { key: "spec_id_number", label: "Spec ID / Number", type: "text", value: "SPEC-001" },
          { key: "version", label: "Version", type: "text", value: "1.0" },
          { key: "status", label: "Status", type: "text", value: "Draft" },
          { key: "owner", label: "Owner / Author", type: "text", value: "Systems Engineering Lead" },
          { key: "stakeholders", label: "Stakeholders", type: "textarea", value: "Project Manager, Product Owner, Design Engineering Team, Quality Assurance Team, Regulatory Compliance Team, Reliability Analysts, Supply Chain Stakeholders, and Customer Support Representatives." },
          { key: "date_created", label: "Date Created", type: "text", value: "" },
          { key: "date_updated", label: "Date Updated", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          spec_title: 3,
          spec_id_number: 3,
          version: 3,
          status: 2,
          owner: 3,
          stakeholders: 2,
          date_created: 0,
          date_updated: 0
        }
      },
      {
        title: "Overview",
        id: "SEC-002",
        type: "Overview",
        fields: [
          { key: "purpose", label: "Purpose", type: "textarea", value: "This specification section's purpose is to clearly define the objectives and intent of the document. It aims to outline the goals and rationale behind the specifications, providing readers with an understanding of the scope and relevance of the content within the overview section." },
          { key: "scope", label: "Scope", type: "textarea", value: "This section defines the scope of the specifications document, detailing the boundaries, applicability, and extent of coverage for the project or product. It outlines which aspects, features, components, or functionalities are included and excluded, ensuring a clear understanding of the document's reach to all stakeholders involved." },
          { key: "definitions", label: "Definitions / Acronyms", type: "textarea", value: "Definitions / Acronyms\n\nThis section defines key terms and acronyms used throughout the specification document to ensure clarity and common understanding among all stakeholders.\n\n- UUT: Unit Under Test\n- SEC: Section identifier prefix used in this document\n- AI: Artificial Intelligence\n- QA: Quality Assurance\n- PM: Project Manager\n- PO: Product Owner\n- R&D: Research and Development\n- SOP: Standard Operating Procedure\n- API: Application Programming Interface\n- KPI: Key Performance Indicator\n\nThese definitions facilitate accurate communication and interpretation of the specifications described in this document." },
          { key: "references", label: "References / Related docs", type: "textarea", value: "None. This specification section currently contains no references or related documents." }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          purpose: 2,
          scope: 2,
          definitions: 2,
          references: 2
        }
      },
      {
        title: "Requirements",
        id: "SEC-003",
        type: "Requirements",
        fields: [
          { key: "functional_requirements", label: "Functional Requirements", type: "textarea", value: "- The system shall accurately detect, process, and interpret input signals within specified timeframes.\n- The system shall execute defined operations and workflows according to established protocols and user commands.\n- The system shall maintain secure data storage and perform reliable data retrieval with integrity checks.\n- The system shall provide user authentication and authorization mechanisms to control access to functionalities.\n- The system shall generate standardized reports and logs detailing operation statuses, errors, and events.\n- The system shall support integration interfaces for communication with external systems and components.\n- The system shall perform self-diagnostics and error handling to ensure operational continuity and alert users of" },
          { key: "performance_requirements", label: "Performance Requirements", type: "textarea", value: "- The system shall process data at a minimum throughput of 100 transactions per second to ensure timely responses under peak load conditions.  \n- The device shall maintain operational accuracy within ±0.5% over an ambient temperature range of 0°C to 50°C to guarantee consistent performance in typical environments.  \n- Power consumption shall not exceed 10 watts during standard operation to optimize energy efficiency and extend battery life in portable applications." },
          { key: "environment_conditions", label: "Environmental / Operating Conditions", type: "textarea", value: "The environmental and operating conditions for this specification section should include the range of temperatures, humidity levels, atmospheric pressure, vibration, shock, and other relevant environmental factors to which the product or system will be exposed during normal operation, storage, and transportation. Conditions such as operating temperature range (-20°C to 50°C), relative humidity (10% to 90% non-condensing), altitude (up to 2000 meters), and exposure to dust or water ingress (IP rating if applicable) must be detailed to ensure reliable performance under specified conditions." },
          { key: "interfaces", label: "Interfaces", type: "textarea", value: "- Integration with external systems through RESTful APIs to enable data exchange and command execution.\n- Support for USB and serial communication ports for peripheral devices.\n- Ethernet interface for network connectivity and remote management.\n- Wireless communication capabilities including Wi-Fi and Bluetooth for flexible deployment.\n- Data input interfaces supporting standard sensors and user input devices.\n- Output interfaces for LCD displays, LEDs, and actuator control signals.\n- Compliance with standard communication protocols such as Modbus and CAN bus for industrial environments." },
          { key: "inputs_outputs", label: "Inputs / Outputs", type: "textarea", value: "- Inputs: Sensor data signals, user commands, authentication credentials, external system communications, diagnostic information.\n- Outputs: Processed data reports, system status logs, error alerts, authentication responses, integration interface messages, diagnostic alerts." },
          { key: "constraints", label: "Constraints / Limitations", type: "textarea", value: "- Maximum allowable data input size is 10 MB to ensure efficient processing without performance degradation.  \n- System operation is limited to environments with ambient temperatures between -20°C and 50°C and relative humidity from 10% to 90% non-condensing.  \n- Communication interfaces must adhere to predefined protocol standards to maintain compatibility with external systems.  \n- Power supply constraints restrict maximum consumption to 10 watts during standard operation.  \n- The system shall not operate beyond an altitude of 2000 meters to maintain functional integrity.  \n- Any software updates must be backward compatible with existing system versions to avoid" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          functional_requirements: 2,
          performance_requirements: 2,
          environment_conditions: 2,
          interfaces: 2,
          inputs_outputs: 2,
          constraints: 2
        }
      },
      {
        title: "Compliance & Standards",
        id: "SEC-004",
        type: "Compliance & Standards",
        fields: [
          { key: "target_standards", label: "Target Standards", type: "textarea", value: "- ISO 9001:2015 - Quality Management Systems  \n- ISO/IEC 27001 - Information Security Management  \n- IEC 62304 - Medical Device Software Lifecycle Processes  \n- ISO 13485 - Medical Devices Quality Management  \n- IEEE 829 - Software Test Documentation  \n- ISO/IEC 12207 - Systems and Software Engineering Lifecycle Processes  \n- RoHS Directive 2011/65/EU - Restriction of Hazardous Substances  \n- CE Marking Compliance  \n- FDA 21 CFR Part 820 - Quality System Regulation for Medical Devices" },
          { key: "regulatory_requirements", label: "Regulatory Requirements", type: "textarea", value: "The product shall comply with all applicable regulatory requirements including, but not limited to, the following:\n\n- Compliance with relevant national and international safety regulations such as IEC 62368-1 for audio/video, information and communication technology equipment safety.\n- Adherence to electromagnetic compatibility (EMC) standards including FCC Part 15 (USA), CE marking directives (EU), and CISPR 32 for emissions and immunity.\n- Conformance to RoHS (Restriction of Hazardous Substances) directive limiting hazardous materials in electrical and electronic equipment.\n- Compliance with WEEE (Waste Electrical and Electronic Equipment) directive for" },
          { key: "quality_requirements", label: "Quality / Safety Requirements", type: "textarea", value: "- The product shall comply with established quality management system standards, such as ISO 9001, to ensure consistent quality processes and continuous improvement.\n- All safety-related components and processes shall meet applicable safety standards, including ISO 12100 for risk assessment and ISO 13849 for safety-related control systems.\n- The design and manufacturing processes shall incorporate rigorous quality control measures, including incoming inspection, in-process monitoring, and final product testing to maintain high reliability and safety levels.\n- The product shall undergo failure mode and effects analysis (FMEA) to identify and mitigate potential safety risks throughout its lifecycle.\n- All" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          target_standards: 2,
          regulatory_requirements: 2,
          quality_requirements: 2
        }
      },
      {
        title: "Verification",
        id: "SEC-005",
        type: "Verification",
        fields: [
          { key: "verification_method", label: "Verification Method", type: "textarea", value: "Verification shall be conducted through a combination of methods including functional testing, system integration testing, and compliance audits. Functional testing will validate that all specified requirements are met under normal and edge case conditions. System integration testing will ensure interoperability with external interfaces and subsystems. Compliance audits will verify adherence to applicable regulatory and quality standards. Test procedures, test cases, and test environments will be documented in a dedicated test plan, with results recorded and analyzed to confirm fulfillment of acceptance criteria." },
          { key: "acceptance_criteria", label: "Acceptance Criteria", type: "textarea", value: "- All specified functional requirements are met without critical defects or deviations.\n- Performance targets, including throughput and accuracy, are achieved within defined tolerances.\n- The product operates reliably across the specified environmental and operating conditions.\n- Interfaces function correctly with all required external systems and peripherals.\n- Inputs and outputs conform to the defined formats and protocols.\n- Constraints and limitations are respected, ensuring system stability and safety.\n- Verification tests pass according to predefined test procedures with no unresolved anomalies.\n- Documentation of verification results is complete, accurate, and traceable.\n- Compliance with all applicable standards and regulatory requirements is demonstrated.\n-" },
          { key: "test_plan_reference", label: "Test Plan Reference", type: "textarea", value: "Refer to the Verification Test Plan v1.2, document number TP-005-2026, which details the procedures, test cases, and acceptance criteria for validating compliance and functionality outlined in this specification section." }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          verification_method: 2,
          acceptance_criteria: 2,
          test_plan_reference: 2
        }
      },
      {
        title: "Assumptions & Risks",
        id: "SEC-006",
        type: "Assumptions & Risks",
        fields: [
          { key: "assumptions", label: "Assumptions", type: "textarea", value: "- The system architecture and design are assumed to remain stable throughout the development lifecycle.\n- All external interfaces and dependencies will comply with specified standards and protocols.\n- The development team has access to all necessary resources, including hardware, software, and documentation.\n- Stakeholders will provide timely feedback and approvals during the review phases.\n- Regulatory and quality requirements remain consistent and unchanged.\n- Environmental conditions will align with those specified in the specification.\n- No significant changes to project scope or objectives will occur without formal change control.\n- Risks identified will be mitigated according to established risk management processes." },
          { key: "risks", label: "Risks / Mitigations", type: "textarea", value: "- Risk: Potential delays in project timeline due to unclear assumptions or incomplete risk identification. Mitigation: Establish a comprehensive risk management process with regular reviews and updates.\n- Risk: Technical challenges arising from unforeseen environmental conditions or interface incompatibilities. Mitigation: Conduct thorough environmental testing and interface validation early in development.\n- Risk: Non-compliance with regulatory requirements due to evolving standards or misinterpretation. Mitigation: Engage regulatory experts and maintain up-to-date compliance tracking.\n- Risk: Quality issues stemming from inadequate verification procedures or incomplete acceptance criteria. Mitigation: Implement rigorous verification protocols and continuous quality monitoring." },
          { key: "open_issues", label: "Open Issues", type: "textarea", value: "No open issues have been identified for this specification section at this time." }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          assumptions: 2,
          risks: 2,
          open_issues: 2
        }
      },
      {
        title: "Change Control",
        id: "SEC-007",
        type: "Change Control",
        fields: [
          { key: "change_log", label: "Change Log", type: "textarea", value: "Change Log:\n\n- 2026-01-28: Initial creation of the Change Control section to document all future changes to the specifications.\n- 2026-01-29: Added detailed review comments and updated structure for consistency with other specification sections." }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          change_log: 3
        }
      }
    ];

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };

      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };
      const fieldPrompts = {
        section_title: "Enter the section title for this specification.",
        section_no: "Enter the section identifier (e.g., SEC-001).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        fieldPrompts[f.key] = `Provide the ${f.label.toLowerCase()} for this specification section.`;
      }
      if(fieldPrompts.stakeholders){
        fieldPrompts.stakeholders = "Provide the stakeholders for this specification document.";
      }
      if(fieldPrompts.functional_requirements){
        fieldPrompts.functional_requirements = "Provide a list of functional requirements. Be technical and correct.";
      }
      if(fieldPrompts.performance_requirements){
        fieldPrompts.performance_requirements = "Provide a list of performance requirements. Make one to three sentences explaining each performance requirement in detail.";
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "Specifications Document",
      slug: slugifyPlanName("Specifications Document"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Capture and communicate the product specification.",
      scope: "Define requirements, interfaces, constraints, compliance targets, and verification approach.",
      ai_review_guidance: "Concise, professional, and specification-oriented. Use clear, unambiguous language.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
        chat_edit: "You edit a specifications document. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"SEC-001\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections with meaningful section titles and IDs. The set object should use full schema keys: {{schemaKeys}}. Write as a specifications document, not a test procedure. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this specification section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this specification section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add context, stakeholders, and review notes here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded Specifications Document.", "ok");
    toast("Seeded", "Specifications Document created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedRequirementsTraceabilityMatrix(){
    const matrixCols = [
      { id: "req_id", label: "Requirement ID" },
      { id: "requirement", label: "Requirement" },
      { id: "verification_method", label: "Verification Method" },
      { id: "test_case", label: "Test Case ID(s)" },
      { id: "status", label: "Status" },
      { id: "notes", label: "Notes" }
    ];
    const matrixRows = ["REQ-001","REQ-002","REQ-003","REQ-004","REQ-005"].map(id => ({ id, label: id }));
    const matrixValue = {
      rows: matrixRows.map(r => r.id),
      cols: matrixCols.map(c => c.id),
      row_labels: matrixRows.reduce((acc, r) => { acc[r.id] = r.label; return acc; }, {}),
      col_labels: matrixCols.reduce((acc, c) => { acc[c.id] = c.label; return acc; }, {}),
      cells: matrixRows.reduce((acc, r) => {
        acc[matrixCellKey(r.id, "req_id")] = r.id;
        return acc;
      }, {})
    };

    const sections = [
      {
        title: "Core Metadata",
        id: "RTM-001",
        type: "Core Metadata",
        fields: [
          { key: "doc_title", label: "Document Title", type: "text", value: "Requirements Traceability Matrix" },
          { key: "doc_id", label: "Document ID", type: "text", value: "RTM-0001" },
          { key: "version", label: "Version", type: "text", value: "1.0" },
          { key: "owner", label: "Owner", type: "text", value: "Systems Engineering" },
          { key: "date_created", label: "Date Created", type: "text", value: "" },
          { key: "date_updated", label: "Date Updated", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          doc_title: 3,
          doc_id: 3,
          version: 3,
          owner: 3,
          date_created: 0,
          date_updated: 0
        }
      },
      {
        title: "Traceability Matrix",
        id: "RTM-002",
        type: "Traceability Matrix",
        fields: [
          { key: "rtm_matrix", label: "RTM Matrix", type: "matrix", value: matrixValue }
        ],
        schema: {
          rtm_matrix: {
            rows: matrixRows,
            cols: matrixCols
          }
        },
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          rtm_matrix: 2
        }
      }
    ];

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };
      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };
      const fieldPrompts = {
        section_title: "Enter the section title for this requirements traceability matrix.",
        section_no: "Enter the section identifier (e.g., RTM-001).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        fieldPrompts[f.key] = f.type === "matrix"
          ? "Provide the requirements traceability matrix with requirement IDs mapped to verification methods, test cases, and status."
          : `Provide the ${f.label.toLowerCase()} for this requirements traceability matrix section.`;
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      if(section.schema && section.schema.rtm_matrix){
        if(!normalized._ai.field_schema) normalized._ai.field_schema = {};
        normalized._ai.field_schema.rtm_matrix = cloneJsonValue(section.schema.rtm_matrix);
      }
      if(!normalized._ai.field_schema) normalized._ai.field_schema = {};
      if(!normalized._ai.field_schema.rtm_matrix) normalized._ai.field_schema.rtm_matrix = {};
      normalized._ai.field_schema.rtm_matrix.col_prompts = {
        req_id: "Requirement ID (e.g., REQ-001).",
        requirement: "Requirement text summary.",
        method: "Verification method (Test, Analysis, Inspection, Demo).",
        test_case: "Test case ID or name.",
        status: "Status (Planned/In Progress/Complete).",
        notes: "Notes or rationale."
      };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      if(section.id === "BOM-001"){
        normalized._ai.last_ai_reviewed = "";
        normalized._ai.last_ai_review_model = "";
        normalized._ai.last_human_reviewed = "2026-01-30T21:07:22.874Z";
      }
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "Requirements Traceability Matrix",
      slug: slugifyPlanName("Requirements Traceability Matrix"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Trace requirements to verification methods and test cases.",
      scope: "Track requirement IDs, verification methods, coverage, and status in a structured matrix.",
      ai_review_guidance: "Concise, traceability-focused, and unambiguous. Use consistent requirement IDs and test references.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief. If matrix_cell is present, you are editing a single matrix cell. Use matrix_cell.row_label and matrix_cell.col_label to determine what belongs in that cell, and use matrix_cell.cell_value as the current value. Return ONLY the cell value (no explanations). If unknown, return an empty string. Never return placeholders like \"Value\", \"TBD\", or repeat the column label.{{guidanceLine}}",
        chat_edit: "You edit a requirements traceability matrix. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"RTM-001\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for a requirements traceability matrix. The set object should use full schema keys: {{schemaKeys}}. Use concise, matrix-style language. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this requirements traceability matrix section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this requirements traceability matrix section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add context, assumptions, and review notes here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded Requirements Traceability Matrix.", "ok");
    toast("Seeded", "Requirements Traceability Matrix created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedBillOfMaterials(){
    const matrixCols = [
      { id: "item", label: "Item" },
      { id: "refdes", label: "RefDes" },
      { id: "qty", label: "Qty" },
      { id: "description", label: "Description" },
      { id: "value", label: "Value" },
      { id: "package", label: "Package" },
      { id: "mfr_1", label: "Manufacturer 1" },
      { id: "mpn_1", label: "Manufacturer P/N 1" },
      { id: "mfr_2", label: "Manufacturer 2" },
      { id: "mpn_2", label: "Manufacturer P/N 2" },
      { id: "mfr_3", label: "Manufacturer 3" },
      { id: "mpn_3", label: "Manufacturer P/N 3" },
      { id: "notes", label: "Notes" }
    ];
    const matrixRows = ["001","002","003","004","005"].map(id => ({ id, label: id }));
    const matrixValue = {
      rows: matrixRows.map(r => r.id),
      cols: matrixCols.map(c => c.id),
      row_labels: matrixRows.reduce((acc, r) => { acc[r.id] = r.label; return acc; }, {}),
      col_labels: matrixCols.reduce((acc, c) => { acc[c.id] = c.label; return acc; }, {}),
      cells: matrixRows.reduce((acc, r) => {
        acc[matrixCellKey(r.id, "item")] = r.id;
        return acc;
      }, {})
    };
    matrixValue.cells[matrixCellKey("001", "mfr_1")] = "Texas Instruments";
    matrixValue.cells[matrixCellKey("001", "mpn_1")] = "TPS7A4700RGW";
    matrixValue.cells[matrixCellKey("001", "mfr_2")] = "Analog Devices";
    matrixValue.cells[matrixCellKey("001", "mpn_2")] = "ADP7104ARDZ";
    matrixValue.cells[matrixCellKey("001", "mfr_3")] = "Microchip";
    matrixValue.cells[matrixCellKey("001", "mpn_3")] = "MIC29302WU";

    const sections = [
      {
        title: "Core Metadata",
        id: "BOM-001",
        type: "Core Metadata",
        fields: [
          { key: "doc_title", label: "Document Title", type: "text", value: "Bill of Materials" },
          { key: "doc_id", label: "Document ID", type: "text", value: "BOM-0001" },
          { key: "version", label: "Version", type: "text", value: "1.0" },
          { key: "owner", label: "Owner", type: "text", value: "Manufacturing Engineering" },
          { key: "date_created", label: "Date Created", type: "text", value: "" },
          { key: "date_updated", label: "Date Updated", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          doc_title: 2,
          doc_id: 2,
          version: 2,
          owner: 2,
          date_created: 0,
          date_updated: 0
        }
      },
      {
        title: "BOM Table",
        id: "BOM-002",
        type: "BOM Table",
        fields: [
          { key: "bom_matrix", label: "BOM Matrix", type: "matrix", value: matrixValue }
        ],
        schema: {
          bom_matrix: {
            rows: matrixRows,
            cols: matrixCols
          }
        },
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          bom_matrix: 2
        }
      }
    ];

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };
      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };
      const fieldPrompts = {
        section_title: "Enter the section title for this bill of materials.",
        section_no: "Enter the section identifier (e.g., BOM-001).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        fieldPrompts[f.key] = f.type === "matrix"
          ? "Provide the bill of materials table with items, quantities, and manufacturer details."
          : `Provide the ${f.label.toLowerCase()} for this bill of materials section.`;
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      if(section.schema && section.schema.bom_matrix){
        if(!normalized._ai.field_schema) normalized._ai.field_schema = {};
        normalized._ai.field_schema.bom_matrix = cloneJsonValue(section.schema.bom_matrix);
      }
      if(!normalized._ai.field_schema) normalized._ai.field_schema = {};
      if(!normalized._ai.field_schema.bom_matrix) normalized._ai.field_schema.bom_matrix = {};
      normalized._ai.field_schema.bom_matrix.col_prompts = {
        item: "Item number.",
        refdes: "Reference designators (e.g., R1,R2,C5).",
        qty: "Quantity.",
        description: "Part description.",
        value: "Part value.",
        package: "Package or footprint.",
        mfr_1: "Primary manufacturer.",
        mpn_1: "Primary manufacturer part number.",
        mfr_2: "Alternate manufacturer.",
        mpn_2: "Alternate manufacturer part number.",
        mfr_3: "Second alternate manufacturer.",
        mpn_3: "Second alternate manufacturer part number.",
        notes: "Notes (e.g., DNP, orientation, assembly notes)."
      };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "Bill of Materials",
      slug: slugifyPlanName("Bill of Materials"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Capture a structured bill of materials for the design.",
      scope: "List items, quantities, reference designators, and sourcing details in a structured matrix.",
      ai_review_guidance: "Concise, manufacturing-oriented. Use clear part identifiers and consistent formatting.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
        chat_edit: "You edit a bill of materials document. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"BOM-001\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for a bill of materials. The set object should use full schema keys: {{schemaKeys}}. Use concise, manufacturing-style language. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this bill of materials section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this bill of materials section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add sourcing notes, alternates, and revision notes here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded Bill of Materials.", "ok");
    toast("Seeded", "Bill of Materials created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedVerificationMatrix(){
    const sections = [
      {
        title: "Core Metadata",
        id: "VM-001",
        type: "Core Metadata",
        fields: [
          { key: "doc_title", label: "Document Title", type: "text", value: "Verification Matrix" },
          { key: "doc_id", label: "Document ID", type: "text", value: "VM-0001" },
          { key: "version", label: "Version", type: "text", value: "1.0" },
          { key: "owner", label: "Owner", type: "text", value: "Systems Engineering" },
          { key: "date_created", label: "Date Created", type: "text", value: "" },
          { key: "date_updated", label: "Date Updated", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          doc_title: 2,
          doc_id: 2,
          version: 2,
          owner: 2,
          date_created: 0,
          date_updated: 0
        }
      },
      {
        title: "Requirements Table",
        id: "VM-002",
        type: "Requirements Table",
        fields: [
          { key: "requirements_table", label: "Requirements Table", type: "textarea", value: "REQ-001 | Provide regulated 5V output ±5%\nREQ-002 | Startup within 2 seconds\nREQ-003 | Operate from 9–15 VDC input" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          requirements_table: 2
        }
      },
      {
        title: "Verification Mapping",
        id: "VM-003",
        type: "Verification Mapping",
        fields: [
          { key: "verification_mapping", label: "Verification Mapping", type: "textarea", value: "REQ-001 → Test 003 (Power Voltages), Method: Test, Status: Planned\nREQ-002 → Test 004 (Input Power), Method: Test, Status: Planned\nREQ-003 → Test 004 (Input Power), Method: Test, Status: Planned" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          verification_mapping: 2
        }
      },
      {
        title: "Results Summary",
        id: "VM-004",
        type: "Results Summary",
        fields: [
          { key: "results_summary", label: "Results Summary", type: "textarea", value: "All mapped requirements are planned for verification. No results recorded yet." },
          { key: "coverage_gaps", label: "Coverage Gaps", type: "textarea", value: "None identified at this time." }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          results_summary: 2,
          coverage_gaps: 2
        }
      },
      {
        title: "Notes / Assumptions",
        id: "VM-005",
        type: "Notes / Assumptions",
        fields: [
          { key: "notes_assumptions", label: "Notes / Assumptions", type: "textarea", value: "Assumptions:\n- Requirements list is stable for this revision.\n- Verification methods will be test-based unless noted otherwise." }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          notes_assumptions: 2
        }
      }
    ];

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };

      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };
      const fieldPrompts = {
        section_title: "Enter the section title for this verification matrix.",
        section_no: "Enter the section identifier (e.g., VM-001).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        fieldPrompts[f.key] = `Provide the ${f.label.toLowerCase()} for this verification matrix section.`;
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "Verification Matrix",
      slug: slugifyPlanName("Verification Matrix"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Map requirements to verification methods and results.",
      scope: "Define requirement IDs, verification methods, and coverage status in a single matrix.",
      ai_review_guidance: "Concise, technical, verification-oriented. Use clear mappings and unambiguous labels.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
        chat_edit: "You edit a verification matrix. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"VM-001\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for a verification matrix. The set object should use full schema keys: {{schemaKeys}}. Use concise, matrix-style language. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this verification matrix section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this verification matrix section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add context, assumptions, and review notes here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded Verification Matrix.", "ok");
    toast("Seeded", "Verification Matrix created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedDesignReviewChecklist(){
    const sections = [
      {
        title: "Review Metadata",
        id: "DR-001",
        type: "Review Metadata",
        fields: [
          { key: "review_title", label: "Review Title", type: "text", value: "Design Review Checklist" },
          { key: "review_id", label: "Review ID", type: "text", value: "DR-001" },
          { key: "review_type", label: "Review Type", type: "text", value: "PDR" },
          { key: "owner_chair", label: "Owner / Chair", type: "text", value: "Systems Engineering" },
          { key: "review_date", label: "Review Date", type: "text", value: "" },
          { key: "product_program", label: "Product / Program", type: "text", value: "" },
          { key: "version", label: "Version / Revision", type: "text", value: "1.0" },
          { key: "attendees", label: "Attendees", type: "textarea", value: "" },
          { key: "review_scope", label: "Review Scope", type: "textarea", value: "" },
          { key: "artifacts_reviewed", label: "Artifacts Reviewed", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          review_title: 2,
          review_id: 2,
          review_type: 2,
          owner_chair: 2,
          review_date: 0,
          product_program: 0,
          version: 2,
          attendees: 0,
          review_scope: 0,
          artifacts_reviewed: 0
        }
      },
      {
        title: "Requirements & Traceability",
        id: "DR-002",
        type: "Requirements & Traceability",
        fields: [
          { key: "requirements_coverage", label: "Requirements Coverage", type: "textarea", value: "" },
          { key: "traceability_links", label: "Traceability Links", type: "textarea", value: "" },
          { key: "unverified_requirements", label: "Unverified Requirements", type: "textarea", value: "" },
          { key: "requirements_risks", label: "Requirements Risks", type: "textarea", value: "" },
          { key: "notes", label: "Notes", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          requirements_coverage: 0,
          traceability_links: 0,
          unverified_requirements: 0,
          requirements_risks: 0,
          notes: 0
        }
      },
      {
        title: "Architecture & Interfaces",
        id: "DR-003",
        type: "Architecture & Interfaces",
        fields: [
          { key: "architecture_summary", label: "System Architecture Summary", type: "textarea", value: "" },
          { key: "interface_definitions", label: "Interface Definitions", type: "textarea", value: "" },
          { key: "assumptions_constraints", label: "Assumptions / Constraints", type: "textarea", value: "" },
          { key: "open_interface_questions", label: "Open Interface Questions", type: "textarea", value: "" },
          { key: "notes", label: "Notes", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          architecture_summary: 0,
          interface_definitions: 0,
          assumptions_constraints: 0,
          open_interface_questions: 0,
          notes: 0
        }
      },
      {
        title: "Design Details",
        id: "DR-004",
        type: "Design Details",
        fields: [
          { key: "design_correctness", label: "Schematic / Design Correctness", type: "textarea", value: "" },
          { key: "component_selection", label: "Component Selection & Derating", type: "textarea", value: "" },
          { key: "layout_dfm", label: "Layout / Placement / DFM Notes", type: "textarea", value: "" },
          { key: "thermal_considerations", label: "Thermal Considerations", type: "textarea", value: "" },
          { key: "power_budget", label: "Power Budget", type: "textarea", value: "" },
          { key: "notes", label: "Notes", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          design_correctness: 0,
          component_selection: 0,
          layout_dfm: 0,
          thermal_considerations: 0,
          power_budget: 0,
          notes: 0
        }
      },
      {
        title: "Verification Plan & Coverage",
        id: "DR-005",
        type: "Verification Plan & Coverage",
        fields: [
          { key: "verification_methods", label: "Verification Methods", type: "textarea", value: "" },
          { key: "coverage_gaps", label: "Coverage Gaps", type: "textarea", value: "" },
          { key: "test_readiness", label: "Test Readiness", type: "textarea", value: "" },
          { key: "required_fixtures", label: "Required Fixtures / Equipment", type: "textarea", value: "" },
          { key: "notes", label: "Notes", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          verification_methods: 0,
          coverage_gaps: 0,
          test_readiness: 0,
          required_fixtures: 0,
          notes: 0
        }
      },
      {
        title: "Risk & Safety",
        id: "DR-006",
        type: "Risk & Safety",
        fields: [
          { key: "safety_considerations", label: "Safety Considerations", type: "textarea", value: "" },
          { key: "fmea_summary", label: "FMEA Summary", type: "textarea", value: "" },
          { key: "reliability_risks", label: "Reliability Risks", type: "textarea", value: "" },
          { key: "mitigations", label: "Mitigations", type: "textarea", value: "" },
          { key: "notes", label: "Notes", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          safety_considerations: 0,
          fmea_summary: 0,
          reliability_risks: 0,
          mitigations: 0,
          notes: 0
        }
      },
      {
        title: "Action Items & Disposition",
        id: "DR-007",
        type: "Action Items & Disposition",
        fields: [
          { key: "findings_issues", label: "Findings / Issues", type: "textarea", value: "" },
          { key: "disposition", label: "Disposition", type: "text", value: "" },
          { key: "action_items", label: "Action Items", type: "textarea", value: "" },
          { key: "final_recommendation", label: "Final Recommendation", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          findings_issues: 0,
          disposition: 0,
          action_items: 0,
          final_recommendation: 0
        }
      }
    ];

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };

      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };
      const fieldPrompts = {
        section_title: "Enter the section title for this design review.",
        section_no: "Enter the section identifier (e.g., DR-001).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        fieldPrompts[f.key] = `Provide the ${f.label.toLowerCase()} for this design review section.`;
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "Design Review Checklist",
      slug: slugifyPlanName("Design Review Checklist"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Ensure design readiness through a structured review checklist.",
      scope: "Capture review criteria, risks, and disposition across requirements, architecture, design, and verification.",
      ai_review_guidance: "Concise, professional, review-oriented. Use checklist-style statements and clear dispositions.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
        chat_edit: "You edit a design review checklist. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"DR-001\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for a design review checklist. The set object should use full schema keys: {{schemaKeys}}. Use checklist-style, review-oriented language. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this design review section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this design review section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add review context, attendees, and action items here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded Design Review Checklist.", "ok");
    toast("Seeded", "Design Review Checklist created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedInterfaceControlDocument(){
    const sections = [
      {
        title: "Core Metadata",
        id: "ICD-001",
        type: "Core Metadata",
        fields: [
          { key: "doc_title", label: "Document Title", type: "text", value: "Interface Control Document" },
          { key: "doc_id", label: "Document ID / Number", type: "text", value: "ICD-001" },
          { key: "version", label: "Version", type: "text", value: "1.0" },
          { key: "status", label: "Status", type: "text", value: "Draft" },
          { key: "owner", label: "Owner / Author", type: "text", value: "Systems Engineering" },
          { key: "stakeholders", label: "Stakeholders", type: "textarea", value: "" },
          { key: "date_created", label: "Date Created", type: "text", value: "" },
          { key: "date_updated", label: "Date Updated", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          doc_title: 2,
          doc_id: 2,
          version: 2,
          status: 2,
          owner: 2,
          stakeholders: 0,
          date_created: 0,
          date_updated: 0
        }
      },
      {
        title: "Interface Overview",
        id: "ICD-002",
        type: "Interface Overview",
        fields: [
          { key: "purpose", label: "Purpose", type: "textarea", value: "" },
          { key: "scope", label: "Scope", type: "textarea", value: "" },
          { key: "interface_summary", label: "Interface Summary", type: "textarea", value: "" },
          { key: "assumptions_constraints", label: "Assumptions / Constraints", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          purpose: 0,
          scope: 0,
          interface_summary: 0,
          assumptions_constraints: 0
        }
      },
      {
        title: "Connector & Pinout",
        id: "ICD-003",
        type: "Connector & Pinout",
        fields: [
          { key: "connector_id", label: "Connector ID / Name", type: "text", value: "" },
          { key: "connector_type", label: "Connector Type / Part Number", type: "text", value: "" },
          { key: "pinout_table", label: "Pinout Table", type: "textarea", value: "" },
          { key: "mechanical_notes", label: "Mechanical Interface Notes", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          connector_id: 0,
          connector_type: 0,
          pinout_table: 0,
          mechanical_notes: 0
        }
      },
      {
        title: "Electrical Characteristics",
        id: "ICD-004",
        type: "Electrical Characteristics",
        fields: [
          { key: "signal_levels", label: "Signal Levels / Logic Standards", type: "textarea", value: "" },
          { key: "voltage_current_limits", label: "Voltage / Current Limits", type: "textarea", value: "" },
          { key: "power_pins_budget", label: "Power Pins & Budget", type: "textarea", value: "" },
          { key: "esd_protection", label: "ESD / Protection Requirements", type: "textarea", value: "" },
          { key: "grounding_shielding", label: "Grounding / Shielding Strategy", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          signal_levels: 0,
          voltage_current_limits: 0,
          power_pins_budget: 0,
          esd_protection: 0,
          grounding_shielding: 0
        }
      },
      {
        title: "Protocols & Timing",
        id: "ICD-005",
        type: "Protocols & Timing",
        fields: [
          { key: "protocols", label: "Protocol(s)", type: "textarea", value: "" },
          { key: "timing_requirements", label: "Timing Requirements", type: "textarea", value: "" },
          { key: "signal_integrity", label: "Signal Integrity / Termination", type: "textarea", value: "" },
          { key: "clock_reset", label: "Clock / Reset Requirements", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          protocols: 0,
          timing_requirements: 0,
          signal_integrity: 0,
          clock_reset: 0
        }
      },
      {
        title: "Interfaces & Dependencies",
        id: "ICD-006",
        type: "Interfaces & Dependencies",
        fields: [
          { key: "external_interfaces", label: "External Interfaces", type: "textarea", value: "" },
          { key: "dependencies", label: "Dependencies / Preconditions", type: "textarea", value: "" },
          { key: "compatibility", label: "Compatibility / Backward Support", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          external_interfaces: 0,
          dependencies: 0,
          compatibility: 0
        }
      },
      {
        title: "Verification & Compliance",
        id: "ICD-007",
        type: "Verification & Compliance",
        fields: [
          { key: "verification_method", label: "Verification Method", type: "textarea", value: "" },
          { key: "acceptance_criteria", label: "Acceptance Criteria", type: "textarea", value: "" },
          { key: "applicable_standards", label: "Applicable Standards", type: "textarea", value: "" },
          { key: "test_plan_reference", label: "Test Plan Reference", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          verification_method: 0,
          acceptance_criteria: 0,
          applicable_standards: 0,
          test_plan_reference: 0
        }
      },
      {
        title: "Change Control",
        id: "ICD-008",
        type: "Change Control",
        fields: [
          { key: "change_log", label: "Change Log", type: "textarea", value: "" },
          { key: "open_issues", label: "Open Issues", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          change_log: 0,
          open_issues: 0
        }
      }
    ];

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };

      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };
      const fieldPrompts = {
        section_title: "Enter the section title for this interface control document.",
        section_no: "Enter the section identifier (e.g., ICD-001).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        fieldPrompts[f.key] = `Provide the ${f.label.toLowerCase()} for this interface control document section.`;
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "Interface Control Document",
      slug: slugifyPlanName("Interface Control Document"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Define interfaces, pinouts, protocols, and electrical limits for system integration.",
      scope: "Capture connector details, electrical characteristics, and verification requirements for each interface.",
      ai_review_guidance: "Concise, technical, and interface-focused. Use clear terminology and unambiguous requirements.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
        chat_edit: "You edit an interface control document. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"ICD-001\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for an interface control document. The set object should use full schema keys: {{schemaKeys}}. Use precise interface terminology. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this interface control document section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this interface control document section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add interface context, open issues, and review notes here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded Interface Control Document.", "ok");
    toast("Seeded", "Interface Control Document created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedEmcCompliancePlan(){
    const sections = [
      {
        title: "Core Metadata",
        id: "EMC-001",
        type: "Core Metadata",
        fields: [
          { key: "document_title", label: "Document Title", type: "text", value: "EMC/EMI Compliance Plan" },
          { key: "document_id_number", label: "Document ID / Number", type: "text", value: "EMC-0001" },
          { key: "revision", label: "Revision", type: "text", value: "1.0" },
          { key: "status", label: "Status", type: "text", value: "Draft" },
          { key: "owner_author", label: "Owner / Author", type: "text", value: "Compliance Engineering" },
          { key: "stakeholders", label: "Stakeholders", type: "textarea", value: "" },
          { key: "date_created", label: "Date Created", type: "text", value: "" },
          { key: "date_updated", label: "Date Updated", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          document_title: 2,
          document_id_number: 2,
          revision: 2,
          status: 2,
          owner_author: 2,
          stakeholders: 0,
          date_created: 0,
          date_updated: 0
        }
      },
      {
        title: "Scope & Objectives",
        id: "EMC-002",
        type: "Scope & Objectives",
        fields: [
          { key: "purpose", label: "Purpose", type: "textarea", value: "" },
          { key: "scope_detail", label: "Scope", type: "textarea", value: "" },
          { key: "product_variants", label: "Product/Variant Coverage", type: "textarea", value: "" },
          { key: "regulatory_regions", label: "Regulatory Regions", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          purpose: 2,
          scope_detail: 2,
          product_variants: 2,
          regulatory_regions: 2
        }
      },
      {
        title: "Applicable Standards",
        id: "EMC-003",
        type: "Applicable Standards",
        fields: [
          { key: "emissions_standards", label: "Emissions Standards", type: "textarea", value: "" },
          { key: "immunity_standards", label: "Immunity Standards", type: "textarea", value: "" },
          { key: "safety_installation_standards", label: "Safety/Installation Standards", type: "textarea", value: "" },
          { key: "product_family_standards", label: "Product Family Standards", type: "textarea", value: "" },
          { key: "deviations_notes", label: "Notes on Deviations/Interpretations", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          emissions_standards: 2,
          immunity_standards: 2,
          safety_installation_standards: 2,
          product_family_standards: 2,
          deviations_notes: 2
        }
      },
      {
        title: "Test Configuration",
        id: "EMC-004",
        type: "Test Configuration",
        fields: [
          { key: "eut_description", label: "EUT Description", type: "textarea", value: "" },
          { key: "operating_modes", label: "Operating Modes / States", type: "textarea", value: "" },
          { key: "cabling_io", label: "Cabling & I/O Configuration", type: "textarea", value: "" },
          { key: "power_configuration", label: "Power Configuration", type: "textarea", value: "" },
          { key: "grounding_bonding", label: "Grounding / Bonding", type: "textarea", value: "" },
          { key: "boundary_conditions", label: "Boundary Conditions", type: "textarea", value: "" },
          { key: "test_levels_margins", label: "Test Levels / Margins", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          eut_description: 2,
          operating_modes: 2,
          cabling_io: 2,
          power_configuration: 2,
          grounding_bonding: 2,
          boundary_conditions: 2,
          test_levels_margins: 2
        }
      },
      {
        title: "Emissions Tests",
        id: "EMC-005",
        type: "Emissions Tests",
        fields: [
          { key: "conducted_emissions", label: "Conducted Emissions", type: "textarea", value: "" },
          { key: "radiated_emissions", label: "Radiated Emissions", type: "textarea", value: "" },
          { key: "harmonics_flicker", label: "Harmonics / Flicker (if applicable)", type: "textarea", value: "" },
          { key: "emissions_limits", label: "Test Limits", type: "textarea", value: "" },
          { key: "worst_case_mode", label: "Worst‑Case Mode", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          conducted_emissions: 2,
          radiated_emissions: 2,
          harmonics_flicker: 2,
          emissions_limits: 2,
          worst_case_mode: 2
        }
      },
      {
        title: "Immunity Tests",
        id: "EMC-006",
        type: "Immunity Tests",
        fields: [
          { key: "esd", label: "ESD", type: "textarea", value: "" },
          { key: "eft_burst", label: "EFT/Burst", type: "textarea", value: "" },
          { key: "surge", label: "Surge", type: "textarea", value: "" },
          { key: "conducted_rf_immunity", label: "Conducted RF Immunity", type: "textarea", value: "" },
          { key: "radiated_rf_immunity", label: "Radiated RF Immunity", type: "textarea", value: "" },
          { key: "magnetic_fields", label: "Magnetic Fields (if applicable)", type: "textarea", value: "" },
          { key: "immunity_test_levels", label: "Test Levels", type: "textarea", value: "" },
          { key: "immunity_pass_fail", label: "Pass/Fail Criteria", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          esd: 2,
          eft_burst: 2,
          surge: 2,
          conducted_rf_immunity: 2,
          radiated_rf_immunity: 2,
          magnetic_fields: 2,
          immunity_test_levels: 2,
          immunity_pass_fail: 2
        }
      },
      {
        title: "Test Facilities & Equipment",
        id: "EMC-007",
        type: "Test Facilities & Equipment",
        fields: [
          { key: "lab_site", label: "Accredited Lab / Site", type: "textarea", value: "" },
          { key: "equipment_list", label: "Equipment List", type: "textarea", value: "" },
          { key: "calibration_requirements", label: "Calibration Requirements", type: "textarea", value: "" },
          { key: "uncertainty_tolerance", label: "Uncertainty / Tolerance", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          lab_site: 2,
          equipment_list: 2,
          calibration_requirements: 2,
          uncertainty_tolerance: 2
        }
      },
      {
        title: "Pre‑Compliance Strategy",
        id: "EMC-008",
        type: "Pre‑Compliance Strategy",
        fields: [
          { key: "prescan_plan", label: "Pre‑scan Plan", type: "textarea", value: "" },
          { key: "remediation_plan", label: "Debug/Remediation Plan", type: "textarea", value: "" },
          { key: "risk_areas", label: "Risk Areas / Suspected Emissions", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          prescan_plan: 2,
          remediation_plan: 2,
          risk_areas: 2
        }
      },
      {
        title: "Acceptance Criteria",
        id: "EMC-009",
        type: "Acceptance Criteria",
        fields: [
          { key: "compliance_criteria", label: "Compliance Criteria", type: "textarea", value: "" },
          { key: "margin_targets", label: "Margin Targets", type: "textarea", value: "" },
          { key: "retest_criteria", label: "Re‑test Criteria", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          compliance_criteria: 2,
          margin_targets: 2,
          retest_criteria: 2
        }
      },
      {
        title: "Schedule & Deliverables",
        id: "EMC-010",
        type: "Schedule & Deliverables",
        fields: [
          { key: "test_schedule", label: "Test Schedule", type: "textarea", value: "" },
          { key: "artifacts", label: "Artifacts (reports, plots, photos)", type: "textarea", value: "" },
          { key: "responsible_roles", label: "Responsible Roles", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          test_schedule: 2,
          artifacts: 2,
          responsible_roles: 2
        }
      },
      {
        title: "Risks & Mitigations",
        id: "EMC-011",
        type: "Risks & Mitigations",
        fields: [
          { key: "risks", label: "Risks", type: "textarea", value: "" },
          { key: "mitigations", label: "Mitigations", type: "textarea", value: "" },
          { key: "open_issues", label: "Open Issues", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          risks: 2,
          mitigations: 2,
          open_issues: 2
        }
      }
    ];

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };

      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };

      const fieldPrompts = {
        section_title: "Enter the section title for this EMC/EMI compliance plan.",
        section_no: "Enter the section identifier (e.g., EMC-001).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        fieldPrompts[f.key] = `Provide the ${f.label.toLowerCase()} for this EMC/EMI compliance plan.`;
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      if(section.schema && section.schema.verification_matrix){
        if(!normalized._ai.field_schema) normalized._ai.field_schema = {};
        normalized._ai.field_schema.verification_matrix = cloneJsonValue(section.schema.verification_matrix);
      }
      if(!normalized._ai.field_schema) normalized._ai.field_schema = {};
      if(!normalized._ai.field_schema.verification_matrix) normalized._ai.field_schema.verification_matrix = {};
      normalized._ai.field_schema.verification_matrix.col_prompts = {
        req_id: "Requirement ID (e.g., REQ-001).",
        requirement: "Requirement text summary.",
        method: "Verification method (Test, Analysis, Inspection, Demo).",
        test_case: "Test case ID or name.",
        status: "Status (Planned/In Progress/Complete).",
        notes: "Notes or rationale."
      };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "EMC/EMI Compliance Plan",
      slug: slugifyPlanName("EMC/EMI Compliance Plan"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Define standards, tests, and limits required to achieve EMC/EMI compliance.",
      scope: "Covers emissions and immunity requirements, test configuration, limits, facilities, and evidence.",
      ai_review_guidance: "Concise, compliance-focused, and technical. Use standard EMC terminology and clear criteria.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
        chat_edit: "You edit an EMC/EMI compliance plan. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"EMC-001\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for an EMC/EMI compliance plan. The set object should use full schema keys: {{schemaKeys}}. Use standard EMC terminology. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this EMC/EMI compliance plan. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this EMC/EMI compliance plan. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add standards, test configuration details, and evidence notes here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded EMC/EMI Compliance Plan.", "ok");
    toast("Seeded", "EMC/EMI Compliance Plan created.", "ok");
    runAsync(renderLibrary());
  }

  async function seedFmea(){
    const scaleOptions = ["1","2","3","4","5","6","7","8","9","10"];
    const sections = [
      {
        title: "Core Metadata",
        id: "FMEA-001",
        type: "Core Metadata",
        fields: [
          { key: "doc_title", label: "Document Title", type: "text", value: "FMEA" },
          { key: "doc_id", label: "Document ID", type: "text", value: "FMEA-001" },
          { key: "version", label: "Version", type: "text", value: "1.0" },
          { key: "status", label: "Status", type: "text", value: "Draft" },
          { key: "owner", label: "Owner / Author", type: "text", value: "Reliability Engineering" },
          { key: "stakeholders", label: "Stakeholders", type: "textarea", value: "" },
          { key: "date_created", label: "Date Created", type: "text", value: "" },
          { key: "date_updated", label: "Date Updated", type: "text", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          doc_title: 2,
          doc_id: 2,
          version: 2,
          status: 2,
          owner: 2,
          stakeholders: 0,
          date_created: 0,
          date_updated: 0
        }
      },
      {
        title: "System / Scope",
        id: "FMEA-002",
        type: "System / Scope",
        fields: [
          { key: "system_description", label: "System Description", type: "textarea", value: "" },
          { key: "scope", label: "Scope / Boundaries", type: "textarea", value: "" },
          { key: "assumptions", label: "Assumptions", type: "textarea", value: "" },
          { key: "operating_environment", label: "Operating Environment", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          system_description: 0,
          scope: 0,
          assumptions: 0,
          operating_environment: 0
        }
      }
    ];

    for(let i = 1; i <= 5; i++){
      sections.push({
        title: `Failure Mode ${i}`,
        id: `FMEA-00${i + 2}`,
        type: "Failure Mode",
        fields: [
          { key: "item_function", label: "Item / Function", type: "text", value: "" },
          { key: "failure_mode", label: "Failure Mode", type: "text", value: "" },
          { key: "effect", label: "Effect", type: "textarea", value: "" },
          { key: "cause", label: "Cause", type: "textarea", value: "" },
          { key: "severity", label: "Severity", type: "select", value: "" },
          { key: "occurrence", label: "Occurrence", type: "select", value: "" },
          { key: "detection", label: "Detection", type: "select", value: "" },
          { key: "rpn", label: "RPN", type: "computed", value: "" },
          { key: "current_controls", label: "Current Controls", type: "textarea", value: "" },
          { key: "recommended_actions", label: "Recommended Actions", type: "textarea", value: "" },
          { key: "action_owner_due", label: "Action Owner / Due Date", type: "text", value: "" },
          { key: "action_status", label: "Action Status", type: "text", value: "" },
          { key: "verification_method", label: "Verification Method", type: "textarea", value: "" },
          { key: "acceptance_criteria", label: "Acceptance Criteria", type: "textarea", value: "" },
          { key: "test_plan_reference", label: "Test Plan Reference", type: "textarea", value: "" }
        ],
        maturity: {
          section_title: 3,
          section_no: 3,
          section_type: 3,
          param1_label: 3,
          param1_value: 3,
          param2_label: 3,
          param2_value: 3,
          item_function: 0,
          failure_mode: 0,
          effect: 0,
          cause: 0,
          severity: 2,
          occurrence: 2,
          detection: 2,
          rpn: 4,
          current_controls: 0,
          recommended_actions: 0,
          action_owner_due: 0,
          action_status: 0,
          verification_method: 0,
          acceptance_criteria: 0,
          test_plan_reference: 0
        }
      });
    }

    const tests = sections.map((section, idx) => {
      const data = {
        section_title: section.title,
        section_no: section.id,
        section_type: section.type,
        param1_label: "",
        param1_value: "",
        param2_label: "",
        param2_value: ""
      };

      const fieldLabels = {
        section_title: "Section Title",
        section_no: "Section ID",
        section_type: "Section Type",
        param1_label: "Param 1 Label",
        param1_value: "Param 1 Value",
        param2_label: "Param 2 Label",
        param2_value: "Param 2 Value"
      };

      const fieldTypes = {
        section_title: "text",
        section_no: "text",
        section_type: "text",
        param1_label: "text",
        param1_value: "text",
        param2_label: "text",
        param2_value: "text"
      };

      const fieldOptions = {};
      const fieldPrompts = {
        section_title: "Enter the section title for this FMEA document.",
        section_no: "Enter the section identifier (e.g., FMEA-003).",
        section_type: "Describe the section type or category.",
        param1_label: "Enter a label for parameter 1 (optional).",
        param1_value: "Select which field should supply parameter 1's value.",
        param2_label: "Enter a label for parameter 2 (optional).",
        param2_value: "Select which field should supply parameter 2's value."
      };

      for(const f of section.fields){
        data[f.key] = f.value != null ? f.value : "";
        fieldLabels[f.key] = f.label;
        fieldTypes[f.key] = f.type;
        if(["severity","occurrence","detection"].includes(f.key)){
          fieldOptions[f.key] = scaleOptions;
          fieldPrompts[f.key] = "Select a value from 1–10.";
        }else if(f.key === "rpn"){
          fieldPrompts[f.key] = "Auto-computed from Severity × Occurrence × Detection.";
        }else{
          fieldPrompts[f.key] = `Provide the ${f.label.toLowerCase()} for this failure mode.`;
        }
      }

      const normalized = normalizeTestData(data);
      normalized._ai.field_labels = fieldLabels;
      normalized._ai.field_types = fieldTypes;
      normalized._ai.field_prompts = fieldPrompts;
      normalized._ai.field_options = fieldOptions;
      normalized._ai.maturity = { ...(normalized._ai.maturity || {}) };
      const maturityOverrides = section.maturity || {};
      for(const key of Object.keys(data)){
        if(key === "_ai") continue;
        if(Object.prototype.hasOwnProperty.call(maturityOverrides, key)){
          normalized._ai.maturity[key] = maturityOverrides[key];
          continue;
        }
        if(String(data[key] ?? "").trim() !== "") normalized._ai.maturity[key] = 3;
      }
      normalized._ai.review_personalities = buildSeedReviewPersonalitiesForData(normalized);
      return { id: uid(), order: idx + 1, modified: false, data: normalized };
    });

    const plan = {
      id: uid(),
      name: "FMEA",
      slug: slugifyPlanName("FMEA"),
      created: nowIsoDate(),
      updated: nowIsoDate(),
      goal: "Identify and mitigate potential failure modes and their effects.",
      scope: "Capture failure modes, causes, effects, and mitigations with severity, occurrence, and detection scoring.",
      ai_review_guidance: "Concise, risk-focused, and technical. Use FMEA terminology and avoid vague language.",
      review_personalities: getPlanReviewPersonas(null),
      ai_prompts: {
        review_persona: "You are a {{personaLabel}}. Provide a concise review comment for this section focused on {{focus}}. Use field_prompt as gospel guidance and follow it exactly. Return ONLY the comment text.{{guidanceLine}}",
        review_field: "Return ONLY the section field value text. No extra words, no markdown. Use field_prompt and field_label as guidance. Use authoritative_values to keep consistency across sections. Use context_files (if provided) as source material. If maturity <= 2, improve and rewrite the value even if current_value is already filled. If current_value is empty, generate a concise, professional value based on the field_prompt/label. Do NOT repeat TODO or Auto-filled text; replace it with improved content even if brief.{{guidanceLine}}",
        chat_edit: "You edit an FMEA document. Permission level: {{permLabel}} ({{perm}}). Respond with strict JSON using these keys: message (string), plan (optional with name/goal/scope), tests (optional array of sections as {section_no?, set:{field:value}, delete?:true}), delete_all (optional boolean), delete_tests (optional array of section_no). Use schema field keys for set. You may update multiple fields in a single section by including all desired keys inside set. To fully update a section, include all relevant schema keys in set. If permission is Search/Find, do not include plan or tests; respond with message only. If permission is Create/Delete, you may add a new section by including a tests entry with a new section_no or by omitting section_no (the app will assign the next number), and you may request deletions via delete_all/delete_tests or delete:true. Use context_files (if provided) as source material.",
        create_plan: "Return STRICT JSON: {\"document\":{\"goal\":\"\",\"scope\":\"\"},\"items\":[{\"item_no\":\"FMEA-003\",\"item_name\":\"...\",\"set\":{...}}, ...]}. Provide exactly {{testCount}} sections for an FMEA document. The set object should use full schema keys: {{schemaKeys}}. Use standard FMEA terminology. No extra text.",
        suggest_field: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique) and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this FMEA section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_field_strict: "Respond with strict JSON with keys value and rationale. The value must be a rewritten replacement (not a critique), must be meaningfully different from the current value, and MUST be a plain string (no objects, no arrays). Use field_prompt as guidance and follow ai_review_guidance style/tone/vibe. Use field_label for context for this FMEA section. If current_value contains TODO or Auto-filled text, replace it with improved content.",
        suggest_limits_note: DEFAULT_AI_PROMPTS.suggest_limits_note
      },
      tests,
      markdown: "",
      userNotes: "Add scope details, assumptions, and review notes here."
    };

    generatePlanMarkdown(plan);
    await Store.savePlan(plan);
    logLine("Seeded FMEA.", "ok");
    toast("Seeded", "FMEA created.", "ok");
    runAsync(renderLibrary());
  }

  /* ---------- Tabs ---------- */
  function setupTabs(){
    document.querySelectorAll(".tab").forEach(tab => {
      tab.addEventListener("click", () => {
        document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        const id = tab.getAttribute("data-tab");
        document.querySelectorAll(".tabContent").forEach(c => c.classList.remove("active"));
        $(`tab-${id}`).classList.add("active");
      });
    });
  }

  /* ---------- Menu (simple) ---------- */
  function openMenu(title, items){
    showModal(title, (body, footer) => {
      body.innerHTML = items.map(it => `
        <div class="item" style="cursor:pointer;" data-id="${escapeHtml(it.id)}">
          <div class="left">
            <div class="name">${escapeHtml(it.title)}</div>
            <div class="meta"><span class="tag">${escapeHtml(it.desc || "")}</span></div>
          </div>
          <div class="actions"><span class="tag">Click</span></div>
        </div>
      `).join("");

      body.querySelectorAll(".item[data-id]").forEach(row => {
        row.addEventListener("click", () => {
          const id = row.getAttribute("data-id");
          hideModal();
          const it = items.find(x => x.id === id);
          if(it && typeof it.onClick === "function") it.onClick();
        });
      });

      footer.innerHTML = `<button class="btn" id="closeMenu">Close</button>`;
      $("closeMenu").onclick = hideModal;
    });
  }

  /* ---------- Flow pan/zoom ---------- */
  function setupFlowPanZoom(){
    const svg = $("flowSvg");
    if(!svg) return;
    let panning = false;
    let startX = 0;
    let startY = 0;
    let originX = 0;
    let originY = 0;

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const getSvgPoint = (evt) => {
      const pt = svg.createSVGPoint();
      pt.x = evt.clientX;
      pt.y = evt.clientY;
      const ctm = svg.getScreenCTM();
      return ctm ? pt.matrixTransform(ctm.inverse()) : { x: evt.clientX, y: evt.clientY };
    };

    svg.addEventListener("pointerdown", (e) => {
      if(e.button !== 0) return;
      panning = true;
      svg.classList.add("dragging");
      startX = e.clientX;
      startY = e.clientY;
      originX = state.flow.x;
      originY = state.flow.y;
      svg.setPointerCapture(e.pointerId);
    });

    svg.addEventListener("pointermove", (e) => {
      if(!panning) return;
      const dx = (e.clientX - startX) / state.flow.scale;
      const dy = (e.clientY - startY) / state.flow.scale;
      state.flow.x = originX + dx;
      state.flow.y = originY + dy;
      applyFlowTransform();
    });

    svg.addEventListener("pointerup", (e) => {
      if(!panning) return;
      panning = false;
      svg.classList.remove("dragging");
      svg.releasePointerCapture(e.pointerId);
    });

    svg.addEventListener("pointerleave", () => {
      if(!panning) return;
      panning = false;
      svg.classList.remove("dragging");
    });

    svg.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 1.12 : 0.9;
      const current = state.flow.scale;
      const next = clamp(current * delta, 0.4, 2.5);
      if(next === current) return;
      const p = getSvgPoint(e);
      state.flow.x = p.x - (p.x - state.flow.x) * (next / current);
      state.flow.y = p.y - (p.y - state.flow.y) * (next / current);
      state.flow.scale = next;
      applyFlowTransform();
    }, { passive: false });

    svg.addEventListener("dblclick", () => {
      state.flow.x = 0;
      state.flow.y = 0;
      state.flow.scale = 1;
      applyFlowTransform();
    });
  }

  /* ---------- Wiring ---------- */
  function wire(){
    setupTabs();
    setupFlowPanZoom();

    $("btnNewPlan").addEventListener("click", createNewPlanFlow);
    $("btnPrefs").addEventListener("click", openPreferences);
    $("planSearch").addEventListener("input", () => runAsync(renderLibrary()));

    // Import/Export removed
    // Wipe removed
    $("btnSeedDemo").addEventListener("click", () => runAsync(seedDemo()));
    $("btnSeedSpec").addEventListener("click", () => runAsync(seedSpecificationsDocument()));
    $("btnSeedRtm").addEventListener("click", () => runAsync(seedRequirementsTraceabilityMatrix()));
    $("btnSeedBom").addEventListener("click", () => runAsync(seedBillOfMaterials()));
    $("btnSeedVerify").addEventListener("click", () => runAsync(seedVerificationMatrix()));
    $("btnSeedDesignReview").addEventListener("click", () => runAsync(seedDesignReviewChecklist()));
    $("btnSeedIcd").addEventListener("click", () => runAsync(seedInterfaceControlDocument()));
    $("btnSeedFmea").addEventListener("click", () => runAsync(seedFmea()));
    $("btnSeedEmc").addEventListener("click", () => runAsync(seedEmcCompliancePlan()));
    // Library details toggle removed

    $("switchPlanBtn").addEventListener("click", () => {
      const dirty = state.currentPlan?.tests?.some(t => t.modified);
      if(dirty && !confirm("You have unsaved changes. Switch documents anyway?")) return;
      showLibrary();
    });

    $("saveAllBtn").addEventListener("click", () => runAsync(saveAll()));

    $("testSearch").addEventListener("input", renderTestsList);
    document.addEventListener("click", hideContextMenu);
    document.addEventListener("scroll", hideContextMenu, true);
    $("btnNewTest").addEventListener("click", () => {
      if(state.currentTestTemplate && state.templateEditReturnPlanId){
        runAsync(openPlanById(state.templateEditReturnPlanId));
      }else{
        runAsync(newTest());
      }
    });
    $("btnManageTestTemplates").addEventListener("click", () => runAsync(openManageTestTemplates()));
    const delBtn = $("btnDeleteTest");
    if(delBtn) delBtn.addEventListener("click", deleteCurrentTest);
    $("btnAiSuggest").addEventListener("click", aiSuggestFocusedField);
    const appTitle = $("appTitle");
    if(appTitle) appTitle.addEventListener("click", showLibrary);

    const btnNormalize = $("btnNormalize");
    if(btnNormalize) btnNormalize.addEventListener("click", normalizeCurrentTest);
    $("btnShowJson").addEventListener("click", showCurrentJsonModal);

    $("btnAiReviewPlan").addEventListener("click", () => {
      if(!state.currentPlan) return;
      runAsync(aiReviewPlan(state.currentPlan.id));
    });
    const pauseReviewBtn = $("btnAiReviewPause");
    if(pauseReviewBtn) pauseReviewBtn.addEventListener("click", () => {
      if(!state.aiReviewControl?.running) return;
      state.aiReviewControl.paused = !state.aiReviewControl.paused;
      updateAiReviewControls();
      logLine(`AI Review: ${state.aiReviewControl.paused ? "paused" : "resumed"}.`, "warn");
    });
    const cancelReviewBtn = $("btnAiReviewCancel");
    if(cancelReviewBtn) cancelReviewBtn.addEventListener("click", () => {
      if(!state.aiReviewControl?.running) return;
      state.aiReviewControl.cancelled = true;
      updateAiReviewControls();
      logLine("AI Review: cancel requested.", "warn");
    });
    const fitBtn = $("btnFitFlow");
    if(fitBtn) fitBtn.addEventListener("click", fitFlowToView);
    const applyBtn = $("btnApplyNotes");
    if(applyBtn) applyBtn.addEventListener("click", () => runAsync(applyNotes()));
    const regenBtn = $("btnRegenerateMd");
    if(regenBtn) regenBtn.addEventListener("click", () => runAsync(regenerateMd()));
    const dlBtn = $("btnDownloadMd");
    if(dlBtn) dlBtn.addEventListener("click", downloadMd);

    const chatSend = $("btnAiChatSend");
    if(chatSend) chatSend.addEventListener("click", () => runAsync(aiChatSend()));
    const chatClear = $("btnAiChatClear");
    if(chatClear) chatClear.addEventListener("click", () => { const log = $("aiChatLog"); if(log) log.innerHTML = ""; });
    const chatInput = $("aiChatInput");
    if(chatInput){
      chatInput.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const items = [
          {
            id: "load_file",
            label: "Load File",
            onClick: () => openAiChatFilePicker()
          }
        ];
        showContextMenu(e.clientX, e.clientY, items);
      });
      chatInput.addEventListener("keydown", (e) => {
        if(e.key === "Enter" && (e.ctrlKey || e.metaKey)){
          e.preventDefault();
          runAsync(aiChatSend());
        }
      });
    }
    const permSlider = $("aiPermSlider");
    if(permSlider){
      permSlider.addEventListener("input", () => {
        const val = normalizeAiChatPermission(permSlider.value);
        const label = $("aiPermLabel");
        if(label) label.textContent = aiChatPermissionLabel(val);
      });
      permSlider.addEventListener("change", () => {
        const val = normalizeAiChatPermission(permSlider.value);
        state.prefs.ai_chat_permission = val;
        savePrefs();
        const label = $("aiPermLabel");
        if(label) label.textContent = aiChatPermissionLabel(val);
        logLine(`AI Permission set to ${aiChatPermissionLabel(val)}.`, "ok");
      });
    }
    const planBadgeName = $("planBadgeName");
    if(planBadgeName) planBadgeName.addEventListener("click", showMarkdownModal);

    $("btnCopyLog").addEventListener("click", async () => {
      const lines = [...$("log").querySelectorAll(".line")].map(x => x.textContent);
      try{
        await navigator.clipboard.writeText(lines.join("\n"));
        toast("Log copied", "Copied to clipboard.", "ok");
      }catch{
        toast("Copy failed", "Clipboard permission denied.", "warn");
      }
    });
    $("btnClearLog").addEventListener("click", () => $("log").innerHTML = "");

    const modalClose = $("modalClose");
    if(modalClose) modalClose.addEventListener("click", hideModal);
    $("modalOverlay").addEventListener("click", (e) => {
      if(e.target === $("modalOverlay")) hideModal();
    });
    $("aiChip").addEventListener("click", openPreferences);

    // Top menus removed (small UI)
    document.addEventListener("keydown", (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
      if(e.code === "Space" && tag !== "input" && tag !== "textarea" && tag !== "select"){
        state.matrixPanKey = true;
      }
      if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s"){
        e.preventDefault();
        runAsync(saveAll());
      }
    });
    document.addEventListener("keyup", (e) => {
      if(e.code === "Space") state.matrixPanKey = false;
    });
  }

  function openPersonalityDialog(test, fieldKey){
    if(!test || !fieldKey) return;
    if(!test.data._ai) test.data._ai = ensureAiMeta(null, Object.keys(test.data).filter(k => k !== "_ai"));
    const personas = mergeReviewPersonalities(
      buildDefaultReviewPersonalities(Object.keys(test.data).filter(k => k !== "_ai"), getPlanReviewPersonas(state.currentPlan)),
      test.data._ai.review_personalities || {},
      Object.keys(test.data).filter(k => k !== "_ai"),
      getPlanReviewPersonas(state.currentPlan)
    );
    const label = test.data?._ai?.field_labels?.[fieldKey] || fieldKey;
    showModal("Field Reviews", (body, footer) => {
      const blocks = Object.keys(personas).map(id => {
        const p = personas[id] || { label: id, field_comments: {} };
        const comment = p.field_comments?.[fieldKey] || "";
        const safeLabel = escapeHtml(p.label || id);
        const safeComment = escapeHtml(comment);
        return `
          <div class="label">${safeLabel}</div>
          <textarea class="input" rows="3" readonly>${safeComment}</textarea>
        `;
      }).join("");
      body.innerHTML = `
        <div class="label">Field</div>
        <div class="input" style="display:flex;align-items:center;">${escapeHtml(label)}</div>
        <div class="hr"></div>
        ${blocks}
      `;
      footer.innerHTML = `<button class="btn" id="closePersonaDialog">Close</button>`;
      $("closePersonaDialog").onclick = hideModal;
    });
  }

  function getAiReviewGuidance(){
    return new Promise(resolve => {
      showModal("AI Review Guidance", (body, footer) => {
        const plan = state.currentPlan;
        const current = plan?.ai_review_guidance || "";
        body.innerHTML = `
          <div class="label">Style / Tone / Vibe</div>
          <textarea class="input" id="aiReviewGuidance" rows="4" spellcheck="false" placeholder="e.g., concise, formal, risk-focused, manufacturing-ready...">${escapeHtml(current)}</textarea>
          <div class="hint">Optional. This guidance is applied to AI Review output and personality comments.</div>
        `;
        footer.innerHTML = `
          <button class="btn" id="cancelGuidance">Skip</button>
          <button class="btn primary" id="confirmGuidance">Use Guidance</button>
        `;
        $("cancelGuidance").onclick = () => { hideModal(); resolve(current || ""); };
        $("confirmGuidance").onclick = () => {
          const val = $("aiReviewGuidance").value.trim();
          if(plan){
            plan.ai_review_guidance = val;
          }
          hideModal();
          resolve(val);
        };
        setTimeout(() => $("aiReviewGuidance").focus(), 20);
      });
    });
  }

  function showAiCreateProgress(etaText){
    let seconds = 0;
    showModal("AI Create in Progress", (body, footer) => {
      body.innerHTML = `
        <div class="label">Estimated Time</div>
        <div class="input" id="aiCreateEta" style="display:flex;align-items:center;">${escapeHtml(etaText || "Calculating…")}</div>
        <div class="label" style="margin-top:10px;">Elapsed</div>
        <div class="input" id="aiCreateTimer" style="display:flex;align-items:center;">00:00</div>
      `;
      footer.innerHTML = `<button class="btn" id="aiCreateClose" disabled>Working…</button>`;
    });
    const timerId = setInterval(() => {
      seconds += 1;
      const mm = String(Math.floor(seconds / 60)).padStart(2, "0");
      const ss = String(seconds % 60).padStart(2, "0");
      const el = $("aiCreateTimer");
      if(el) el.textContent = `${mm}:${ss}`;
    }, 1000);
    return {
      setEta(text){
        const el = $("aiCreateEta");
        if(el) el.textContent = text || "Calculating…";
      },
      close(){
        clearInterval(timerId);
        hideModal();
      }
    };
  }

  /* ---------- Init ---------- */
  function init(){
    wire();
    showLibrary();
    updatePlanRootUI();
    updateAiBadge();
    const splash = $("splashScreen");
    const splashFolder = $("splashFolder");
    if(splash){
      const hideSplash = () => {
        splash.style.display = "none";
      };
      splash.style.display = "flex";
      if(splashFolder) splashFolder.style.display = "none";
      const closeBtn = $("splashClose");
      const startBtn = $("splashStart");
      if(closeBtn) closeBtn.onclick = hideSplash;
      if(startBtn) startBtn.onclick = () => {
        hideSplash();
        if(splashFolder) splashFolder.style.display = "flex";
      };
      if(splashFolder){
        const closeFolderBtn = $("splashFolderClose");
        const doneFolderBtn = $("splashFolderDone");
        const prefsFolderBtn = $("splashFolderPrefs");
        const hideFolder = () => { splashFolder.style.display = "none"; };
        if(closeFolderBtn) closeFolderBtn.onclick = hideFolder;
        if(doneFolderBtn) doneFolderBtn.onclick = hideFolder;
        if(prefsFolderBtn) prefsFolderBtn.onclick = () => {
          hideFolder();
          openPreferences();
        };
      }
    }
    loadPlanRoot().then(() => {
      updatePlanRootUI();
      runAsync(renderLibrary());
      promptPlanRootIfNeeded();
    });
    logLine("Test Base 2026 loaded.", "ok");
  }

  init();
})();
</script>
</body>
</html>








