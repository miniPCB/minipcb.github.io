<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Engineering Analyzer</title>
   <style>
     :root {
       --bg: #0e1118;
       --panel: #151b25;
       --panel-2: #1b2330;
       --text: #e8edf5;
       --muted: #98a7bb;
       --accent: #2f88ff;
       --accent-2: #37c3ff;
       --border: #2d3a4d;
       --ok: #2ecc71;
       --warn: #f1c40f;
       --bad: #ff5757;
       --shadow: 0 8px 28px rgba(0, 0, 0, 0.35);
       --mono: "Consolas", "Courier New", monospace;
       --sans: "Segoe UI", "Trebuchet MS", sans-serif;
     }

     * { box-sizing: border-box; }

     body {
       margin: 0;
       font-family: var(--sans);
       color: var(--text);
       background:
         radial-gradient(circle at 20% 0%, #1b2434 0%, transparent 50%),
         radial-gradient(circle at 90% 100%, #132036 0%, transparent 45%),
         var(--bg);
       min-height: 100vh;
     }

     .page {
       width: min(1920px, calc(100vw - 24px));
       max-width: none;
       margin: 0 auto;
       padding: 20px;
     }

    .title {
      margin: 0 0 16px;
      font-size: 1.45rem;
      letter-spacing: 0.02em;
    }

    .tabbar {
      display: grid;
      grid-template-columns: repeat(5, minmax(150px, 1fr));
      gap: 8px;
      margin-bottom: 12px;
    }

    .tab-button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #131b27;
      color: var(--text);
      padding: 10px;
      text-align: left;
      min-height: 62px;
      cursor: pointer;
    }

    .tab-button .tab-title {
      display: block;
      font-size: 0.82rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
      margin-bottom: 3px;
    }

    .tab-button .tab-state {
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--muted);
    }

    .tab-button.active {
      border-color: var(--accent);
      background: linear-gradient(180deg, #1b2a3f, #141e2d);
      box-shadow: inset 0 0 0 1px rgba(47, 136, 255, 0.2);
    }

    .tab-button.state-ready .tab-state { color: var(--warn); }
    .tab-button.state-done .tab-state { color: var(--ok); }
    .tab-button.state-locked { opacity: 0.65; cursor: not-allowed; }

    .tab-panel {
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 12px;
      margin-bottom: 12px;
    }

    .tab-panel.hidden { display: none; }

    .control-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }

    .control-group {
      display: grid;
      gap: 6px;
      align-content: start;
    }

    .control-label {
      font-size: 0.78rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      padding-left: 2px;
    }

    .inline-option {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      align-items: center;
    }

    .inline-option input[type="number"] {
      border: 1px solid var(--border);
      background: #1e2837;
      color: var(--text);
      border-radius: 8px;
      min-height: 42px;
      padding: 0 10px;
      width: 100%;
    }

    .checkline {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 0.82rem;
      padding-left: 2px;
    }

    .fmea-assumptions {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #121a25;
      padding: 10px;
    }

    #panelSetup {
      border: 0;
      background: transparent;
      box-shadow: none;
      padding: 0;
    }

    #panelSetup .fmea-assumptions {
      margin-top: 0;
      border: 0;
      border-radius: 0;
      background: transparent;
      padding: 0;
    }

    .setup-stage-tabs {
      display: grid;
      grid-template-columns: repeat(4, minmax(170px, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }

    .setup-stage-button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #131b27;
      color: var(--text);
      padding: 10px;
      text-align: left;
      min-height: 52px;
      cursor: pointer;
      font-size: 0.86rem;
      font-weight: 700;
      letter-spacing: 0.01em;
    }

    .setup-stage-button.active {
      border-color: var(--accent);
      background: linear-gradient(180deg, #1b2a3f, #141e2d);
      box-shadow: inset 0 0 0 1px rgba(47, 136, 255, 0.2);
    }

    .setup-stage-button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .setup-stage-panel {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #101823;
      padding: 10px;
      width: 100%;
    }

    .setup-stage-panel.hidden { display: none; }

    .fmea-assumptions h3 {
      margin: 0 0 8px;
      font-size: 0.96rem;
    }

    .assumption-note {
      margin: 0 0 10px;
      color: var(--muted);
      font-size: 0.84rem;
    }

    .assumption-table textarea {
      width: 100%;
      min-height: 72px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #1a2332;
      color: var(--text);
      padding: 7px 8px;
      font-family: var(--mono);
      font-size: 0.79rem;
      resize: vertical;
     }

    .lookup-pill-board {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 10px;
      padding: 2px;
    }

    .lookup-pill-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #101823;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .lookup-type-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.8rem;
      font-weight: 700;
      width: fit-content;
      border: 1px solid rgba(102,163,255,.45);
      color: #c6e3ff;
      background: rgba(102,163,255,.18);
    }

    .lookup-mode-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-content: flex-start;
      min-height: 34px;
    }

    .lookup-mode-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      border: 1px solid rgba(123,220,181,.45);
      color: #c8ffe2;
      background: rgba(123,220,181,.15);
      line-height: 1.2;
    }

    .lookup-edit-label {
      color: var(--muted);
      font-size: 0.76rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    .detail-grid select,
    .detail-grid textarea {
      width: 100%;
    }

    .detail-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .drill-layout {
      display: grid;
      grid-template-columns: minmax(260px, 34%) minmax(420px, 66%);
      gap: 10px;
      margin-bottom: 10px;
      align-items: start;
    }

    .drill-col {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0f1824;
      padding: 10px;
      min-height: 220px;
    }

    .drill-col .control-label { margin-bottom: 8px; display: block; }

    .pill-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-content: flex-start;
      max-height: 44vh;
      overflow: auto;
      padding-right: 2px;
    }

    .drill-pill {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 5px 11px;
      font-size: 0.8rem;
      line-height: 1.25;
      color: var(--text);
      background: #1a2638;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }

    .drill-pill.active {
      outline: 2px solid rgba(255, 255, 255, 0.85);
      outline-offset: 1px;
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.65),
        0 0 0 2px rgba(47, 136, 255, 0.55),
        0 0 18px rgba(47, 136, 255, 0.45);
      transform: translateY(-1px) scale(1.03);
      font-weight: 700;
    }

    .drill-detail-grid {
      margin-top: 10px;
      display: grid;
      gap: 8px;
    }

    .detail-pill {
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 9px 11px;
      min-height: 56px;
      color: var(--text);
      background: rgba(67, 118, 198, 0.17);
    }

    .detail-pill[data-field="description"] { background: rgba(67, 118, 198, 0.2); border-color: rgba(89, 158, 255, 0.55); }
    .detail-pill[data-field="l1"] { background: rgba(60, 164, 114, 0.2); border-color: rgba(85, 221, 156, 0.55); }
    .detail-pill[data-field="l2"] { background: rgba(180, 126, 52, 0.22); border-color: rgba(255, 199, 111, 0.55); }
    .detail-pill.disabled { opacity: 0.55; }

    .detail-pill .pill-title {
      display: block;
      font-size: 0.75rem;
      color: rgba(235, 242, 251, 0.8);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 6px;
      font-weight: 700;
    }

    .detail-pill .pill-text {
      outline: none;
      min-height: 22px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .saved-table button {
      min-height: 30px;
      padding: 0 8px;
      font-size: 0.8rem;
    }

    .results-action-btn {
      min-height: 30px;
      height: 30px;
      padding: 0 10px;
      font-size: 0.78rem;
      border-radius: 999px;
      line-height: 1;
      width: auto;
      justify-self: start;
    }

    .results-actions {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .results-subtabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }

    .results-subtab {
      min-height: 32px;
      height: 32px;
      padding: 0 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      background: #132033;
      border: 1px solid var(--border);
    }

    .results-subtab.active {
      border-color: rgba(102, 163, 255, 0.7);
      background: rgba(102, 163, 255, 0.2);
      color: #d9ebff;
      box-shadow: inset 0 0 0 1px rgba(102,163,255,0.28);
    }

    .results-subpanel.hidden { display: none; }

    .review-board {
      display: grid;
      gap: 10px;
    }

    .review-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #101823;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .review-pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .review-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      border: 1px solid var(--border);
      background: #1a2638;
      color: var(--text);
      line-height: 1.2;
    }

    .review-pill.ref { border-color: rgba(102,163,255,.45); color: #c6e3ff; background: rgba(102,163,255,.18); }
    .review-pill.type { border-color: rgba(123,220,181,.45); color: #c8ffe2; background: rgba(123,220,181,.15); }
    .review-pill.mode { border-color: rgba(255,211,124,.45); color: #ffeec3; background: rgba(255,211,124,.15); }
    .review-pill.net { border-color: rgba(206,160,255,.45); color: #f0deff; background: rgba(206,160,255,.15); }
    .review-pill.aff { border-color: rgba(255,123,123,.45); color: #ffd6d6; background: rgba(255,123,123,.15); }

    .review-text-block {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #0f1928;
      padding: 8px;
    }

    .review-text-block .k {
      color: var(--muted);
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 4px;
      display: block;
    }

    .review-list {
      margin: 0;
      padding-left: 18px;
      color: var(--text);
      font-size: 0.84rem;
    }

    .assumption-board {
      display: grid;
      gap: 10px;
      padding: 10px;
    }

    .assumption-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #101823;
      padding: 10px;
    }

    .assumption-card-head {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .assumption-chip {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 3px 9px;
      font-size: 0.78rem;
      border: 1px solid var(--border);
      background: #1a2638;
      color: var(--text);
    }

    .assumption-chip.ref { border-color: rgba(102,163,255,.45); color: #c6e3ff; background: rgba(102,163,255,.18); }
    .assumption-chip.type { border-color: rgba(123,220,181,.45); color: #c8ffe2; background: rgba(123,220,181,.15); }
    .assumption-chip.src { border-color: rgba(255,211,124,.45); color: #ffeec3; background: rgba(255,211,124,.15); }

    .bucket-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .bucket {
      border: 1px dashed var(--border);
      border-radius: 10px;
      min-height: 82px;
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-content: flex-start;
      transition: border-color .15s ease, background .15s ease;
    }

    .bucket h4 {
      margin: 0 0 5px;
      width: 100%;
      font-size: 0.8rem;
      color: var(--muted);
      font-weight: 600;
    }

    .bucket.run {
      background: rgba(46,204,113,0.08);
      border-color: rgba(46,204,113,0.45);
    }

    .bucket.skip {
      background: rgba(255,87,87,0.08);
      border-color: rgba(255,87,87,0.45);
    }

    .bucket.drag-over {
      border-style: solid;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.18);
    }

    .mode-pill {
      border: 1px solid rgba(46,204,113,.5);
      color: #d6ffe8;
      background: rgba(46,204,113,.2);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      line-height: 1.2;
      cursor: grab;
      user-select: none;
    }

    .mode-pill.skip {
      border-color: rgba(255,87,87,.5);
      color: #ffd8d8;
      background: rgba(255,87,87,.2);
    }

    .mode-pill:active { cursor: grabbing; }

     button,
     select {
       border: 1px solid var(--border);
       background: #1e2837;
       color: var(--text);
       border-radius: 8px;
       min-height: 42px;
       padding: 0 12px;
       font-size: 0.95rem;
       cursor: pointer;
     }

     button:hover, select:hover { border-color: #496287; }
     button:disabled { opacity: 0.5; cursor: not-allowed; }

     .content {
       display: grid;
       grid-template-columns: minmax(320px, 38%) minmax(420px, 62%);
       gap: 12px;
       align-items: start;
     }

     .panel {
       border: 1px solid var(--border);
       background: var(--panel);
       border-radius: 12px;
       box-shadow: var(--shadow);
       overflow: hidden;
     }

     .panel h2 {
       margin: 0;
       padding: 10px 12px;
       font-size: 1rem;
       border-bottom: 1px solid var(--border);
       background: #1a2230;
     }

     .panel-body { padding: 10px; }

     details {
       border: 1px solid var(--border);
       border-radius: 8px;
       margin-bottom: 10px;
       overflow: hidden;
       background: #121a25;
     }

     summary {
       cursor: pointer;
       padding: 10px 12px;
       user-select: none;
       font-weight: 600;
       background: #182231;
     }

    pre {
      margin: 0;
      padding: 10px;
      white-space: pre;
      overflow: auto;
       max-height: 320px;
       font-size: 0.8rem;
       font-family: var(--mono);
       background: #0f151f;
      border-top: 1px solid var(--border);
    }

    .jsonViewport{
      border-top: 1px solid var(--border);
      background: rgba(15,20,30,0.45);
      overflow:auto;
      min-height:220px;
      max-height:360px;
      padding:10px;
      border-radius:0 0 8px 8px;
    }

    .jsonStatus{
      color: var(--muted);
      font-size: 0.84rem;
      display: flex;
      align-items: center;
    }

    .jsonTree{
      display:flex;
      flex-direction:column;
      gap:8px;
      font-family: var(--mono);
      font-size:12px;
    }

    .jsonEntry{
      display:flex;
      align-items:flex-start;
      gap:6px;
      flex-wrap:wrap;
    }

    .jsonChild{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-left:10px;
      border-left:1px dashed rgba(102,163,255,0.3);
      padding-left:10px;
      min-width:0;
      flex:1;
    }

    .jsonBubble{
      display:inline-flex;
      align-items:center;
      border-radius:999px;
      padding:3px 9px;
      line-height:1.2;
      max-width:100%;
      word-break:break-word;
      white-space:normal;
    }

    .jsonKeyBubble{
      background: rgba(102,163,255,0.18);
      border:1px solid rgba(102,163,255,0.45);
      color: #c6e3ff;
      font-weight:600;
    }

    .jsonValBubble{
      background: rgba(123,220,181,0.15);
      border:1px solid rgba(123,220,181,0.45);
      color: #c8ffe2;
    }

    .jsonValBubble.type-number{
      background: rgba(255,211,124,0.15);
      border-color: rgba(255,211,124,0.45);
      color: #ffeec3;
    }

    .jsonValBubble.type-boolean{
      background: rgba(206,160,255,0.15);
      border-color: rgba(206,160,255,0.45);
      color: #f0deff;
    }

    .jsonValBubble.type-null{
      background: rgba(255,123,123,0.15);
      border-color: rgba(255,123,123,0.45);
      color: #ffd6d6;
    }

    .jsonValBubble.type-object{
      background: rgba(111,181,255,0.15);
      border-color: rgba(111,181,255,0.45);
      color: #d8ebff;
    }

     .table-wrap {
       overflow: auto;
       border: 1px solid var(--border);
       border-radius: 8px;
       max-height: 330px;
       margin-bottom: 10px;
      }

     /* Stage 3 should feel like a dedicated work area: about one full screen, slightly more. */
     #setupStagePanelComponents .table-wrap {
       height: 95vh;
       max-height: 95vh;
     }

     #setupStagePanelAssumptions .table-wrap {
       height: 95vh;
       max-height: 95vh;
     }

     .context-menu {
       position: fixed;
       z-index: 1000;
       min-width: 210px;
       border: 1px solid var(--border);
       border-radius: 10px;
       background: #0f1824;
       box-shadow: var(--shadow);
       padding: 6px;
     }

     .context-menu button {
       width: 100%;
       text-align: left;
       min-height: 34px;
       border-radius: 8px;
       background: transparent;
       border: 1px solid transparent;
       font-size: 0.84rem;
     }

     .context-menu button:hover {
       border-color: #496287;
       background: #152132;
     }

     table {
       width: 100%;
       border-collapse: collapse;
       font-size: 0.86rem;
     }

     th, td {
       padding: 8px 9px;
       border-bottom: 1px solid #283447;
       text-align: left;
       vertical-align: top;
     }

     th {
       position: sticky;
       top: 0;
       background: #1a2535;
       cursor: pointer;
       white-space: nowrap;
     }

     tr:hover td { background: #152132; }

     .summary-grid {
       display: grid;
       grid-template-columns: repeat(3, minmax(120px, 1fr));
       gap: 10px;
     }

     .metric {
       border: 1px solid var(--border);
       border-radius: 8px;
       background: #121c2a;
       padding: 8px 10px;
     }

     .metric .k {
       display: block;
       color: var(--muted);
       font-size: 0.76rem;
       margin-bottom: 4px;
     }

     .metric .v {
       font-weight: 700;
       font-size: 1.05rem;
     }

     .status-ok { color: var(--ok); font-weight: 700; }
     .status-warn { color: var(--warn); font-weight: 700; }
     .status-bad { color: var(--bad); font-weight: 700; }
     .muted { color: var(--muted); }

     .hint {
       margin: 0;
       padding: 0 2px 10px;
       font-size: 0.86rem;
       color: var(--muted);
     }

     .hidden { display: none; }

     @media (max-width: 1200px) {
       .tabbar { grid-template-columns: 1fr 1fr; }
       .control-panel { grid-template-columns: 1fr 1fr; }
       .setup-stage-tabs { grid-template-columns: 1fr 1fr; }
     }

     @media (max-width: 860px) {
       .tabbar { grid-template-columns: 1fr; }
       .control-panel { grid-template-columns: 1fr; }
       .setup-stage-tabs { grid-template-columns: 1fr; }
       .drill-layout { grid-template-columns: 1fr; }
       .content { grid-template-columns: 1fr; }
     }
   </style>
</head>
<body>
   <div class="page">
     <h1 class="title">Engineering Analyzer v0.2</h1>

    <section class="tabbar">
      <button id="tabInputsBtn" class="tab-button active state-ready" type="button" data-tab="inputs">
        <span class="tab-title">Load Inputs</span>
        <span id="tabInputsState" class="tab-state">Ready</span>
      </button>
      <button id="tabSetupBtn" class="tab-button state-done" type="button" data-tab="setup">
        <span class="tab-title">Setup Analysis</span>
        <span id="tabSetupState" class="tab-state">Done</span>
      </button>
      <button id="tabRunBtn" class="tab-button state-locked" type="button" data-tab="run" disabled>
        <span class="tab-title">Run Analysis</span>
        <span id="tabRunState" class="tab-state">Locked</span>
      </button>
      <button id="tabResultsBtn" class="tab-button state-locked" type="button" data-tab="results" disabled>
        <span class="tab-title">Review Results</span>
        <span id="tabResultsState" class="tab-state">Locked</span>
      </button>
      <button id="tabSavedBtn" class="tab-button state-ready" type="button" data-tab="saved">
        <span class="tab-title">Saved Analysis</span>
        <span id="tabSavedState" class="tab-state">Ready</span>
      </button>
    </section>

    <section id="panelSetup" class="tab-panel hidden">
      <section id="fmeaAssumptionsSection" class="fmea-assumptions">
        <div class="setup-stage-tabs">
          <button id="setupStageTabType" class="setup-stage-button active" type="button" data-setup-tab="analysis_type">1. Analysis Type</button>
          <button id="setupStageTabAssumptions" class="setup-stage-button" type="button" data-setup-tab="analysis_assumptions">2. Analysis Assumptions</button>
          <button id="setupStageTabComponents" class="setup-stage-button" type="button" data-setup-tab="assumptions_per_component">3. Assumptions per Component</button>
          <button id="setupStageTabDrill" class="setup-stage-button" type="button" data-setup-tab="propagation_drill_down">4. Propagation Drill Down</button>
        </div>
        <p id="fmeaAssumptionsStatus" class="assumption-note">Load inputs to generate component-level assumptions.</p>
        <section id="setupStagePanelType" class="setup-stage-panel">
          <div class="control-panel">
            <div class="control-group">
              <div class="control-label">Analysis Type</div>
              <select id="analysisType" aria-label="Select Analysis Type">
                <option value="fmea">FMEA</option>
                <option value="epsa">EPSA</option>
                <option value="wcca">WCCA</option>
                <option value="coverage">Coverage</option>
              </select>
            </div>
            <div class="control-group">
              <div class="control-label">Setup Actions</div>
              <button id="saveSetupBtn" type="button">Save Setup File</button>
            </div>
          </div>
          <p id="setupSaveStatus" class="hint">Setup files target `json/fmea/setup` when directory access is configured.</p>
        </section>
        <section id="setupStagePanelAssumptions" class="setup-stage-panel hidden">
          <div class="table-wrap assumption-table">
            <div id="fmeaLookupBody" class="lookup-pill-board"></div>
          </div>
        </section>
        <section id="setupStagePanelComponents" class="setup-stage-panel hidden">
          <div class="table-wrap">
            <div id="fmeaGeneratedBoard" class="assumption-board"></div>
          </div>
        </section>
        <section id="setupStagePanelDrill" class="setup-stage-panel hidden">
          <div class="drill-layout">
            <div class="drill-col">
              <span class="control-label">Ref Des Components</span>
              <div id="fmeaDetailComponent" class="pill-cloud"></div>
            </div>
            <div class="drill-col">
              <span class="control-label">Failure Modes</span>
              <div id="fmeaDetailMode" class="pill-cloud"></div>
              <div class="drill-detail-grid">
                <div id="fmeaDetailDescription" class="detail-pill" data-field="description">
                  <span class="pill-title">Failure Mode Description</span>
                  <div class="pill-text" contenteditable="false"></div>
                </div>
                <div id="fmeaDetailL1" class="detail-pill" data-field="l1">
                  <span class="pill-title">Propagation Effects - Level 1</span>
                  <div class="pill-text" contenteditable="false"></div>
                </div>
                <div id="fmeaDetailL2" class="detail-pill" data-field="l2">
                  <span class="pill-title">Propagation Effects - Level 2</span>
                  <div class="pill-text" contenteditable="false"></div>
                </div>
              </div>
            </div>
          </div>
          <div class="detail-actions">
            <button id="fmeaDetailSaveBtn" type="button">Save Mode Detail Override</button>
            <button id="fmeaDetailResetBtn" type="button">Reset Mode Detail to Default</button>
          </div>
        </section>
      </section>
    </section>

    <section id="panelInputs" class="tab-panel">
      <h2>Load Inputs</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Inputs</div>
          <button id="uploadBtn" type="button">Upload Files</button>
          <input id="fileInput" type="file" accept=".json,application/json" multiple class="hidden">
        </div>
      </div>
      <p id="inputStatus" class="hint">Load `netlist.json` (or equivalent schema v1.1 JSON) to enable analysis.</p>
      <details open>
        <summary>Input JSON Viewer</summary>
        <div id="inputViewer" class="jsonViewport jsonStatus">No JSON loaded.</div>
      </details>
      <details>
        <summary>Net Graph Viewer (v0.2 placeholder)</summary>
        <div id="netGraphViewer" class="jsonViewport jsonStatus">Graph output is optional in v0.2. Net adjacency summary will appear here after upload.</div>
      </details>
    </section>

    <section id="panelRun" class="tab-panel hidden">
      <h2>Run Analysis</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Run</div>
          <button id="runBtn" type="button" disabled>Run Analysis</button>
        </div>
      </div>
      <p id="resultStatus" class="hint">Run an analysis to populate deterministic results.</p>
    </section>

    <section id="panelResults" class="tab-panel hidden">
      <div class="control-panel">
        <div class="control-group results-actions">
          <button id="saveResultsBtn" class="results-action-btn" type="button" disabled>Save Results File</button>
          <button id="exportBtn" class="results-action-btn" type="button" disabled>Export Results</button>
        </div>
      </div>
      <div class="results-subtabs">
        <button id="resultsSubtabAffects" class="results-subtab active" type="button">Failure Affects</button>
        <button id="resultsSubtabModes" class="results-subtab" type="button">Failure Modes</button>
        <button id="resultsSubtabTroubleshooting" class="results-subtab" type="button">Troubleshooting</button>
        <button id="resultsSubtabTables" class="results-subtab" type="button">Analysis Tables</button>
      </div>
      <section id="resultsSubpanelAffects" class="results-subpanel">
        <div id="failureAffectsViewer" class="review-board"></div>
      </section>
      <section id="resultsSubpanelModes" class="results-subpanel hidden">
        <div id="failureModesViewer" class="review-board"></div>
      </section>
      <section id="resultsSubpanelTroubleshooting" class="results-subpanel hidden">
        <div id="troubleshootingViewer" class="review-board"></div>
      </section>
      <section id="resultsSubpanelTables" class="results-subpanel hidden">
        <div class="table-wrap">
          <table id="resultsTable">
            <thead><tr id="resultsHead"></tr></thead>
            <tbody id="resultsBody"></tbody>
          </table>
        </div>
        <div id="secondaryWrap" class="table-wrap">
          <table id="secondaryTable">
            <thead><tr id="secondaryHead"></tr></thead>
            <tbody id="secondaryBody"></tbody>
          </table>
        </div>
        <div id="summaryGrid" class="summary-grid"></div>
        <details>
          <summary>Output JSON Viewer</summary>
          <div id="outputViewer" class="jsonViewport jsonStatus">No JSON output yet.</div>
        </details>
      </section>
    </section>

    <section id="panelSaved" class="tab-panel hidden">
      <h2>Saved Analysis</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Directory Access</div>
          <button id="selectFmeaDirBtn" type="button">Select `json/fmea` Folder</button>
          <button id="refreshSavedBtn" type="button">Refresh Saved Files</button>
        </div>
      </div>
      <p id="savedStatus" class="hint">Select the `json/fmea` folder to read/write setup and result files directly. Fallback listing uses `json/fmea/index.json` if present.</p>
      <div class="table-wrap saved-table">
        <table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Location</th>
              <th>Type</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="savedFilesBody"></tbody>
        </table>
      </div>
    </section>
   </div>

   <div id="lookupModeContextMenu" class="context-menu hidden">
     <button type="button" data-lookup-action="duplicate">Duplicate</button>
     <button type="button" data-lookup-action="delete">Delete</button>
     <button type="button" data-lookup-action="insert_before">Insert New Before</button>
     <button type="button" data-lookup-action="insert_after">Insert New After</button>
   </div>

   <script>
     "use strict";

     const ENGINE_VERSION = "0.2";

    // Fixed UI/runtime defaults intentionally replacing removed Setup options:
    // 1) EPSA margin threshold is deterministic at 20%.
    // 2) Secondary results table remains visible by default.
    // If changing these values, update:
    // - `buildSetupPayload()` persisted metadata fields
    // - `runEPSA()` threshold source
    // - `applyFixedUiDefaults()` display behavior
    const FIXED_EPSA_MARGIN_THRESHOLD_PERCENT = 20;
    const FIXED_SHOW_SECONDARY_TABLE = true;

    const state = {
      files: {},
      netlist: null,
      testPlan: null,
      partsLibrary: null,
      toleranceLibrary: null,
      stressRules: null,
      inputsValid: false,
      lastAnalysisType: null,
      lastOutput: null,
      lastMarkdown: "",
      outputsExported: false,
      fmeaDirHandle: null,
      fmeaAssumptionLookup: null,
      fmeaAssumptionOverrides: {},
      fmeaKnowledgeOverrides: {}
    };

    const DEFAULT_FAILURE_MODES_BY_CLASS = Object.freeze({
      resistor: Object.freeze(["open", "short", "oot_high", "oot_low", "drift_high", "drift_low", "noise_excess"]),
      capacitor: Object.freeze(["open", "short", "capacitance_low", "capacitance_high", "esr_high", "leakage_high"]),
      transistor: Object.freeze(["gain_low", "gain_high", "be_short", "ce_short", "open_collector", "open_emitter", "leakage_high"]),
      connector: Object.freeze(["open_contact", "intermittent_contact", "high_contact_resistance", "miswire"]),
      test_point: Object.freeze(["measurement_error", "probe_slip", "open_test_node"]),
      diode: Object.freeze(["open", "short", "leakage_high", "vf_shift"]),
      inductor: Object.freeze(["open", "short", "inductance_low", "inductance_high", "core_saturation"]),
      integrated_circuit: Object.freeze(["pin_open", "pin_short", "pin_short_to_adjecent_pin_up", "pin_short_to_adjecent_pin_down", "latchup", "timing_shift", "output_stuck_high", "output_stuck_low"]),
      switch: Object.freeze(["stuck_open", "stuck_closed", "intermittent_contact", "high_contact_resistance"]),
      fuse: Object.freeze(["nuisance_open", "fail_to_open", "high_resistance"]),
      relay: Object.freeze(["coil_open", "contact_welded", "contact_bounce_excess", "contact_open"]),
      transformer: Object.freeze(["primary_open", "secondary_open", "interwinding_short", "turns_ratio_shift"]),
      crystal: Object.freeze(["start_fail", "freq_shift_high", "freq_shift_low", "high_esr"]),
      sensor: Object.freeze(["offset_shift", "gain_shift", "stuck_output", "open_signal"]),
      other: Object.freeze(["open", "short"])
    });

    const DEFAULT_FAILURE_MODE_KNOWLEDGE = Object.freeze({
      resistor: Object.freeze({
        open: Object.freeze({ description: "Conduction path opens and current flow drops to near zero.", l1: "Direct branch current collapses and node bias shifts.", l2: "Downstream gain/margin can collapse; detection often visible as static offset." }),
        short: Object.freeze({ description: "Terminals effectively short and branch resistance drops strongly.", l1: "Branch current rises and neighboring node voltage compresses.", l2: "Upstream supply loading rises; thermal stress can propagate to adjacent parts." }),
        oot_high: Object.freeze({ description: "Resistance drifts above nominal tolerance band.", l1: "Current reduces and divider/bias point moves low.", l2: "Stage gain and headroom reduce, increasing clipping or under-drive risk." }),
        oot_low: Object.freeze({ description: "Resistance drifts below nominal tolerance band.", l1: "Current increases and divider/bias point moves high.", l2: "Power dissipation rises and later-stage bias can overdrive." })
      }),
      capacitor: Object.freeze({
        open: Object.freeze({ description: "Capacitive coupling/decoupling is lost.", l1: "AC path opens or local filtering is removed.", l2: "Noise and ripple propagation increase into dependent nodes." }),
        short: Object.freeze({ description: "Capacitor behaves like a low-impedance fault.", l1: "Connected nets are forced together at low impedance.", l2: "Bias collapse or supply loading may trigger multi-node failure signatures." }),
        capacitance_low: Object.freeze({ description: "Capacitance drops below expected value.", l1: "Time constants shorten and filtering weakens.", l2: "Dynamic stability margins degrade under transient loading." }),
        esr_high: Object.freeze({ description: "Equivalent series resistance rises beyond expected.", l1: "Ripple attenuation and pulse-current support degrade.", l2: "Thermal self-heating and cross-stage noise coupling increase." })
      }),
      transistor: Object.freeze({
        gain_low: Object.freeze({ description: "Effective beta/transconductance is reduced.", l1: "Stage gain drops and bias point may move off center.", l2: "Signal chain compression/under-drive propagates to downstream nodes." }),
        be_short: Object.freeze({ description: "Base-emitter junction is effectively shorted.", l1: "Bias network is heavily loaded and control action is lost.", l2: "Collector/emitter operating point collapses and output behavior saturates." }),
        ce_short: Object.freeze({ description: "Collector-emitter path is shorted or near short.", l1: "Load is forced toward supply/ground path unexpectedly.", l2: "Branch overcurrent and thermal stress can propagate into supply network." }),
        open_collector: Object.freeze({ description: "Collector conduction path opens.", l1: "Expected sink/source path disappears.", l2: "Downstream node floats or rails, causing interface-level functional loss." })
      }),
      connector: Object.freeze({
        open_contact: Object.freeze({ description: "One or more interface contacts are open.", l1: "Signal or supply continuity is interrupted.", l2: "External-system observability/control degrades and appears intermittent/static." }),
        intermittent_contact: Object.freeze({ description: "Contact intermittently opens under vibration or handling.", l1: "Momentary dropouts appear on interface nets.", l2: "Transient faults propagate as sporadic resets, spikes, or communication loss." })
      }),
      test_point: Object.freeze({
        measurement_error: Object.freeze({ description: "Probe setup or instrument coupling introduces error.", l1: "Observed value diverges from actual node condition.", l2: "Diagnostic decisions propagate incorrect fault isolation paths." }),
        probe_slip: Object.freeze({ description: "Probe contact moves to wrong node or loses contact.", l1: "Sampled signal is discontinuous or from unintended net.", l2: "Root-cause localization propagates to false suspects." }),
        open_test_node: Object.freeze({ description: "Test access path is open or inaccessible.", l1: "Required observability point is unavailable.", l2: "Coverage gaps increase and detection score worsens for related failures." })
      }),
      integrated_circuit: Object.freeze({
        pin_short_to_adjecent_pin_up: Object.freeze({
          description: "A pin is shorted to the physically adjacent higher-index pin, coupling two intendedly independent IC nodes.",
          l1: "The victim/source pins are electrically forced together, corrupting logic levels, bias points, or analog signal integrity at the package boundary.",
          l2: "Propagation extends into connected nets and downstream stages as contention, false switching, unstable bias, or overstress signatures that appear topology-consistent across both pin paths."
        }),
        pin_short_to_adjecent_pin_down: Object.freeze({
          description: "A pin is shorted to the physically adjacent lower-index pin, creating unintended bidirectional interaction between neighboring IC functions.",
          l1: "Both adjacent pin functions lose independence; expected drive/sense behavior degrades due to cross-loading, level collapse, or parasitic injection.",
          l2: "Secondary effects propagate as multi-net functional corruption, intermittent misbehavior under dynamic conditions, and misleading observability because both affected channels fail in a coupled pattern."
        })
      }),
      other: Object.freeze({})
    });

    const occurrenceByClass = Object.freeze({
      resistor: 3,
      capacitor: 4,
      transistor: 5,
      connector: 6,
      test_point: 2,
      diode: 4,
      inductor: 4,
      integrated_circuit: 6,
      switch: 5,
      fuse: 3,
      relay: 5,
      transformer: 4,
      crystal: 4,
      sensor: 5,
      other: 4
    });

     const detectionCovered = 3;
     const detectionUncovered = 8;

     const analyzers = Object.freeze({
       fmea: runFMEA,
       epsa: runEPSA,
       wcca: runWCCA,
       coverage: runCoverage
     });

    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    const analysisType = document.getElementById("analysisType");
    const runBtn = document.getElementById("runBtn");
    const saveResultsBtn = document.getElementById("saveResultsBtn");
    const exportBtn = document.getElementById("exportBtn");
    const secondaryWrap = document.getElementById("secondaryWrap");


     const inputStatus = document.getElementById("inputStatus");
     const resultStatus = document.getElementById("resultStatus");
     const inputViewer = document.getElementById("inputViewer");
     const outputViewer = document.getElementById("outputViewer");
     const netGraphViewer = document.getElementById("netGraphViewer");
     const resultsHead = document.getElementById("resultsHead");
     const resultsBody = document.getElementById("resultsBody");
    const secondaryHead = document.getElementById("secondaryHead");
    const secondaryBody = document.getElementById("secondaryBody");
    const summaryGrid = document.getElementById("summaryGrid");
    const resultsSubtabAffects = document.getElementById("resultsSubtabAffects");
    const resultsSubtabModes = document.getElementById("resultsSubtabModes");
    const resultsSubtabTroubleshooting = document.getElementById("resultsSubtabTroubleshooting");
    const resultsSubtabTables = document.getElementById("resultsSubtabTables");
    const resultsSubpanelAffects = document.getElementById("resultsSubpanelAffects");
    const resultsSubpanelModes = document.getElementById("resultsSubpanelModes");
    const resultsSubpanelTroubleshooting = document.getElementById("resultsSubpanelTroubleshooting");
    const resultsSubpanelTables = document.getElementById("resultsSubpanelTables");
    const failureAffectsViewer = document.getElementById("failureAffectsViewer");
    const failureModesViewer = document.getElementById("failureModesViewer");
    const troubleshootingViewer = document.getElementById("troubleshootingViewer");
    const tabSetupBtn = document.getElementById("tabSetupBtn");
    const tabInputsBtn = document.getElementById("tabInputsBtn");
    const tabRunBtn = document.getElementById("tabRunBtn");
    const tabResultsBtn = document.getElementById("tabResultsBtn");
    const tabSavedBtn = document.getElementById("tabSavedBtn");
    const tabSetupState = document.getElementById("tabSetupState");
    const tabInputsState = document.getElementById("tabInputsState");
    const tabRunState = document.getElementById("tabRunState");
    const tabResultsState = document.getElementById("tabResultsState");
    const tabSavedState = document.getElementById("tabSavedState");
    const panelSetup = document.getElementById("panelSetup");
    const panelInputs = document.getElementById("panelInputs");
    const panelRun = document.getElementById("panelRun");
    const panelResults = document.getElementById("panelResults");
    const panelSaved = document.getElementById("panelSaved");
    const saveSetupBtn = document.getElementById("saveSetupBtn");
    const setupSaveStatus = document.getElementById("setupSaveStatus");
    const selectFmeaDirBtn = document.getElementById("selectFmeaDirBtn");
    const refreshSavedBtn = document.getElementById("refreshSavedBtn");
    const savedStatus = document.getElementById("savedStatus");
    const savedFilesBody = document.getElementById("savedFilesBody");
    const fmeaAssumptionsSection = document.getElementById("fmeaAssumptionsSection");
    const fmeaAssumptionsStatus = document.getElementById("fmeaAssumptionsStatus");
    const fmeaLookupBody = document.getElementById("fmeaLookupBody");
    const fmeaGeneratedBoard = document.getElementById("fmeaGeneratedBoard");
    const fmeaDetailComponent = document.getElementById("fmeaDetailComponent");
    const fmeaDetailMode = document.getElementById("fmeaDetailMode");
    const fmeaDetailDescription = document.getElementById("fmeaDetailDescription");
    const fmeaDetailL1 = document.getElementById("fmeaDetailL1");
    const fmeaDetailL2 = document.getElementById("fmeaDetailL2");
    const fmeaDetailSaveBtn = document.getElementById("fmeaDetailSaveBtn");
    const fmeaDetailResetBtn = document.getElementById("fmeaDetailResetBtn");
    const lookupModeContextMenu = document.getElementById("lookupModeContextMenu");
    const setupStageTabType = document.getElementById("setupStageTabType");
    const setupStageTabAssumptions = document.getElementById("setupStageTabAssumptions");
    const setupStageTabComponents = document.getElementById("setupStageTabComponents");
    const setupStageTabDrill = document.getElementById("setupStageTabDrill");
    const setupStagePanelType = document.getElementById("setupStagePanelType");
    const setupStagePanelAssumptions = document.getElementById("setupStagePanelAssumptions");
    const setupStagePanelComponents = document.getElementById("setupStagePanelComponents");
    const setupStagePanelDrill = document.getElementById("setupStagePanelDrill");


     let sortState = { key: null, direction: 1, table: "primary" };
     const drillSelection = { refdes: "", mode: "" };
     const lookupContextState = { componentType: "", modeIndex: -1 };



    uploadBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", handleFileUpload);
    runBtn.addEventListener("click", runSelectedAnalysis);
    saveResultsBtn.addEventListener("click", saveResultsFile);
    exportBtn.addEventListener("click", exportResults);
    analysisType.addEventListener("change", handleAnalysisTypeChange);
    tabSetupBtn.addEventListener("click", () => activateTab("setup"));
    tabInputsBtn.addEventListener("click", () => activateTab("inputs"));
    tabRunBtn.addEventListener("click", () => activateTab("run"));
    tabResultsBtn.addEventListener("click", () => activateTab("results"));
    tabSavedBtn.addEventListener("click", () => activateTab("saved"));
    fmeaDetailSaveBtn.addEventListener("click", saveFmeaDetailOverride);
    fmeaDetailResetBtn.addEventListener("click", resetFmeaDetailOverride);
    saveSetupBtn.addEventListener("click", saveSetupFile);
    selectFmeaDirBtn.addEventListener("click", selectFmeaDirectory);
    refreshSavedBtn.addEventListener("click", refreshSavedFiles);
    setupStageTabType.addEventListener("click", () => activateSetupStageTab("analysis_type"));
    setupStageTabAssumptions.addEventListener("click", () => activateSetupStageTab("analysis_assumptions"));
    setupStageTabComponents.addEventListener("click", () => activateSetupStageTab("assumptions_per_component"));
    setupStageTabDrill.addEventListener("click", () => activateSetupStageTab("propagation_drill_down"));
    resultsSubtabAffects.addEventListener("click", () => activateResultsSubtab("affects"));
    resultsSubtabModes.addEventListener("click", () => activateResultsSubtab("modes"));
    resultsSubtabTroubleshooting.addEventListener("click", () => activateResultsSubtab("troubleshooting"));
    resultsSubtabTables.addEventListener("click", () => activateResultsSubtab("tables"));
    if (lookupModeContextMenu) {
      lookupModeContextMenu.addEventListener("click", handleLookupModeContextAction);
      document.addEventListener("click", hideLookupModeContextMenu);
      document.addEventListener("keydown", (ev) => { if (ev.key === "Escape") hideLookupModeContextMenu(); });
      document.addEventListener("contextmenu", (ev) => {
        const target = ev.target;
        if (!(target instanceof HTMLElement) || !target.closest(".lookup-mode-pill")) hideLookupModeContextMenu();
      });
    }

    initializeFmeaAssumptions();
    activateSetupStageTab("analysis_type");
    applyFixedUiDefaults();
    updateWorkflowUi();
    refreshSavedFiles();

    function handleAnalysisTypeChange() {
      resetRunState();
      updateWorkflowUi();
      refreshFmeaAssumptionUi();
      updateSetupStageTabsForAnalysisType();
      if (state.inputsValid) {
        inputStatus.textContent = "Inputs loaded and validated. Ready to run " + analysisType.value.toUpperCase() + ".";
      }
    }

    function activateSetupStageTab(tabName) {
      const tabs = {
        analysis_type: { btn: setupStageTabType, panel: setupStagePanelType },
        analysis_assumptions: { btn: setupStageTabAssumptions, panel: setupStagePanelAssumptions },
        assumptions_per_component: { btn: setupStageTabComponents, panel: setupStagePanelComponents },
        propagation_drill_down: { btn: setupStageTabDrill, panel: setupStagePanelDrill }
      };
      const current = tabs[tabName];
      if (!current || current.btn.disabled) return;
      for (const value of Object.values(tabs)) {
        value.btn.classList.remove("active");
        value.panel.classList.add("hidden");
      }
      current.btn.classList.add("active");
      current.panel.classList.remove("hidden");
    }

    function updateSetupStageTabsForAnalysisType() {
      const isFmea = analysisType.value === "fmea";
      setupStageTabAssumptions.disabled = !isFmea;
      setupStageTabComponents.disabled = !isFmea;
      setupStageTabDrill.disabled = !isFmea;
      if (!isFmea) activateSetupStageTab("analysis_type");
    }

    function activateResultsSubtab(name) {
      const tabs = {
        affects: { btn: resultsSubtabAffects, panel: resultsSubpanelAffects },
        modes: { btn: resultsSubtabModes, panel: resultsSubpanelModes },
        troubleshooting: { btn: resultsSubtabTroubleshooting, panel: resultsSubpanelTroubleshooting },
        tables: { btn: resultsSubtabTables, panel: resultsSubpanelTables }
      };
      const current = tabs[name];
      if (!current) return;
      for (const value of Object.values(tabs)) {
        value.btn.classList.remove("active");
        value.panel.classList.add("hidden");
      }
      current.btn.classList.add("active");
      current.panel.classList.remove("hidden");
    }

    function applyFixedUiDefaults() {
      secondaryWrap.style.display = FIXED_SHOW_SECONDARY_TABLE ? "block" : "none";
    }

    function setTabState(button, label, mode) {
      button.classList.remove("state-locked", "state-ready", "state-done");
      button.classList.add(mode);
      button.disabled = mode === "state-locked";
      label.textContent = mode === "state-done" ? "Done" : mode === "state-ready" ? "Ready" : "Locked";
    }

    function activateTab(tabName) {
      const tabs = {
        setup: { btn: tabSetupBtn, panel: panelSetup },
        inputs: { btn: tabInputsBtn, panel: panelInputs },
        run: { btn: tabRunBtn, panel: panelRun },
        results: { btn: tabResultsBtn, panel: panelResults },
        saved: { btn: tabSavedBtn, panel: panelSaved }
      };
      const current = tabs[tabName];
      if (!current || current.btn.disabled) return;
      for (const value of Object.values(tabs)) {
        value.btn.classList.remove("active");
        value.panel.classList.add("hidden");
      }
      current.btn.classList.add("active");
      current.panel.classList.remove("hidden");
    }

    function updateWorkflowUi() {
      const analysisReady = !!analysisType.value;
      const inputsReady = analysisReady && !!state.inputsValid;
      const runDone = !!state.lastOutput;
      const outputsReady = runDone;
      const outputsDone = outputsReady && !!state.outputsExported;

      uploadBtn.disabled = !analysisReady;
      runBtn.disabled = !inputsReady;
      saveResultsBtn.disabled = !outputsReady;
      exportBtn.disabled = !outputsReady;

      setTabState(tabSetupBtn, tabSetupState, "state-done");
      setTabState(tabInputsBtn, tabInputsState, inputsReady ? "state-done" : "state-ready");
      setTabState(tabRunBtn, tabRunState, runDone ? "state-done" : (inputsReady ? "state-ready" : "state-locked"));
      setTabState(tabResultsBtn, tabResultsState, outputsDone ? "state-done" : (outputsReady ? "state-ready" : "state-locked"));
      setTabState(tabSavedBtn, tabSavedState, "state-ready");

      if (tabResultsBtn.disabled && tabResultsBtn.classList.contains("active")) {
        if (!tabRunBtn.disabled) activateTab("run");
        else if (!tabInputsBtn.disabled) activateTab("inputs");
        else activateTab("setup");
      }
      if (tabRunBtn.disabled && tabRunBtn.classList.contains("active")) {
        if (!tabInputsBtn.disabled) activateTab("inputs");
        else activateTab("setup");
      }
    }

    function initializeFmeaAssumptions() {
      state.fmeaAssumptionLookup = cloneFailureModeLookup(DEFAULT_FAILURE_MODES_BY_CLASS);
      state.fmeaAssumptionOverrides = {};
      state.fmeaKnowledgeOverrides = {};
      refreshFmeaAssumptionUi();
    }

    function cloneFailureModeLookup(lookup) {
      const clone = {};
      for (const [k, v] of Object.entries(lookup)) clone[k] = Array.isArray(v) ? v.slice() : [];
      return clone;
    }

    function normalizeFailureModeListFromText(text) {
      const values = String(text || "")
        .split(/\r?\n|,/)
        .map((x) => x.trim().toLowerCase().replace(/\s+/g, "_"))
        .filter(Boolean);
      return dedupe(values);
    }

    function normalizeFailureModeValue(value) {
      return String(value || "").trim().toLowerCase().replace(/\s+/g, "_");
    }

    function getFailureModesForComponent(componentClass, refdes) {
      const buckets = getFailureModeBucketsForComponent(componentClass, refdes);
      return buckets.run.slice();
    }

    function getFailureModeBucketsForComponent(componentClass, refdes) {
      const defaults = state.fmeaAssumptionLookup[componentClass] || state.fmeaAssumptionLookup.other || ["open"];
      const override = state.fmeaAssumptionOverrides[refdes];
      if (!override) return { run: defaults.slice(), skip: [], isOverride: false };

      // Backward compatibility with previous array-based override format.
      if (Array.isArray(override)) {
        const runLegacy = dedupe(override);
        const skipLegacy = defaults.filter((m) => !runLegacy.includes(m));
        return { run: runLegacy, skip: skipLegacy, isOverride: true };
      }

      const run = dedupe(Array.isArray(override.run) ? override.run : defaults);
      const skip = dedupe(Array.isArray(override.skip) ? override.skip : []);
      const merged = dedupe([].concat(run, skip, defaults));
      const resolvedRun = dedupe(run.filter((m) => merged.includes(m)));
      const resolvedSkip = dedupe(skip.filter((m) => merged.includes(m) && !resolvedRun.includes(m)));
      const isOverride = !arraysEqual(resolvedRun, defaults) || resolvedSkip.length > 0;
      return { run: resolvedRun, skip: resolvedSkip, isOverride };
    }

    function setFailureModeBucketsForComponent(componentClass, refdes, run, skip) {
      const defaults = state.fmeaAssumptionLookup[componentClass] || state.fmeaAssumptionLookup.other || ["open"];
      const runNorm = dedupe((run || []).map((x) => String(x).trim()).filter(Boolean));
      const skipNorm = dedupe((skip || []).map((x) => String(x).trim()).filter(Boolean)).filter((m) => !runNorm.includes(m));
      if (arraysEqual(runNorm, defaults) && skipNorm.length === 0) {
        delete state.fmeaAssumptionOverrides[refdes];
        return;
      }
      state.fmeaAssumptionOverrides[refdes] = { run: runNorm, skip: skipNorm };
    }

    function buildKnowledgeKey(componentClass, mode) {
      return componentClass + "::" + mode;
    }

    function buildDefaultFailureKnowledge(componentClass, mode) {
      const modeLabel = String(mode || "unknown").replace(/_/g, " ");
      const typeLabel = String(componentClass || "component").replace(/_/g, " ");
      return {
        description: "Deterministic failure assumption for " + typeLabel + " mode '" + modeLabel + "'.",
        l1: "Primary propagation: directly connected nets and bias points shift based on topology.",
        l2: "Secondary propagation: downstream interfaces, margins, and detection paths are impacted."
      };
    }

    function getFailureModeKnowledge(componentClass, mode) {
      const key = buildKnowledgeKey(componentClass, mode);
      if (state.fmeaKnowledgeOverrides[key]) return Object.assign({}, state.fmeaKnowledgeOverrides[key]);
      const typeDefaults = DEFAULT_FAILURE_MODE_KNOWLEDGE[componentClass] || DEFAULT_FAILURE_MODE_KNOWLEDGE.other || {};
      const knowledge = typeDefaults[mode];
      if (knowledge) return { description: knowledge.description, l1: knowledge.l1, l2: knowledge.l2 };
      return buildDefaultFailureKnowledge(componentClass, mode);
    }

    function renderFmeaLookupTable() {
      if (!fmeaLookupBody) return;
      fmeaLookupBody.innerHTML = "";
      const keys = Object.keys(state.fmeaAssumptionLookup || {}).sort();
      for (const componentType of keys) {
        const card = document.createElement("div");
        card.className = "lookup-pill-card";
        const typePill = document.createElement("span");
        typePill.className = "lookup-type-pill";
        typePill.textContent = componentType;
        const modeCloud = document.createElement("div");
        modeCloud.className = "lookup-mode-cloud";
        const modes = state.fmeaAssumptionLookup[componentType] || [];
        for (let i = 0; i < modes.length; i += 1) {
          const mode = modes[i];
          const pill = document.createElement("span");
          pill.className = "lookup-mode-pill";
          pill.textContent = mode;
          pill.addEventListener("contextmenu", (ev) => showLookupModeContextMenu(ev, componentType, i));
          modeCloud.appendChild(pill);
        }
        const editLabel = document.createElement("div");
        editLabel.className = "lookup-edit-label";
        editLabel.textContent = "Edit modes (one per line)";
        const textarea = document.createElement("textarea");
        textarea.value = modes.join("\n");
        textarea.addEventListener("change", () => {
          const list = normalizeFailureModeListFromText(textarea.value);
          state.fmeaAssumptionLookup[componentType] = list.length ? list : ["open"];
          textarea.value = state.fmeaAssumptionLookup[componentType].join("\n");
          renderFmeaLookupTable();
          renderGeneratedFmeaAssumptions();
        });
        card.appendChild(typePill);
        card.appendChild(modeCloud);
        card.appendChild(editLabel);
        card.appendChild(textarea);
        fmeaLookupBody.appendChild(card);
      }
    }

    function showLookupModeContextMenu(ev, componentType, modeIndex) {
      if (!lookupModeContextMenu) return;
      ev.preventDefault();
      lookupContextState.componentType = componentType;
      lookupContextState.modeIndex = modeIndex;
      lookupModeContextMenu.classList.remove("hidden");
      const pad = 8;
      const menuRect = lookupModeContextMenu.getBoundingClientRect();
      const x = Math.min(ev.clientX, window.innerWidth - menuRect.width - pad);
      const y = Math.min(ev.clientY, window.innerHeight - menuRect.height - pad);
      lookupModeContextMenu.style.left = Math.max(pad, x) + "px";
      lookupModeContextMenu.style.top = Math.max(pad, y) + "px";
    }

    function hideLookupModeContextMenu() {
      if (!lookupModeContextMenu) return;
      lookupModeContextMenu.classList.add("hidden");
    }

    function handleLookupModeContextAction(ev) {
      const target = ev.target;
      if (!(target instanceof HTMLElement)) return;
      const action = target.dataset.lookupAction;
      if (!action) return;
      const componentType = lookupContextState.componentType;
      const idx = lookupContextState.modeIndex;
      const list = (state.fmeaAssumptionLookup[componentType] || []).slice();
      if (!componentType || idx < 0 || idx >= list.length) {
        hideLookupModeContextMenu();
        return;
      }
      if (action === "duplicate") {
        list.splice(idx + 1, 0, list[idx]);
      } else if (action === "delete") {
        list.splice(idx, 1);
        if (!list.length) list.push("open");
      } else if (action === "insert_before" || action === "insert_after") {
        const entered = window.prompt("Enter new failure mode token (example: pin_short_crossrail):", "");
        const normalized = normalizeFailureModeValue(entered);
        if (!normalized) {
          hideLookupModeContextMenu();
          return;
        }
        const insertAt = action === "insert_before" ? idx : idx + 1;
        list.splice(insertAt, 0, normalized);
      }
      state.fmeaAssumptionLookup[componentType] = list;
      hideLookupModeContextMenu();
      renderFmeaLookupTable();
      renderGeneratedFmeaAssumptions();
    }

    function createModePill(refdes, mode, bucketName) {
      const pill = document.createElement("span");
      pill.className = "mode-pill" + (bucketName === "skip" ? " skip" : "");
      pill.textContent = mode;
      pill.draggable = true;
      pill.dataset.refdes = refdes;
      pill.dataset.mode = mode;
      pill.dataset.bucket = bucketName;
      pill.addEventListener("dragstart", (ev) => {
        ev.dataTransfer.setData("text/plain", JSON.stringify({
          refdes,
          mode,
          fromBucket: bucketName
        }));
      });
      return pill;
    }

    function attachBucketDropHandlers(bucketEl, refdes, targetBucket) {
      bucketEl.addEventListener("dragover", (ev) => {
        ev.preventDefault();
        bucketEl.classList.add("drag-over");
      });
      bucketEl.addEventListener("dragleave", () => bucketEl.classList.remove("drag-over"));
      bucketEl.addEventListener("drop", (ev) => {
        ev.preventDefault();
        bucketEl.classList.remove("drag-over");
        let payload = null;
        try { payload = JSON.parse(ev.dataTransfer.getData("text/plain")); } catch (_err) { return; }
        if (!payload || payload.refdes !== refdes || !payload.mode) return;
        const componentType = classifyComponent(refdes);
        const buckets = getFailureModeBucketsForComponent(componentType, refdes);
        const run = buckets.run.slice();
        const skip = buckets.skip.slice();
        if (payload.fromBucket === targetBucket) return;
        if (targetBucket === "run") {
          if (!run.includes(payload.mode)) run.push(payload.mode);
          const idx = skip.indexOf(payload.mode);
          if (idx >= 0) skip.splice(idx, 1);
        } else {
          if (!skip.includes(payload.mode)) skip.push(payload.mode);
          const idx = run.indexOf(payload.mode);
          if (idx >= 0) run.splice(idx, 1);
        }
        if (!run.length) return; // keep at least one runnable mode
        setFailureModeBucketsForComponent(componentType, refdes, run, skip);
        renderGeneratedFmeaAssumptions();
      });
    }

    function renderGeneratedFmeaAssumptions() {
      if (!fmeaGeneratedBoard) return;
      fmeaGeneratedBoard.innerHTML = "";
      const components = (state.netlist && Array.isArray(state.netlist.components)) ? state.netlist.components.slice() : [];
      components.sort((a, b) => String(a.refdes || "").localeCompare(String(b.refdes || "")));
      if (!components.length) {
        const empty = document.createElement("div");
        empty.className = "assumption-note";
        empty.textContent = "Load a netlist to generate assumptions per component.";
        fmeaGeneratedBoard.appendChild(empty);
        return;
      }

      for (const component of components) {
        const refdes = component.refdes || "UNASSIGNED";
        const componentType = classifyComponent(refdes);
        const buckets = getFailureModeBucketsForComponent(componentType, refdes);
        const card = document.createElement("div");
        card.className = "assumption-card";

        const head = document.createElement("div");
        head.className = "assumption-card-head";
        const chipRef = document.createElement("span");
        chipRef.className = "assumption-chip ref";
        chipRef.textContent = refdes;
        const chipType = document.createElement("span");
        chipType.className = "assumption-chip type";
        chipType.textContent = componentType;
        const chipSrc = document.createElement("span");
        chipSrc.className = "assumption-chip src";
        chipSrc.textContent = buckets.isOverride ? "override" : "lookup";
        head.appendChild(chipRef);
        head.appendChild(chipType);
        head.appendChild(chipSrc);

        const bucketGrid = document.createElement("div");
        bucketGrid.className = "bucket-grid";
        const runBucket = document.createElement("div");
        runBucket.className = "bucket run";
        const skipBucket = document.createElement("div");
        skipBucket.className = "bucket skip";
        const runTitle = document.createElement("h4");
        runTitle.textContent = "Run";
        const skipTitle = document.createElement("h4");
        skipTitle.textContent = "Skip";
        runBucket.appendChild(runTitle);
        skipBucket.appendChild(skipTitle);
        for (const mode of buckets.run) runBucket.appendChild(createModePill(refdes, mode, "run"));
        for (const mode of buckets.skip) skipBucket.appendChild(createModePill(refdes, mode, "skip"));
        attachBucketDropHandlers(runBucket, refdes, "run");
        attachBucketDropHandlers(skipBucket, refdes, "skip");
        bucketGrid.appendChild(runBucket);
        bucketGrid.appendChild(skipBucket);

        card.appendChild(head);
        card.appendChild(bucketGrid);
        fmeaGeneratedBoard.appendChild(card);
      }
      refreshFmeaDetailComponentOptions();
    }

    function refreshFmeaDetailComponentOptions() {
      if (!fmeaDetailComponent) return;
      const prev = drillSelection.refdes;
      fmeaDetailComponent.innerHTML = "";
      const components = (state.netlist && Array.isArray(state.netlist.components)) ? state.netlist.components.slice() : [];
      components.sort((a, b) => String(a.refdes || "").localeCompare(String(b.refdes || "")));
      if (!components.length) {
        drillSelection.refdes = "";
        refreshFmeaDetailModeOptions();
        return;
      }
      const refs = components.map((c) => c.refdes || "UNASSIGNED");
      drillSelection.refdes = refs.includes(prev) ? prev : refs[0];
      for (const ref of refs) {
        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "drill-pill" + (ref === drillSelection.refdes ? " active" : "");
        pill.textContent = ref;
        const color = getRefdesColor(ref);
        pill.style.background = color.bg;
        pill.style.borderColor = color.border;
        pill.style.color = color.text;
        pill.addEventListener("click", () => {
          drillSelection.refdes = ref;
          refreshFmeaDetailComponentOptions();
        });
        fmeaDetailComponent.appendChild(pill);
      }
      refreshFmeaDetailModeOptions();
    }

    function refreshFmeaDetailModeOptions() {
      if (!fmeaDetailMode) return;
      const refdes = drillSelection.refdes;
      const prev = drillSelection.mode;
      fmeaDetailMode.innerHTML = "";
      if (!refdes) {
        drillSelection.mode = "";
        populateFmeaDetailEditor();
        return;
      }
      const componentType = classifyComponent(refdes);
      const buckets = getFailureModeBucketsForComponent(componentType, refdes);
      const modes = dedupe([].concat(buckets.run, buckets.skip));
      drillSelection.mode = modes.includes(prev) ? prev : (modes[0] || "");
      for (const mode of modes) {
        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "drill-pill" + (mode === drillSelection.mode ? " active" : "");
        pill.textContent = mode;
        const modeIsRun = buckets.run.includes(mode);
        pill.style.background = modeIsRun ? "rgba(46,204,113,0.2)" : "rgba(255,87,87,0.2)";
        pill.style.borderColor = modeIsRun ? "rgba(46,204,113,0.52)" : "rgba(255,87,87,0.52)";
        pill.style.color = modeIsRun ? "#d6ffe8" : "#ffd8d8";
        pill.addEventListener("click", () => {
          drillSelection.mode = mode;
          refreshFmeaDetailModeOptions();
        });
        fmeaDetailMode.appendChild(pill);
      }
      populateFmeaDetailEditor();
    }

    function setDetailPillContent(wrapper, text, disabled) {
      const content = wrapper ? wrapper.querySelector(".pill-text") : null;
      if (!wrapper || !content) return;
      content.textContent = text || "";
      content.contentEditable = disabled ? "false" : "true";
      wrapper.classList.toggle("disabled", !!disabled);
    }

    function getDetailPillContent(wrapper) {
      const content = wrapper ? wrapper.querySelector(".pill-text") : null;
      return content ? String(content.textContent || "").trim() : "";
    }

    function getRefdesColor(refdes) {
      const text = String(refdes || "X");
      let hash = 0;
      for (let i = 0; i < text.length; i += 1) hash = ((hash << 5) - hash + text.charCodeAt(i)) | 0;
      const hue = Math.abs(hash) % 360;
      return {
        bg: "hsla(" + hue + ", 65%, 25%, 0.42)",
        border: "hsla(" + hue + ", 75%, 62%, 0.62)",
        text: "hsla(" + hue + ", 92%, 90%, 1)"
      };
    }

    function populateFmeaDetailEditor() {
      const refdes = drillSelection.refdes;
      const mode = drillSelection.mode;
      const disable = !refdes || !mode;
      fmeaDetailSaveBtn.disabled = disable;
      fmeaDetailResetBtn.disabled = disable;
      if (disable) {
        setDetailPillContent(fmeaDetailDescription, "", true);
        setDetailPillContent(fmeaDetailL1, "", true);
        setDetailPillContent(fmeaDetailL2, "", true);
        return;
      }
      const componentType = classifyComponent(refdes);
      const k = getFailureModeKnowledge(componentType, mode);
      setDetailPillContent(fmeaDetailDescription, k.description || "", false);
      setDetailPillContent(fmeaDetailL1, k.l1 || "", false);
      setDetailPillContent(fmeaDetailL2, k.l2 || "", false);
    }

    function saveFmeaDetailOverride() {
      const refdes = drillSelection.refdes;
      const mode = drillSelection.mode;
      if (!refdes || !mode) return;
      const componentType = classifyComponent(refdes);
      const key = buildKnowledgeKey(componentType, mode);
      state.fmeaKnowledgeOverrides[key] = {
        description: getDetailPillContent(fmeaDetailDescription),
        l1: getDetailPillContent(fmeaDetailL1),
        l2: getDetailPillContent(fmeaDetailL2)
      };
      fmeaAssumptionsStatus.textContent = "Saved detail override for " + componentType + " / " + mode + ".";
    }

    function resetFmeaDetailOverride() {
      const refdes = drillSelection.refdes;
      const mode = drillSelection.mode;
      if (!refdes || !mode) return;
      const componentType = classifyComponent(refdes);
      delete state.fmeaKnowledgeOverrides[buildKnowledgeKey(componentType, mode)];
      populateFmeaDetailEditor();
      fmeaAssumptionsStatus.textContent = "Reset detail override to deterministic default for " + componentType + " / " + mode + ".";
    }

    function refreshFmeaAssumptionUi() {
      if (!fmeaAssumptionsSection) return;
      const isFmea = analysisType.value === "fmea";
      updateSetupStageTabsForAnalysisType();
      if (!isFmea) {
        fmeaAssumptionsStatus.textContent = "Select FMEA in Analysis Type to enable assumptions, per-component run/skip, and propagation drill-down.";
        renderResultsInsights();
        return;
      }
      renderFmeaLookupTable();
      renderGeneratedFmeaAssumptions();
      const componentCount = state.netlist && Array.isArray(state.netlist.components) ? state.netlist.components.length : 0;
      fmeaAssumptionsStatus.textContent = componentCount
        ? "Deterministic assumptions generated for " + componentCount + " components from refdes-derived types."
        : "Load inputs to generate component-level assumptions.";
      renderResultsInsights();
    }

    function buildFmeaReviewRows() {
      if (analysisType.value !== "fmea" || !state.netlist || !Array.isArray(state.netlist.components)) return [];
      const components = state.netlist.components.slice().sort((a, b) => String(a.refdes || "").localeCompare(String(b.refdes || "")));
      const netToRefs = buildNetToRefsMap(state.netlist);
      const rows = [];
      for (const component of components) {
        const refdes = component.refdes || "UNASSIGNED";
        const componentType = classifyComponent(refdes);
        const buckets = getFailureModeBucketsForComponent(componentType, refdes);
        const nets = extractComponentNets(component);
        const affectedComponents = dedupe(nets.flatMap((net) => netToRefs[net] || []).filter((r) => r !== refdes));
        for (const mode of buckets.run) {
          const k = getFailureModeKnowledge(componentType, mode);
          rows.push({
            refdes,
            component_type: componentType,
            mode,
            description: k.description || "",
            l1: k.l1 || "",
            l2: k.l2 || "",
            affected_nets: nets,
            affected_components: affectedComponents
          });
        }
      }
      return rows;
    }

    function renderFailureModesReview(rows) {
      if (!failureModesViewer) return;
      failureModesViewer.innerHTML = "";
      if (!rows.length) {
        const card = document.createElement("div");
        card.className = "review-card";
        card.textContent = analysisType.value === "fmea"
          ? "No non-skipped failure modes available yet."
          : "Failure mode review is available when Analysis Type is set to FMEA.";
        failureModesViewer.appendChild(card);
        return;
      }
      const byComponent = {};
      for (const row of rows) {
        if (!byComponent[row.refdes]) byComponent[row.refdes] = { component_type: row.component_type, modes: [] };
        byComponent[row.refdes].modes.push(row.mode);
      }
      for (const refdes of Object.keys(byComponent).sort()) {
        const card = document.createElement("div");
        card.className = "review-card";
        const pills = document.createElement("div");
        pills.className = "review-pill-row";
        const ref = document.createElement("span");
        ref.className = "review-pill ref";
        ref.textContent = refdes;
        const type = document.createElement("span");
        type.className = "review-pill type";
        type.textContent = byComponent[refdes].component_type;
        pills.appendChild(ref);
        pills.appendChild(type);
        card.appendChild(pills);
        const modeRow = document.createElement("div");
        modeRow.className = "review-pill-row";
        for (const mode of dedupe(byComponent[refdes].modes).sort()) {
          const m = document.createElement("span");
          m.className = "review-pill mode";
          m.textContent = mode;
          modeRow.appendChild(m);
        }
        card.appendChild(modeRow);
        failureModesViewer.appendChild(card);
      }
    }

    function renderFailureAffectsReview(rows) {
      if (!failureAffectsViewer) return;
      failureAffectsViewer.innerHTML = "";
      if (!rows.length) {
        const card = document.createElement("div");
        card.className = "review-card";
        card.textContent = analysisType.value === "fmea"
          ? "No propagation records available yet."
          : "Propagation affects are available when Analysis Type is set to FMEA.";
        failureAffectsViewer.appendChild(card);
        return;
      }
      for (const row of rows) {
        const card = document.createElement("div");
        card.className = "review-card";
        const idRow = document.createElement("div");
        idRow.className = "review-pill-row";
        const ref = document.createElement("span");
        ref.className = "review-pill ref";
        ref.textContent = row.refdes;
        const type = document.createElement("span");
        type.className = "review-pill type";
        type.textContent = row.component_type;
        const mode = document.createElement("span");
        mode.className = "review-pill mode";
        mode.textContent = row.mode;
        idRow.appendChild(ref);
        idRow.appendChild(type);
        idRow.appendChild(mode);
        card.appendChild(idRow);

        const d = document.createElement("div");
        d.className = "review-text-block";
        const dk = document.createElement("span");
        dk.className = "k";
        dk.textContent = "Failure Mode Description";
        d.appendChild(dk);
        d.appendChild(document.createTextNode(row.description || "(none)"));
        card.appendChild(d);
        const l1 = document.createElement("div");
        l1.className = "review-text-block";
        const l1k = document.createElement("span");
        l1k.className = "k";
        l1k.textContent = "Propagation Effects - Level 1";
        l1.appendChild(l1k);
        l1.appendChild(document.createTextNode(row.l1 || "(none)"));
        card.appendChild(l1);
        const l2 = document.createElement("div");
        l2.className = "review-text-block";
        const l2k = document.createElement("span");
        l2k.className = "k";
        l2k.textContent = "Propagation Effects - Level 2";
        l2.appendChild(l2k);
        l2.appendChild(document.createTextNode(row.l2 || "(none)"));
        card.appendChild(l2);

        const netsRow = document.createElement("div");
        netsRow.className = "review-pill-row";
        for (const net of row.affected_nets) {
          const pill = document.createElement("span");
          pill.className = "review-pill net";
          pill.textContent = net;
          netsRow.appendChild(pill);
        }
        card.appendChild(netsRow);
        const compRow = document.createElement("div");
        compRow.className = "review-pill-row";
        for (const comp of row.affected_components) {
          const pill = document.createElement("span");
          pill.className = "review-pill aff";
          pill.textContent = comp;
          compRow.appendChild(pill);
        }
        card.appendChild(compRow);
        failureAffectsViewer.appendChild(card);
      }
    }

    function renderTroubleshootingReview(rows) {
      if (!troubleshootingViewer) return;
      troubleshootingViewer.innerHTML = "";
      const card = document.createElement("div");
      card.className = "review-card";
      const title = document.createElement("div");
      title.className = "review-text-block";
      const components = new Set(rows.map((r) => r.refdes));
      const modes = rows.length;
      const noModes = (state.netlist && Array.isArray(state.netlist.components))
        ? state.netlist.components
          .map((c) => c.refdes || "UNASSIGNED")
          .filter((refdes) => !rows.some((r) => r.refdes === refdes))
        : [];
      const tk = document.createElement("span");
      tk.className = "k";
      tk.textContent = "Troubleshooting Snapshot";
      title.appendChild(tk);
      title.appendChild(document.createTextNode("Components with run modes: " + components.size + " | Total considered modes: " + modes));
      card.appendChild(title);
      const tips = document.createElement("ul");
      tips.className = "review-list";
      const tipItems = [];
      tipItems.push("Use 'Failure Affects' to trace each mode's L1/L2 text with affected nets/components.");
      tipItems.push("Use 'Failure Modes' to verify non-skipped mode coverage per component before running analysis.");
      if (noModes.length) tipItems.push("Components with zero runnable modes: " + noModes.join(", "));
      if (!rows.length && analysisType.value === "fmea") tipItems.push("No modes are currently selected to run. Revisit Setup > Assumptions per Component.");
      if (analysisType.value !== "fmea") tipItems.push("Set Analysis Type to FMEA to populate this troubleshooting view.");
      for (const text of tipItems) {
        const li = document.createElement("li");
        li.textContent = text;
        tips.appendChild(li);
      }
      card.appendChild(tips);
      troubleshootingViewer.appendChild(card);
    }

    function renderResultsInsights() {
      const rows = buildFmeaReviewRows();
      renderFailureAffectsReview(rows);
      renderFailureModesReview(rows);
      renderTroubleshootingReview(rows);
    }

    function buildAnalysisStem(kind) {
      const boardPn = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_pn"], "unknown_board"));
      const boardRev = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_rev"], "unknown_rev"));
      const when = new Date().toISOString().replace(/[:.]/g, "-");
      return "analysis_" + safeFilePart(kind || analysisType.value || "fmea") + "_" + boardPn + "_" + boardRev + "_" + when;
    }

    function buildStableAnalysisStem() {
      const boardPn = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_pn"], "unknown_board"));
      const boardRev = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_rev"], "unknown_rev"));
      return "analysis_" + boardPn + "_" + boardRev;
    }

    function buildSetupPayload() {
      const netlist = state.netlist || null;
      const files = state.files || {};
      const fileNames = Object.keys(files).sort();
      const components = (netlist && Array.isArray(netlist.components)) ? netlist.components.slice() : [];
      components.sort((a, b) => String(a.refdes || "").localeCompare(String(b.refdes || "")));

      // Deterministic lightweight fingerprints to quickly detect setup changes without diffing large blobs.
      const hashOf = (value) => {
        const text = JSON.stringify(value);
        let h = 2166136261 >>> 0;
        for (let i = 0; i < text.length; i += 1) {
          h ^= text.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return ("00000000" + (h >>> 0).toString(16)).slice(-8);
      };

      const schFileName = fileNames.find((name) => /_sch\.json$/i.test(name))
        || fileNames.find((name) => files[name] === netlist)
        || "";
      const schRaw = schFileName ? files[schFileName] : (netlist || {});

      const componentTypeByRefdes = {};
      const fmeaCatalog = {};
      const resolvedByComponent = [];
      const validationErrors = [];
      const validationWarnings = [];

      for (const component of components) {
        const refdes = component.refdes || "UNASSIGNED";
        const componentType = classifyComponent(refdes);
        const buckets = getFailureModeBucketsForComponent(componentType, refdes);
        const allModes = dedupe([].concat(buckets.run, buckets.skip)).sort();
        const catalogRefs = [];

        componentTypeByRefdes[refdes] = componentType;
        for (const mode of allModes) {
          const modeRef = componentType + "::" + mode;
          const key = buildKnowledgeKey(componentType, mode);
          if (!fmeaCatalog[modeRef]) {
            const k = getFailureModeKnowledge(componentType, mode);
            fmeaCatalog[modeRef] = {
              component_type: componentType,
              mode,
              description: k.description || "",
              propagation_l1: k.l1 || "",
              propagation_l2: k.l2 || "",
              source: state.fmeaKnowledgeOverrides[key] ? "knowledge_override" : "default"
            };
          }
          catalogRefs.push(modeRef);
        }

        const overlap = buckets.run.filter((mode) => buckets.skip.includes(mode));
        if (overlap.length) validationErrors.push(refdes + " has run/skip overlap: " + overlap.join(", "));

        resolvedByComponent.push({
          refdes,
          component_type: componentType,
          assumption_source: buckets.isOverride ? "override" : "lookup",
          failure_modes_run: dedupe(buckets.run.slice()),
          failure_modes_skip: dedupe(buckets.skip.slice()),
          catalog_refs: dedupe(catalogRefs)
        });
      }

      for (const refdes of Object.keys(state.fmeaAssumptionOverrides || {})) {
        if (!componentTypeByRefdes[refdes]) validationWarnings.push("Override exists for non-netlist component: " + refdes);
      }

      const modeKnowledgeOverrides = {};
      for (const [modeRef, detail] of Object.entries(state.fmeaKnowledgeOverrides || {})) {
        modeKnowledgeOverrides[modeRef] = {
          description: String(safeGet(detail, ["description"], "") || ""),
          propagation_l1: String(safeGet(detail, ["l1"], "") || ""),
          propagation_l2: String(safeGet(detail, ["l2"], "") || "")
        };
      }

      const payload = {
        schema_version: "fmea_setup_v1",
        setup_type: "fmea",
        analysis_type: "fmea",
        generated_on: new Date().toISOString(),
        board_pn: safeGet(netlist || {}, ["identity", "board_pn"], "unknown_board"),
        board_rev: safeGet(netlist || {}, ["identity", "board_rev"], "unknown_rev"),
        input: {
          uploaded_files: fileNames,
          sch_file_name: schFileName,
          sch_raw: schRaw,
          sch_fingerprint: hashOf(schRaw)
        },
        classification: {
          // Deterministic refdes-prefix classifier version used to derive component_type_by_refdes.
          classification_rules_version: "refdes_prefix_v1",
          component_type_by_refdes: componentTypeByRefdes
        },
        // Canonical single-source catalog. Do not duplicate lookup tables elsewhere in the setup payload.
        fmea_catalog: fmeaCatalog,
        overrides: {
          component_overrides: state.fmeaAssumptionOverrides || {},
          mode_knowledge_overrides: modeKnowledgeOverrides
        },
        resolved_assumptions_by_component: resolvedByComponent,
        topology_snapshot: buildNetAdjacencyData(netlist),
        validation: {
          is_valid: validationErrors.length === 0,
          errors: validationErrors,
          warnings: validationWarnings
        },
        provenance: {
          analysis_engine_version: ENGINE_VERSION,
          ruleset_version: "fmea_ruleset_v1",
          fingerprints: {
            sch_raw: hashOf(schRaw),
            fmea_catalog: hashOf(fmeaCatalog),
            component_overrides: hashOf(state.fmeaAssumptionOverrides || {}),
            mode_knowledge_overrides: hashOf(modeKnowledgeOverrides),
            resolved_assumptions: hashOf(resolvedByComponent)
          }
        }
      };

      if (!payload.input.sch_file_name) validationWarnings.push("No *_sch.json filename detected; sch_raw sourced from current netlist.");
      return payload;
    }

    function setSavedStatus(message) {
      if (savedStatus) savedStatus.textContent = message;
      if (setupSaveStatus) setupSaveStatus.textContent = message;
    }

    async function resolveFmeaBaseDirectoryHandle() {
      if (!state.fmeaDirHandle) return null;
      const selected = state.fmeaDirHandle;
      try {
        const jsonDir = await selected.getDirectoryHandle("json");
        const fmeaDir = await jsonDir.getDirectoryHandle("fmea");
        return { handle: fmeaDir, resolvedFrom: "json/fmea" };
      } catch (_err1) {
        // continue
      }
      try {
        const fmeaDir = await selected.getDirectoryHandle("fmea");
        return { handle: fmeaDir, resolvedFrom: "fmea" };
      } catch (_err2) {
        // continue
      }
      return { handle: selected, resolvedFrom: "(selected folder)" };
    }

    async function saveSetupFile() {
      const payload = buildSetupPayload();
      const stableStem = buildStableAnalysisStem();
      const stem = stableStem.replace(/^analysis_/, "analysis_fmea_setup_");
      const filename = stem + ".json";
      try {
        if (await writeJsonToFmeaDirectory("setup", filename, payload)) {
          setSavedStatus("Saved setup file to json/fmea/setup/" + filename + " (overwrites same PN/REV).");
          refreshSavedFiles();
          return;
        }
      } catch (err) {
        setSavedStatus("Direct setup save failed: " + err.message + ". Downloaded instead.");
      }
      setSavedStatus("Directory save unavailable. Downloaded setup file instead.");
      downloadBlob(filename, JSON.stringify(payload, null, 2), "application/json");
    }

    async function autoSaveLatestAnalysisReport() {
      if (!state.lastOutput) return;
      const stem = buildStableAnalysisStem();
      const jsonName = stem + ".json";
      const mdName = stem + ".md";
      try {
        const okJson = await writeJsonToFmeaDirectory("", jsonName, state.lastOutput);
        const okMd = await writeTextToFmeaDirectory("", mdName, state.lastMarkdown || "");
        if (okJson && okMd) {
          setSavedStatus("Auto-saved analysis report to json/fmea/" + jsonName + " (overwrites same PN/REV).");
          state.outputsExported = true;
          updateWorkflowUi();
          refreshSavedFiles();
          return;
        }
      } catch (err) {
        setSavedStatus("Auto-save failed: " + err.message);
        return;
      }
      setSavedStatus("Auto-save not available until a folder is selected in Saved Analysis.");
    }

    async function selectFmeaDirectory() {
      try {
        if (!window.showDirectoryPicker) {
          setSavedStatus("Directory API unavailable in this browser. Use downloads or provide json/fmea/index.json.");
          return;
        }
        const handle = await window.showDirectoryPicker();
        state.fmeaDirHandle = handle;
        const resolved = await resolveFmeaBaseDirectoryHandle();
        setSavedStatus("Directory selected. Save base resolved as " + (resolved ? resolved.resolvedFrom : "(none)") + " under selected folder.");
        await refreshSavedFiles();
      } catch (err) {
        setSavedStatus("Directory selection cancelled or denied.");
      }
    }

    async function writeJsonToFmeaDirectory(subdir, filename, value) {
      const resolved = await resolveFmeaBaseDirectoryHandle();
      if (!resolved || !resolved.handle) return false;
      const base = resolved.handle;
      const targetDir = subdir ? await base.getDirectoryHandle(subdir, { create: true }) : base;
      const fileHandle = await targetDir.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(value, null, 2));
      await writable.close();
      return true;
    }

    async function writeTextToFmeaDirectory(subdir, filename, text) {
      const resolved = await resolveFmeaBaseDirectoryHandle();
      if (!resolved || !resolved.handle) return false;
      const base = resolved.handle;
      const targetDir = subdir ? await base.getDirectoryHandle(subdir, { create: true }) : base;
      const fileHandle = await targetDir.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(String(text));
      await writable.close();
      return true;
    }

    async function refreshSavedFiles() {
      if (state.fmeaDirHandle) {
        await refreshSavedFilesFromDirectory();
        return;
      }
      await refreshSavedFilesFromIndex();
    }

    async function refreshSavedFilesFromDirectory() {
      const rows = [];
      try {
        const resolved = await resolveFmeaBaseDirectoryHandle();
        if (!resolved || !resolved.handle) throw new Error("No directory selected");
        for await (const [name, handle] of resolved.handle.entries()) {
          if (handle.kind === "file") rows.push({ name, location: "json/fmea", type: "file", source: "dir" });
          if (handle.kind === "directory" && name === "setup") {
            for await (const [sname, sh] of handle.entries()) {
              if (sh.kind === "file") rows.push({ name: sname, location: "json/fmea/setup", type: "setup-file", source: "dir", inSetup: true });
            }
          }
        }
        renderSavedFiles(rows);
        setSavedStatus("Loaded " + rows.length + " saved files from resolved json/fmea base.");
      } catch (err) {
        setSavedStatus("Unable to enumerate selected folder: " + err.message);
      }
    }

    async function refreshSavedFilesFromIndex() {
      try {
        const res = await fetch("json/fmea/index.json?v=" + Date.now(), { cache: "no-store" });
        if (!res.ok) throw new Error("index.json not found");
        const data = await res.json();
        const rows = Array.isArray(data.files) ? data.files.map((f) => ({
          name: String(f.name || ""),
          location: String(f.location || "json/fmea"),
          type: String(f.type || "file"),
          source: "index"
        })) : [];
        renderSavedFiles(rows);
        setSavedStatus("Loaded " + rows.length + " saved files from json/fmea/index.json.");
      } catch (_err) {
        renderSavedFiles([]);
        setSavedStatus("No directory selected and no json/fmea/index.json manifest available.");
      }
    }

    function renderSavedFiles(rows) {
      savedFilesBody.innerHTML = "";
      if (!rows.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 4;
        td.textContent = "No saved analysis files found.";
        tr.appendChild(td);
        savedFilesBody.appendChild(tr);
        return;
      }
      rows.sort((a, b) => String(a.location + "/" + a.name).localeCompare(String(b.location + "/" + b.name)));
      for (const row of rows) {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        tdName.textContent = row.name;
        const tdLoc = document.createElement("td");
        tdLoc.textContent = row.location;
        const tdType = document.createElement("td");
        tdType.textContent = row.type;
        const tdAction = document.createElement("td");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = "Load";
        btn.addEventListener("click", () => loadSavedAnalysisRow(row));
        tdAction.appendChild(btn);
        tr.appendChild(tdName);
        tr.appendChild(tdLoc);
        tr.appendChild(tdType);
        tr.appendChild(tdAction);
        savedFilesBody.appendChild(tr);
      }
    }

    async function loadSavedAnalysisRow(row) {
      try {
        if (state.fmeaDirHandle && row.source === "dir") {
          const resolved = await resolveFmeaBaseDirectoryHandle();
          if (!resolved || !resolved.handle) throw new Error("No resolved base directory");
          const dir = row.inSetup ? await resolved.handle.getDirectoryHandle("setup") : resolved.handle;
          const file = await (await dir.getFileHandle(row.name)).getFile();
          const text = await file.text();
          const parsed = JSON.parse(text);
          renderJsonViewer(outputViewer, parsed, "No JSON output yet.");
          activateTab("results");
          return;
        }
        const path = (row.location || "json/fmea").replace(/\/+$/, "") + "/" + row.name;
        const res = await fetch(path + "?v=" + Date.now(), { cache: "no-store" });
        if (!res.ok) throw new Error("Cannot fetch " + path);
        const parsed = await res.json();
        renderJsonViewer(outputViewer, parsed, "No JSON output yet.");
        activateTab("results");
      } catch (err) {
        setSavedStatus("Load failed: " + err.message);
      }
    }


    function handleFileUpload(event) {
      const files = Array.from(event.target.files || []);
      if (!files.length) {
        return;
      }
      state.inputsValid = false;
      resetRunState();
      const reads = files.map(readJsonFile);
       Promise.all(reads)
         .then((loaded) => {
           state.files = {};
           for (const loadedFile of loaded) {
             state.files[loadedFile.name] = loadedFile.data;
           }
           classifyLoadedFiles();
           validateAndRenderInputs();
         })
        .catch((err) => {
          state.inputsValid = false;
          inputStatus.textContent = "Upload failed: " + err.message;
          refreshFmeaAssumptionUi();
          updateWorkflowUi();
        });
    }

     function readJsonFile(file) {
       return new Promise((resolve, reject) => {
         const reader = new FileReader();
         reader.onerror = () => reject(new Error("Unable to read " + file.name));
         reader.onload = () => {
           try {
             const parsed = JSON.parse(String(reader.result));
             resolve({ name: file.name, data: parsed });
           } catch (err) {
             reject(new Error(file.name + " is not valid JSON."));
           }
         };
         reader.readAsText(file);
       });
     }

    function classifyLoadedFiles() {
      state.netlist = null;
      state.testPlan = null;
      state.partsLibrary = null;
      state.toleranceLibrary = null;
       state.stressRules = null;

      for (const [name, data] of Object.entries(state.files)) {
         const lower = name.toLowerCase();
         if (lower.includes("test_plan")) {
           state.testPlan = data;
           continue;
         }
         if (lower.includes("parts_library")) {
           state.partsLibrary = data;
           continue;
         }
         if (lower.includes("tolerance_library")) {
           state.toleranceLibrary = data;
           continue;
         }
         if (lower.includes("stress_rules")) {
           state.stressRules = data;
           continue;
         }
        if (!state.netlist && looksLikeNetlist(data)) {
          state.netlist = data;
        }
      }
      pruneFmeaOverridesToLoadedComponents();
      refreshFmeaAssumptionUi();
    }

    function pruneFmeaOverridesToLoadedComponents() {
      const valid = new Set((state.netlist && Array.isArray(state.netlist.components))
        ? state.netlist.components.map((c) => c.refdes || "UNASSIGNED")
        : []);
      for (const key of Object.keys(state.fmeaAssumptionOverrides || {})) {
        if (!valid.has(key)) delete state.fmeaAssumptionOverrides[key];
      }
      for (const key of Object.keys(state.fmeaAssumptionOverrides || {})) {
        const componentType = classifyComponent(key);
        const buckets = getFailureModeBucketsForComponent(componentType, key);
        setFailureModeBucketsForComponent(componentType, key, buckets.run, buckets.skip);
      }
      const validTypes = new Set((state.netlist && Array.isArray(state.netlist.components))
        ? state.netlist.components.map((c) => classifyComponent(c.refdes || "UNASSIGNED"))
        : []);
      for (const key of Object.keys(state.fmeaKnowledgeOverrides || {})) {
        const type = String(key).split("::")[0];
        if (!validTypes.has(type)) delete state.fmeaKnowledgeOverrides[key];
      }
    }

     function looksLikeNetlist(data) {
       return !!(data && typeof data === "object" && Array.isArray(data.components));
     }

     function validateAndRenderInputs() {
       const errors = [];
       if (!validateNetlist(state.netlist)) {
         errors.push("Missing required netlist schema fields: schema_version, identity, components[].pins[].net");
       }
       if (state.testPlan && !validateTestPlan(state.testPlan)) {
         errors.push("test_plan.json did not match expected structure.");
       }
       if (state.partsLibrary && !validatePartsLibrary(state.partsLibrary)) {
         errors.push("parts_library.json did not match expected structure.");
       }
       if (state.toleranceLibrary && !validateToleranceLibrary(state.toleranceLibrary)) {
         errors.push("tolerance_library.json did not match expected structure.");
       }
       if (state.stressRules && !validateStressRules(state.stressRules)) {
         errors.push("stress_rules.json did not match expected structure.");
       }

      renderJsonViewer(inputViewer, {
        uploaded_files: Object.keys(state.files),
        detected: {
          netlist: !!state.netlist,
          test_plan: !!state.testPlan,
          parts_library: !!state.partsLibrary,
          tolerance_library: !!state.toleranceLibrary,
          stress_rules: !!state.stressRules
        },
        preview: state.netlist || {}
      }, "No JSON loaded.");


      renderJsonViewer(netGraphViewer, buildNetAdjacencyData(state.netlist), "No netlist loaded.");


      if (errors.length) {
        state.inputsValid = false;
        inputStatus.textContent = "Validation errors: " + errors.join(" | ");
        refreshFmeaAssumptionUi();
        updateWorkflowUi();
        return;
      }

      state.inputsValid = !!state.netlist;
      inputStatus.textContent = "Inputs loaded and validated. Ready to run " + analysisType.value.toUpperCase() + ".";
      refreshFmeaAssumptionUi();
      updateWorkflowUi();
      activateTab("run");
    }

     function validateNetlist(netlist) {
       if (!netlist || typeof netlist !== "object") return false;
       if (!netlist.schema_version || !netlist.identity || !Array.isArray(netlist.components)) return false;
       for (const c of netlist.components) {
         if (!Array.isArray(c.pins)) return false;
         for (const pin of c.pins) {
           if (!pin || typeof pin.net !== "string") return false;
         }
       }
       return true;
     }

     function validateTestPlan(plan) {
       if (!plan || typeof plan !== "object") return false;
       return Array.isArray(plan.tests) || Array.isArray(plan.covered_nets) || Array.isArray(plan.nets);
     }

     function validatePartsLibrary(lib) {
       if (!lib || typeof lib !== "object") return false;
       if (Array.isArray(lib.parts)) return true;
       if (typeof lib.by_refdes === "object") return true;
       return false;
     }

    function validateToleranceLibrary(lib) {
      if (!lib || typeof lib !== "object") return false;
      return Array.isArray(lib.tolerances) || typeof lib.default_tolerance === "number" || typeof lib.by_refdes === "object";
    }

     function validateStressRules(rules) {
       if (!rules || typeof rules !== "object") return false;
       return typeof rules.margin_threshold_percent === "number" || typeof rules.thresholds === "object";
     }

    function runSelectedAnalysis() {
      if (!state.netlist || !state.inputsValid) {
        resultStatus.textContent = "Load a valid netlist first.";
        updateWorkflowUi();
        return;
      }
      const type = analysisType.value;
      const analyzer = analyzers[type];
      if (!analyzer) {
        resultStatus.textContent = "Unknown analysis type: " + type;
        updateWorkflowUi();
        return;
      }
      resetRunState();
       const base = {
         analysis_engine_version: ENGINE_VERSION,
         analysis_type: type,
         generated_on: new Date().toISOString(),
         board_pn: safeGet(state.netlist, ["identity", "board_pn"], "unknown_board"),
         board_rev: safeGet(state.netlist, ["identity", "board_rev"], "unknown_rev")
       };
       const coverageResult = runCoverage(state.netlist, state.testPlan).result;
       const analysis = analyzer(state.netlist, state.testPlan, state.partsLibrary, state.toleranceLibrary, state.stressRules, coverageResult);
      state.lastAnalysisType = type;
      state.lastOutput = Object.assign({}, base, analysis.result);
      state.lastMarkdown = analysis.markdown;
      state.outputsExported = false;
      renderJsonViewer(outputViewer, state.lastOutput, "No JSON output yet.");
      renderAnalysis(analysis);
      renderResultsInsights();
      resultStatus.textContent = "Completed " + type.toUpperCase() + " with deterministic engine v" + ENGINE_VERSION + ".";
      autoSaveLatestAnalysisReport();
      updateWorkflowUi();
      activateTab("results");
    }

     function runFMEA(netlist, testPlan, _partsLibrary, _toleranceLibrary, _stressRules, coverageResult) {
       const netCoverage = (coverageResult && coverageResult.coverage_map) || {};
       const rows = [];
       const netToRefs = buildNetToRefsMap(netlist);
       const components = Array.isArray(netlist.components) ? netlist.components : [];

      for (const component of components) {
        const componentClass = classifyComponent(component.refdes);
        const failures = getFailureModesForComponent(componentClass, component.refdes || "UNASSIGNED");
        const nets = extractComponentNets(component);
         const affectedComponents = dedupe(nets.flatMap((net) => netToRefs[net] || []).filter((ref) => ref !== component.refdes));
         const affectedInterfacePins = nets.filter(isInterfaceNet);


        for (const mode of failures) {
          const knowledge = getFailureModeKnowledge(componentClass, mode);
          const severity = computeSeverity(nets);
          const occurrence = occurrenceByClass[componentClass] || occurrenceByClass.other;
          const detection = nets.some((n) => netCoverage[n]) ? detectionCovered : detectionUncovered;
          const rpn = severity * occurrence * detection;
          rows.push({
            component: component.refdes || "UNASSIGNED",
            failure_mode: mode,
            failure_effect: knowledge.description || "",
            propagation_1: knowledge.l1 || "",
            propagation_2: knowledge.l2 || "",
            affected_nets: nets,
            affected_components: affectedComponents,
            affected_interface_pins: affectedInterfacePins,
            severity,
             occurrence,
             detection,
             RPN: rpn,
             coverage_status: detection === detectionCovered ? "covered" : "uncovered"
           });
         }
       }

       rows.sort((a, b) => b.RPN - a.RPN || String(a.component).localeCompare(String(b.component)));
       const summary = {
         entries: rows.length,
         high_risk_count: rows.filter((r) => r.RPN >= 200).length,
         average_rpn: rows.length ? Number((rows.reduce((acc, r) => acc + r.RPN, 0) / rows.length).toFixed(2)) : 0
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.slice(0, 20).map((r) => ({
           component: r.component,
           failure_mode: r.failure_mode,
           RPN: r.RPN,
           coverage_status: r.coverage_status
         })),
         summary,
         result: { fmea: rows, summary },
         markdown: buildMarkdown("FMEA", rows, summary, ["component", "failure_mode", "severity", "occurrence", "detection", "RPN", "coverage_status"])
       };
     }

    function runEPSA(netlist, _testPlan, partsLibrary, _toleranceLibrary, stressRules) {
      const partsMap = buildPartsMap(partsLibrary);
      // Fixed deterministic EPSA threshold now that Setup option control was removed.
      // If changed, keep `FIXED_EPSA_MARGIN_THRESHOLD_PERCENT` and setup serialization in sync.
      const threshold = toNumber(FIXED_EPSA_MARGIN_THRESHOLD_PERCENT, safeGet(stressRules, ["margin_threshold_percent"], 20));
       const rows = [];
       const components = Array.isArray(netlist.components) ? netlist.components : [];

       for (const component of components) {
         const info = partsMap[component.refdes] || {};
         const componentClass = classifyComponent(component.refdes);
         const ratingVoltage = toNumber(info.voltage_rating, componentClass === "transistor" ? 40 : 16);
         const ratingCurrent = toNumber(info.current_rating, componentClass === "connector" ? 1 : 0.2);
         const ratingPower = toNumber(info.power_rating, componentClass === "resistor" ? 0.25 : 0.5);
         const nets = extractComponentNets(component);
         const vActual = estimateComponentVoltage(netlist, nets);
         const iActual = estimateComponentCurrent(componentClass, vActual, component.value);
         const pActual = componentClass === "resistor" ? computeResistorPower(vActual, component.value) : vActual * iActual;

         rows.push(buildStressRow(component.refdes, "voltage", vActual, ratingVoltage, threshold));
         rows.push(buildStressRow(component.refdes, "current", iActual, ratingCurrent, threshold));
         rows.push(buildStressRow(component.refdes, "power", pActual, ratingPower, threshold));
       }

       const summary = {
         entries: rows.length,
         pass_count: rows.filter((r) => r.status === "pass").length,
         warn_count: rows.filter((r) => r.status === "warn").length,
         fail_count: rows.filter((r) => r.status === "fail").length
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.filter((r) => r.status !== "pass"),
         summary,
         result: { epsa: rows, summary },
         markdown: buildMarkdown("EPSA", rows, summary, ["component", "parameter", "actual", "rating", "margin_percent", "status"])
       };
     }

     function runWCCA(netlist, _testPlan, _partsLibrary, toleranceLibrary) {
       const tolerances = buildToleranceMap(toleranceLibrary);
       const rows = [];
       const components = Array.isArray(netlist.components) ? netlist.components : [];

       for (const component of components) {
         if (classifyComponent(component.refdes) !== "resistor") continue;
         const nominal = parseResistance(component.value);
         if (!Number.isFinite(nominal) || nominal <= 0) continue;
         const tol = toNumber(tolerances[component.refdes], toNumber(tolerances.default, 0.05));
         const high = nominal * (1 + tol);
         const low = nominal * (1 - tol);
         const deviation = tol * 100;
         rows.push({
           network: component.refdes,
           nominal_value: round4(nominal),
           worst_case_high: round4(high),
           worst_case_low: round4(low),
           deviation_percent: round2(deviation),
           margin_status: deviation <= 5 ? "good" : deviation <= 10 ? "watch" : "critical"
         });
       }

       const summary = {
         entries: rows.length,
         avg_deviation_percent: rows.length ? round2(rows.reduce((a, r) => a + r.deviation_percent, 0) / rows.length) : 0,
         critical_count: rows.filter((r) => r.margin_status === "critical").length
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.filter((r) => r.margin_status !== "good"),
         summary,
         result: { wcca: rows, summary },
         markdown: buildMarkdown("WCCA", rows, summary, ["network", "nominal_value", "worst_case_high", "worst_case_low", "deviation_percent", "margin_status"])
       };
     }

     function runCoverage(netlist, testPlan) {
       const nets = dedupe((netlist.components || []).flatMap((c) => extractComponentNets(c)));
       const covered = extractCoveredNets(testPlan);
       const coverageMap = {};
       for (const net of nets) coverageMap[net] = covered.has(net);
       const total = nets.length;
       const coveredCount = nets.filter((n) => coverageMap[n]).length;
       const criticalNets = nets.filter((n) => isPowerNet(n) || isBiasNet(n) || isInterfaceNet(n));
       const criticalCovered = criticalNets.filter((n) => coverageMap[n]).length;

       const tpByNet = {};
       for (const component of netlist.components || []) {
         if (!isTestPoint(component.refdes)) continue;
         for (const net of extractComponentNets(component)) {
           tpByNet[net] = (tpByNet[net] || 0) + 1;
         }
       }

       const rows = nets.map((net) => ({
         net,
         covered: coverageMap[net],
         critical: criticalNets.includes(net),
         test_points: tpByNet[net] || 0,
         redundancy_status: (tpByNet[net] || 0) <= 1 ? "single-point-risk" : "redundant"
       }));


       const summary = {
         total_nets: total,
         covered_nets: coveredCount,
         net_coverage_percent: total ? round2((coveredCount / total) * 100) : 0,
         critical_net_coverage_percent: criticalNets.length ? round2((criticalCovered / criticalNets.length) * 100) : 0
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.filter((r) => r.redundancy_status !== "redundant"),
         summary,
         result: { coverage: rows, summary, coverage_map: coverageMap },
         markdown: buildMarkdown("Coverage", rows, summary, ["net", "covered", "critical", "test_points", "redundancy_status"])
       };
     }

     function renderAnalysis(analysis) {
       renderTable("primary", analysis.primaryRows || []);
       renderTable("secondary", analysis.secondaryRows || []);
       renderSummary(analysis.summary || {});
     }

     function renderTable(which, rows) {
       const head = which === "primary" ? resultsHead : secondaryHead;
       const body = which === "primary" ? resultsBody : secondaryBody;
       head.innerHTML = "";
       body.innerHTML = "";
       if (!rows.length) {
         const tr = document.createElement("tr");
         const td = document.createElement("td");
         td.textContent = "No rows.";
         tr.appendChild(td);
         body.appendChild(tr);
         return;
       }
       const keys = Object.keys(rows[0]);
       for (const key of keys) {
         const th = document.createElement("th");
         th.textContent = key;
         th.addEventListener("click", () => {
           const direction = sortState.key === key && sortState.table === which ? -sortState.direction : 1;
           sortState = { key, direction, table: which };
           rows.sort((a, b) => compareValues(a[key], b[key]) * direction);
           renderTable(which, rows);
         });
         head.appendChild(th);
       }

       for (const row of rows) {
         const tr = document.createElement("tr");
         for (const key of keys) {
           const td = document.createElement("td");
           const value = row[key];
           td.textContent = Array.isArray(value) ? value.join(", ") : String(value);
           applyCellColor(td, key, value);
           tr.appendChild(td);
         }
         body.appendChild(tr);
       }
     }

     function applyCellColor(td, key, value) {
       const lowerKey = String(key).toLowerCase();
       const lowerValue = String(value).toLowerCase();
       if (lowerKey === "rpn") {
         const n = Number(value);
         if (n >= 250) td.classList.add("status-bad");
         else if (n >= 120) td.classList.add("status-warn");
         else td.classList.add("status-ok");
       }
      if (lowerKey.includes("coverage") || lowerKey === "covered") {
        if (lowerValue === "true" || lowerValue === "covered" || Number(value) >= 80) td.classList.add("status-ok");
        else td.classList.add("status-warn");
      }
       if (lowerKey === "status" || lowerKey.endsWith("status")) {
         if (lowerValue === "pass" || lowerValue === "good" || lowerValue === "redundant") td.classList.add("status-ok");
         else if (lowerValue === "warn" || lowerValue === "watch") td.classList.add("status-warn");
         else td.classList.add("status-bad");
       }
     }

     function renderSummary(summary) {
       summaryGrid.innerHTML = "";
       for (const [k, v] of Object.entries(summary)) {
         const item = document.createElement("div");
         item.className = "metric";
         item.innerHTML = '<span class="k">' + k + '</span><span class="v">' + v + "</span>";
         summaryGrid.appendChild(item);
       }
     }

    function exportResults() {
      if (!state.lastOutput || !state.lastAnalysisType) return;
      const stem = buildStableAnalysisStem();
      const jsonName = stem + ".json";
      const mdName = stem + ".md";
      (async () => {
        let savedDirect = false;
        try {
          const okJson = await writeJsonToFmeaDirectory("", jsonName, state.lastOutput);
          const okMd = await writeTextToFmeaDirectory("", mdName, state.lastMarkdown || "");
          savedDirect = okJson && okMd;
        } catch (_err) {
          savedDirect = false;
        }
        if (!savedDirect) {
          downloadBlob(jsonName, JSON.stringify(state.lastOutput, null, 2), "application/json");
          downloadBlob(mdName, state.lastMarkdown, "text/markdown");
          setSavedStatus("Direct result save unavailable. Downloaded files instead.");
        } else {
          setSavedStatus("Saved result files to json/fmea/" + jsonName + " and .md pair (overwrites same PN/REV).");
          refreshSavedFiles();
        }
        state.outputsExported = true;
        updateWorkflowUi();
      })();
    }

    function saveResultsFile() {
      if (!state.lastOutput || !state.lastAnalysisType) return;
      autoSaveLatestAnalysisReport();
    }

     function downloadBlob(filename, content, mime) {
       const blob = new Blob([content], { type: mime });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       a.download = filename;
       document.body.appendChild(a);
       a.click();
       a.remove();
       URL.revokeObjectURL(url);
     }

     function buildMarkdown(title, rows, summary, columns) {
       const lines = [];
       lines.push("# " + title + " Report");
       lines.push("");
       lines.push("Engine Version: " + ENGINE_VERSION);
       lines.push("Generated On: " + new Date().toISOString());
       lines.push("");
       lines.push("## Summary");
       for (const [k, v] of Object.entries(summary)) {
         lines.push("- " + k + ": " + v);
       }
       lines.push("");
       lines.push("## Results");
       if (!rows.length) {
         lines.push("No rows.");
         return lines.join("\n");
       }
       lines.push("| " + columns.join(" | ") + " |");
       lines.push("| " + columns.map(() => "---").join(" | ") + " |");
       const maxRows = Math.min(rows.length, 500);
       for (let i = 0; i < maxRows; i += 1) {
         const row = rows[i];
         const cells = columns.map((col) => {
           const value = row[col];
           if (Array.isArray(value)) return value.join(", ");
           return String(value);
         });
         lines.push("| " + cells.join(" | ") + " |");
       }
       if (title === "FMEA") {
         lines.push("");
         lines.push("## Failure Effects");
         for (let i = 0; i < maxRows; i += 1) {
           const row = rows[i];
           const component = String(row.component || "UNASSIGNED");
           const mode = String(row.failure_mode || "unknown_mode");
           const effect = String(row.failure_effect || "");
           const p1 = String(row.propagation_1 || "");
           const p2 = String(row.propagation_2 || "");
           lines.push("");
           lines.push("### Component: " + component);
           lines.push("#### Failure Mode: " + mode);
           lines.push("##### Failure Effect");
           lines.push(effect || "(none)");
           lines.push("##### Propagation 1");
           lines.push(p1 || "(none)");
           lines.push("##### Propagation 2");
           lines.push(p2 || "(none)");
         }
       }
       return lines.join("\n");
     }

     function buildPartsMap(partsLibrary) {
       const map = {};
       if (!partsLibrary || typeof partsLibrary !== "object") return map;
       if (partsLibrary.by_refdes && typeof partsLibrary.by_refdes === "object") {
         return Object.assign({}, partsLibrary.by_refdes);
       }
       if (Array.isArray(partsLibrary.parts)) {
         for (const part of partsLibrary.parts) {
           if (part && part.refdes) map[part.refdes] = part;
         }
       }
       return map;
     }

     function buildToleranceMap(toleranceLibrary) {
       const map = {};
       if (!toleranceLibrary || typeof toleranceLibrary !== "object") {
         map.default = 0.05;
         return map;
       }
       if (typeof toleranceLibrary.default_tolerance === "number") {
         map.default = toleranceLibrary.default_tolerance;
       } else {
         map.default = 0.05;
       }
       if (Array.isArray(toleranceLibrary.tolerances)) {
         for (const t of toleranceLibrary.tolerances) {
           if (t && t.refdes && typeof t.tolerance === "number") map[t.refdes] = t.tolerance;
         }
       }
       if (toleranceLibrary.by_refdes && typeof toleranceLibrary.by_refdes === "object") {
         for (const [k, v] of Object.entries(toleranceLibrary.by_refdes)) {
           map[k] = Number(v);
         }
       }
       return map;
     }

     function buildStressRow(component, parameter, actual, rating, threshold) {
       const margin = rating === 0 ? -100 : ((rating - actual) / rating) * 100;
       const status = margin < 0 ? "fail" : margin < threshold ? "warn" : "pass";
       return {
         component,
         parameter,
         actual: round4(actual),
         rating: round4(rating),
         margin_percent: round2(margin),
         status
       };
     }

     function buildNetToRefsMap(netlist) {
       const map = {};
       for (const component of netlist.components || []) {
         const ref = component.refdes || "UNASSIGNED";
         for (const net of extractComponentNets(component)) {
           if (!map[net]) map[net] = [];
           map[net].push(ref);
         }
       }
       return map;
     }

    function buildNetAdjacencyData(netlist) {
      if (!netlist || !Array.isArray(netlist.components)) return null;
      const netToRefs = buildNetToRefsMap(netlist);
      const nets = Object.keys(netToRefs).sort();
      const adjacency = {};
      for (const net of nets.slice(0, 120)) adjacency[net] = dedupe(netToRefs[net]);
      return {
        net_count: nets.length,
        truncated: nets.length > 120,
        adjacency
      };
    }

    function renderJsonValueTree(value, keyLabel, depth) {
      const entry = document.createElement("div");
      entry.className = "jsonEntry";
      if (keyLabel) {
        const key = document.createElement("span");
        key.className = "jsonBubble jsonKeyBubble";
        key.textContent = keyLabel;
        entry.appendChild(key);
      }

      const appendPrimitive = (primitive, cls) => {
        const bubble = document.createElement("span");
        bubble.className = "jsonBubble jsonValBubble " + cls;
        bubble.textContent = primitive === null ? "null" : String(primitive);
        entry.appendChild(bubble);
      };

      if (depth > 7) {
        appendPrimitive("max depth reached", "type-object");
        return entry;
      }

      if (value === null) {
        appendPrimitive(null, "type-null");
        return entry;
      }
      if (typeof value === "number") {
        appendPrimitive(value, "type-number");
        return entry;
      }
      if (typeof value === "boolean") {
        appendPrimitive(value, "type-boolean");
        return entry;
      }
      if (typeof value !== "object") {
        appendPrimitive(value, "type-string");
        return entry;
      }

      const child = document.createElement("div");
      child.className = "jsonChild";
      if (Array.isArray(value)) {
        if (!value.length) {
          appendPrimitive("empty list", "type-object");
          return entry;
        }
        value.slice(0, 250).forEach((item, idx) => child.appendChild(renderJsonValueTree(item, "item " + (idx + 1), depth + 1)));
        if (value.length > 250) child.appendChild(renderJsonValueTree("truncated", "more", depth + 1));
      } else {
        const keys = Object.keys(value);
        if (!keys.length) {
          appendPrimitive("empty object", "type-object");
          return entry;
        }
        keys.slice(0, 250).forEach((k) => child.appendChild(renderJsonValueTree(value[k], k, depth + 1)));
        if (keys.length > 250) child.appendChild(renderJsonValueTree("truncated", "more", depth + 1));
      }
      entry.appendChild(child);
      return entry;
    }

    function renderJsonViewer(container, value, emptyText) {
      if (!container) return;
      container.innerHTML = "";
      if (value === null || value === undefined) {
        container.classList.add("jsonStatus");
        container.textContent = emptyText || "No JSON loaded.";
        return;
      }
      const tree = document.createElement("div");
      tree.className = "jsonTree";
      tree.appendChild(renderJsonValueTree(value, "root", 0));
      container.classList.remove("jsonStatus");
      container.appendChild(tree);
    }

     function extractCoveredNets(testPlan) {
       const set = new Set();
       if (!testPlan || typeof testPlan !== "object") return set;

       if (Array.isArray(testPlan.covered_nets)) {
         for (const net of testPlan.covered_nets) {
           if (typeof net === "string") set.add(net);
         }
       }

       if (Array.isArray(testPlan.nets)) {
         for (const net of testPlan.nets) {
           if (typeof net === "string") set.add(net);
         }
       }

       if (Array.isArray(testPlan.tests)) {
         for (const test of testPlan.tests) {
           if (!test || typeof test !== "object") continue;
           const candidates = [].concat(test.nets || [], test.covered_nets || [], test.affected_nets || []);
           for (const net of candidates) {
             if (typeof net === "string") set.add(net);
           }
         }
       }
       return set;
     }

     function extractComponentNets(component) {
       const nets = [];
       for (const pin of component.pins || []) {
         if (pin && typeof pin.net === "string") nets.push(pin.net);
       }
       return dedupe(nets);
     }

     function computeSeverity(nets) {
       let max = 4;
       for (const net of nets) {
         if (isInterfaceNet(net)) max = Math.max(max, 9);
         else if (isPowerNet(net)) max = Math.max(max, 8);
         else if (isBiasNet(net)) max = Math.max(max, 7);
         else max = Math.max(max, 5);
       }
       return max;
     }

    function classifyComponent(refdes) {
      const r = String(refdes || "").toUpperCase();
      if (isTestPoint(r)) return "test_point";
      if (r.startsWith("R")) return "resistor";
      if (r.startsWith("C")) return "capacitor";
      if (r.startsWith("Q")) return "transistor";
      if (r.startsWith("D")) return "diode";
      if (r.startsWith("L")) return "inductor";
      if (r.startsWith("U") || r.startsWith("IC")) return "integrated_circuit";
      if (r.startsWith("S")) return "switch";
      if (r.startsWith("F")) return "fuse";
      if (r.startsWith("K")) return "relay";
      if (r.startsWith("T")) return "transformer";
      if (r.startsWith("X")) return "crystal";
      if (r.startsWith("B")) return "sensor";
      if (r.startsWith("J") || r.startsWith("P")) return "connector";
      return "other";
    }

     function isTestPoint(refdes) {
       const r = String(refdes || "").toUpperCase();
       return r.startsWith("TP") || r.includes("TEST");
     }

     function isPowerNet(net) {
       const n = String(net || "").toUpperCase();
       return n === "V+" || n === "VCC" || n === "VBAT" || n === "GND" || n.includes("POWER");
     }

     function isBiasNet(net) {
       const n = String(net || "").toUpperCase();
       return n.includes("BIAS") || n.includes("BASE");
     }

     function isInterfaceNet(net) {
       const n = String(net || "").toUpperCase();
       return n.includes("INPUT") || n.includes("OUTPUT") || n.includes("INTERFACE") || n.startsWith("IO");
     }

     function estimateComponentVoltage(netlist, nets) {
       const levels = nets.map((net) => estimateNetVoltage(netlist, net)).filter((x) => Number.isFinite(x));
       if (!levels.length) return 0;
       if (levels.length === 1) return levels[0];
       const max = Math.max.apply(null, levels);
       const min = Math.min.apply(null, levels);
       return Math.abs(max - min);
     }

     function estimateNetVoltage(netlist, net) {
       const n = String(net || "").toUpperCase();
       if (n === "GND") return 0;
       if (n === "V+" || n === "VCC") return 12;
       if (isInterfaceNet(n)) return 5;
       const byMeta = safeGet(netlist, ["net_metadata", net, "nominal_voltage"], null);
       if (typeof byMeta === "number") return byMeta;
       return 1;
     }

     function estimateComponentCurrent(componentClass, voltage, value) {
       if (componentClass === "resistor") {
         const r = parseResistance(value);
         if (r > 0) return voltage / r;
       }
       if (componentClass === "connector") return Math.max(0.01, voltage / 100);
       if (componentClass === "transistor") return Math.max(0.002, voltage / 1000);
       return Math.max(0.001, voltage / 2000);
     }

     function computeResistorPower(voltage, value) {
       const r = parseResistance(value);
       if (!Number.isFinite(r) || r <= 0) return 0;
       return (voltage * voltage) / r;
     }

     function parseResistance(raw) {
       if (typeof raw === "number") return raw;
       const v = String(raw || "").trim().toLowerCase();
       if (!v) return NaN;
       if (/^\d+(\.\d+)?$/.test(v)) return Number(v);
       const normalized = v.replace(",", ".");
       const match = normalized.match(/^(\d+(\.\d+)?)([kmun]?)(\d+)?$/);
       if (!match) return NaN;
       const lead = Number(match[1] || "0");
       const suffix = match[3] || "";
       const tail = match[4] || "";
       let value = lead;
       if (tail) value = Number(String(lead) + "." + tail);
       const scale = suffix === "m" ? 1e6 : suffix === "k" ? 1e3 : suffix === "u" ? 1e-6 : suffix === "n" ? 1e-9 : 1;
       return value * scale;
     }

     function compareValues(a, b) {
       const na = Number(a);
       const nb = Number(b);
       if (Number.isFinite(na) && Number.isFinite(nb)) return na - nb;
       return String(a).localeCompare(String(b));
     }

     function safeGet(obj, path, fallback) {
       let cur = obj;
       for (const key of path) {
         if (!cur || typeof cur !== "object" || !(key in cur)) return fallback;
         cur = cur[key];
       }
       return cur;
     }

     function safeFilePart(v) {
       return String(v || "unknown").replace(/[^a-z0-9_.-]/gi, "_");
     }

    function dedupe(arr) {
      return Array.from(new Set(arr));
    }

    function arraysEqual(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
      for (let i = 0; i < a.length; i += 1) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

     function toNumber(v, fallback) {
       const n = Number(v);
       return Number.isFinite(n) ? n : fallback;
     }

     function round2(n) {
       return Math.round(Number(n) * 100) / 100;
     }

     function round4(n) {
       return Math.round(Number(n) * 10000) / 10000;
     }

    function resetRunState() {
      state.lastAnalysisType = null;
      state.lastOutput = null;
      state.lastMarkdown = "";
      state.outputsExported = false;
      renderJsonViewer(outputViewer, null, "No JSON output yet.");
      resultsHead.innerHTML = "";
      resultsBody.innerHTML = "";
      secondaryHead.innerHTML = "";
      secondaryBody.innerHTML = "";
      summaryGrid.innerHTML = "";
      applyFixedUiDefaults();
      updateWorkflowUi();
    }
   </script>
</body>
</html>
