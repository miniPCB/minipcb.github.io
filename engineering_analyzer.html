<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Engineering Analyzer</title>
   <style>
     :root {
       --bg: #0e1118;
       --panel: #151b25;
       --panel-2: #1b2330;
       --text: #e8edf5;
       --muted: #98a7bb;
       --accent: #2f88ff;
       --accent-2: #37c3ff;
       --border: #2d3a4d;
       --ok: #2ecc71;
       --warn: #f1c40f;
       --bad: #ff5757;
       --shadow: 0 8px 28px rgba(0, 0, 0, 0.35);
       --mono: "Consolas", "Courier New", monospace;
       --sans: "Segoe UI", "Trebuchet MS", sans-serif;
     }

     * { box-sizing: border-box; }

     body {
       margin: 0;
       font-family: var(--sans);
       color: var(--text);
       background:
         radial-gradient(circle at 20% 0%, #1b2434 0%, transparent 50%),
         radial-gradient(circle at 90% 100%, #132036 0%, transparent 45%),
         var(--bg);
       min-height: 100vh;
     }

     .page {
       max-width: 1400px;
       margin: 0 auto;
       padding: 20px;
     }

    .title {
      margin: 0 0 16px;
      font-size: 1.45rem;
      letter-spacing: 0.02em;
    }

    .tabbar {
      display: grid;
      grid-template-columns: repeat(5, minmax(150px, 1fr));
      gap: 8px;
      margin-bottom: 12px;
    }

    .tab-button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #131b27;
      color: var(--text);
      padding: 10px;
      text-align: left;
      min-height: 62px;
      cursor: pointer;
    }

    .tab-button .tab-title {
      display: block;
      font-size: 0.82rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
      margin-bottom: 3px;
    }

    .tab-button .tab-state {
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--muted);
    }

    .tab-button.active {
      border-color: var(--accent);
      background: linear-gradient(180deg, #1b2a3f, #141e2d);
      box-shadow: inset 0 0 0 1px rgba(47, 136, 255, 0.2);
    }

    .tab-button.state-ready .tab-state { color: var(--warn); }
    .tab-button.state-done .tab-state { color: var(--ok); }
    .tab-button.state-locked { opacity: 0.65; cursor: not-allowed; }

    .tab-panel {
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 12px;
      margin-bottom: 12px;
    }

    .tab-panel.hidden { display: none; }

    .control-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }

    .control-group {
      display: grid;
      gap: 6px;
      align-content: start;
    }

    .control-label {
      font-size: 0.78rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      padding-left: 2px;
    }

    .inline-option {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      align-items: center;
    }

    .inline-option input[type="number"] {
      border: 1px solid var(--border);
      background: #1e2837;
      color: var(--text);
      border-radius: 8px;
      min-height: 42px;
      padding: 0 10px;
      width: 100%;
    }

    .checkline {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 0.82rem;
      padding-left: 2px;
    }

    .fmea-assumptions {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #121a25;
      padding: 10px;
    }

    .fmea-assumptions h3 {
      margin: 0 0 8px;
      font-size: 0.96rem;
    }

    .assumption-note {
      margin: 0 0 10px;
      color: var(--muted);
      font-size: 0.84rem;
    }

    .assumption-table textarea {
      width: 100%;
      min-height: 72px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #1a2332;
      color: var(--text);
      padding: 7px 8px;
      font-family: var(--mono);
      font-size: 0.79rem;
      resize: vertical;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    .detail-grid select,
    .detail-grid textarea {
      width: 100%;
    }

    .detail-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .saved-table button {
      min-height: 30px;
      padding: 0 8px;
      font-size: 0.8rem;
    }

    .assumption-board {
      display: grid;
      gap: 10px;
      padding: 10px;
    }

    .assumption-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #101823;
      padding: 10px;
    }

    .assumption-card-head {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .assumption-chip {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 3px 9px;
      font-size: 0.78rem;
      border: 1px solid var(--border);
      background: #1a2638;
      color: var(--text);
    }

    .assumption-chip.ref { border-color: rgba(102,163,255,.45); color: #c6e3ff; background: rgba(102,163,255,.18); }
    .assumption-chip.type { border-color: rgba(123,220,181,.45); color: #c8ffe2; background: rgba(123,220,181,.15); }
    .assumption-chip.src { border-color: rgba(255,211,124,.45); color: #ffeec3; background: rgba(255,211,124,.15); }

    .bucket-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .bucket {
      border: 1px dashed var(--border);
      border-radius: 10px;
      min-height: 82px;
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-content: flex-start;
      transition: border-color .15s ease, background .15s ease;
    }

    .bucket h4 {
      margin: 0 0 5px;
      width: 100%;
      font-size: 0.8rem;
      color: var(--muted);
      font-weight: 600;
    }

    .bucket.run {
      background: rgba(46,204,113,0.08);
      border-color: rgba(46,204,113,0.45);
    }

    .bucket.skip {
      background: rgba(255,87,87,0.08);
      border-color: rgba(255,87,87,0.45);
    }

    .bucket.drag-over {
      border-style: solid;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.18);
    }

    .mode-pill {
      border: 1px solid rgba(46,204,113,.5);
      color: #d6ffe8;
      background: rgba(46,204,113,.2);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      line-height: 1.2;
      cursor: grab;
      user-select: none;
    }

    .mode-pill.skip {
      border-color: rgba(255,87,87,.5);
      color: #ffd8d8;
      background: rgba(255,87,87,.2);
    }

    .mode-pill:active { cursor: grabbing; }

     button,
     select {
       border: 1px solid var(--border);
       background: #1e2837;
       color: var(--text);
       border-radius: 8px;
       min-height: 42px;
       padding: 0 12px;
       font-size: 0.95rem;
       cursor: pointer;
     }

     button:hover, select:hover { border-color: #496287; }
     button:disabled { opacity: 0.5; cursor: not-allowed; }

     .content {
       display: grid;
       grid-template-columns: minmax(320px, 38%) minmax(420px, 62%);
       gap: 12px;
       align-items: start;
     }

     .panel {
       border: 1px solid var(--border);
       background: var(--panel);
       border-radius: 12px;
       box-shadow: var(--shadow);
       overflow: hidden;
     }

     .panel h2 {
       margin: 0;
       padding: 10px 12px;
       font-size: 1rem;
       border-bottom: 1px solid var(--border);
       background: #1a2230;
     }

     .panel-body { padding: 10px; }

     details {
       border: 1px solid var(--border);
       border-radius: 8px;
       margin-bottom: 10px;
       overflow: hidden;
       background: #121a25;
     }

     summary {
       cursor: pointer;
       padding: 10px 12px;
       user-select: none;
       font-weight: 600;
       background: #182231;
     }

    pre {
      margin: 0;
      padding: 10px;
      white-space: pre;
      overflow: auto;
       max-height: 320px;
       font-size: 0.8rem;
       font-family: var(--mono);
       background: #0f151f;
      border-top: 1px solid var(--border);
    }

    .jsonViewport{
      border-top: 1px solid var(--border);
      background: rgba(15,20,30,0.45);
      overflow:auto;
      min-height:220px;
      max-height:360px;
      padding:10px;
      border-radius:0 0 8px 8px;
    }

    .jsonStatus{
      color: var(--muted);
      font-size: 0.84rem;
      display: flex;
      align-items: center;
    }

    .jsonTree{
      display:flex;
      flex-direction:column;
      gap:8px;
      font-family: var(--mono);
      font-size:12px;
    }

    .jsonEntry{
      display:flex;
      align-items:flex-start;
      gap:6px;
      flex-wrap:wrap;
    }

    .jsonChild{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-left:10px;
      border-left:1px dashed rgba(102,163,255,0.3);
      padding-left:10px;
      min-width:0;
      flex:1;
    }

    .jsonBubble{
      display:inline-flex;
      align-items:center;
      border-radius:999px;
      padding:3px 9px;
      line-height:1.2;
      max-width:100%;
      word-break:break-word;
      white-space:normal;
    }

    .jsonKeyBubble{
      background: rgba(102,163,255,0.18);
      border:1px solid rgba(102,163,255,0.45);
      color: #c6e3ff;
      font-weight:600;
    }

    .jsonValBubble{
      background: rgba(123,220,181,0.15);
      border:1px solid rgba(123,220,181,0.45);
      color: #c8ffe2;
    }

    .jsonValBubble.type-number{
      background: rgba(255,211,124,0.15);
      border-color: rgba(255,211,124,0.45);
      color: #ffeec3;
    }

    .jsonValBubble.type-boolean{
      background: rgba(206,160,255,0.15);
      border-color: rgba(206,160,255,0.45);
      color: #f0deff;
    }

    .jsonValBubble.type-null{
      background: rgba(255,123,123,0.15);
      border-color: rgba(255,123,123,0.45);
      color: #ffd6d6;
    }

    .jsonValBubble.type-object{
      background: rgba(111,181,255,0.15);
      border-color: rgba(111,181,255,0.45);
      color: #d8ebff;
    }

     .table-wrap {
       overflow: auto;
       border: 1px solid var(--border);
       border-radius: 8px;
       max-height: 330px;
       margin-bottom: 10px;
     }

     table {
       width: 100%;
       border-collapse: collapse;
       font-size: 0.86rem;
     }

     th, td {
       padding: 8px 9px;
       border-bottom: 1px solid #283447;
       text-align: left;
       vertical-align: top;
     }

     th {
       position: sticky;
       top: 0;
       background: #1a2535;
       cursor: pointer;
       white-space: nowrap;
     }

     tr:hover td { background: #152132; }

     .summary-grid {
       display: grid;
       grid-template-columns: repeat(3, minmax(120px, 1fr));
       gap: 10px;
     }

     .metric {
       border: 1px solid var(--border);
       border-radius: 8px;
       background: #121c2a;
       padding: 8px 10px;
     }

     .metric .k {
       display: block;
       color: var(--muted);
       font-size: 0.76rem;
       margin-bottom: 4px;
     }

     .metric .v {
       font-weight: 700;
       font-size: 1.05rem;
     }

     .status-ok { color: var(--ok); font-weight: 700; }
     .status-warn { color: var(--warn); font-weight: 700; }
     .status-bad { color: var(--bad); font-weight: 700; }
     .muted { color: var(--muted); }

     .hint {
       margin: 0;
       padding: 0 2px 10px;
       font-size: 0.86rem;
       color: var(--muted);
     }

     .hidden { display: none; }

    @media (max-width: 1200px) {
      .tabbar { grid-template-columns: 1fr 1fr; }
      .control-panel { grid-template-columns: 1fr 1fr; }
    }

    @media (max-width: 860px) {
      .tabbar { grid-template-columns: 1fr; }
      .control-panel { grid-template-columns: 1fr; }
      .content { grid-template-columns: 1fr; }
    }
   </style>
</head>
<body>
   <div class="page">
     <h1 class="title">Engineering Analyzer v0.1</h1>

    <section class="tabbar">
      <button id="tabInputsBtn" class="tab-button active state-ready" type="button" data-tab="inputs">
        <span class="tab-title">Load Inputs</span>
        <span id="tabInputsState" class="tab-state">Ready</span>
      </button>
      <button id="tabSetupBtn" class="tab-button state-done" type="button" data-tab="setup">
        <span class="tab-title">Setup Analysis</span>
        <span id="tabSetupState" class="tab-state">Done</span>
      </button>
      <button id="tabRunBtn" class="tab-button state-locked" type="button" data-tab="run" disabled>
        <span class="tab-title">Run Analysis</span>
        <span id="tabRunState" class="tab-state">Locked</span>
      </button>
      <button id="tabResultsBtn" class="tab-button state-locked" type="button" data-tab="results" disabled>
        <span class="tab-title">Review Results</span>
        <span id="tabResultsState" class="tab-state">Locked</span>
      </button>
      <button id="tabSavedBtn" class="tab-button state-ready" type="button" data-tab="saved">
        <span class="tab-title">Saved Analysis</span>
        <span id="tabSavedState" class="tab-state">Ready</span>
      </button>
    </section>

    <section id="panelSetup" class="tab-panel hidden">
      <h2>Setup Analysis</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Analysis Type</div>
          <select id="analysisType" aria-label="Select Analysis Type">
            <option value="fmea">FMEA</option>
            <option value="epsa">EPSA</option>
            <option value="wcca">WCCA</option>
            <option value="coverage">Coverage</option>
          </select>
        </div>
        <div class="control-group">
          <div class="control-label">Setup Actions</div>
          <button id="saveSetupBtn" type="button">Save Setup File</button>
        </div>
      </div>
      <p id="setupSaveStatus" class="hint">Setup files target `json/fmea/setup` when directory access is configured.</p>
      <section id="fmeaAssumptionsSection" class="fmea-assumptions hidden">
        <h3>FMEA Failure Mode Assumptions</h3>
        <p id="fmeaAssumptionsStatus" class="assumption-note">Load inputs to generate component-level assumptions.</p>
        <details open>
          <summary>Failure Mode Lookup Tables (by Component Type)</summary>
          <div class="table-wrap assumption-table">
            <table>
              <thead>
                <tr>
                  <th>Component Type</th>
                  <th>Failure Modes (one per line)</th>
                </tr>
              </thead>
              <tbody id="fmeaLookupBody"></tbody>
            </table>
          </div>
        </details>
        <details open>
          <summary>Generated Assumptions for Loaded Components</summary>
          <div class="table-wrap">
            <div id="fmeaGeneratedBoard" class="assumption-board"></div>
          </div>
        </details>
        <details open>
          <summary>Failure Mode Drill-Down (Level 1 / Level 2 Propagation)</summary>
          <div class="detail-grid">
            <div>
              <div class="control-label">Component</div>
              <select id="fmeaDetailComponent"></select>
            </div>
            <div>
              <div class="control-label">Failure Mode</div>
              <select id="fmeaDetailMode"></select>
            </div>
            <div style="grid-column:1 / -1;">
              <div class="control-label">Failure Mode Description</div>
              <textarea id="fmeaDetailDescription" rows="2"></textarea>
            </div>
            <div style="grid-column:1 / -1;">
              <div class="control-label">Propagation Effects - Level 1</div>
              <textarea id="fmeaDetailL1" rows="2"></textarea>
            </div>
            <div style="grid-column:1 / -1;">
              <div class="control-label">Propagation Effects - Level 2</div>
              <textarea id="fmeaDetailL2" rows="3"></textarea>
            </div>
          </div>
          <div class="detail-actions">
            <button id="fmeaDetailSaveBtn" type="button">Save Mode Detail Override</button>
            <button id="fmeaDetailResetBtn" type="button">Reset Mode Detail to Default</button>
          </div>
        </details>
      </section>
    </section>

    <section id="panelInputs" class="tab-panel">
      <h2>Load Inputs</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Inputs</div>
          <button id="uploadBtn" type="button">Upload Files</button>
          <input id="fileInput" type="file" accept=".json,application/json" multiple class="hidden">
        </div>
      </div>
      <p id="inputStatus" class="hint">Load `netlist.json` (or equivalent schema v1.1 JSON) to enable analysis.</p>
      <details open>
        <summary>Input JSON Viewer</summary>
        <div id="inputViewer" class="jsonViewport jsonStatus">No JSON loaded.</div>
      </details>
      <details>
        <summary>Net Graph Viewer (v0.1 placeholder)</summary>
        <div id="netGraphViewer" class="jsonViewport jsonStatus">Graph output is optional in v0.1. Net adjacency summary will appear here after upload.</div>
      </details>
    </section>

    <section id="panelRun" class="tab-panel hidden">
      <h2>Run Analysis</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Run</div>
          <button id="runBtn" type="button" disabled>Run Analysis</button>
        </div>
      </div>
      <p id="resultStatus" class="hint">Run an analysis to populate deterministic results.</p>
    </section>

    <section id="panelResults" class="tab-panel hidden">
      <h2>Review Results</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Outputs</div>
          <button id="saveResultsBtn" type="button" disabled>Save Results File</button>
          <button id="exportBtn" type="button" disabled>Export Results</button>
        </div>
      </div>
      <div class="table-wrap">
        <table id="resultsTable">
          <thead><tr id="resultsHead"></tr></thead>
          <tbody id="resultsBody"></tbody>
        </table>
      </div>
      <div id="secondaryWrap" class="table-wrap">
        <table id="secondaryTable">
          <thead><tr id="secondaryHead"></tr></thead>
          <tbody id="secondaryBody"></tbody>
        </table>
      </div>
      <div id="summaryGrid" class="summary-grid"></div>
      <details>
        <summary>Output JSON Viewer</summary>
        <div id="outputViewer" class="jsonViewport jsonStatus">No JSON output yet.</div>
      </details>
    </section>

    <section id="panelSaved" class="tab-panel hidden">
      <h2>Saved Analysis</h2>
      <div class="control-panel">
        <div class="control-group">
          <div class="control-label">Directory Access</div>
          <button id="selectFmeaDirBtn" type="button">Select `json/fmea` Folder</button>
          <button id="refreshSavedBtn" type="button">Refresh Saved Files</button>
        </div>
      </div>
      <p id="savedStatus" class="hint">Select the `json/fmea` folder to read/write setup and result files directly. Fallback listing uses `json/fmea/index.json` if present.</p>
      <div class="table-wrap saved-table">
        <table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Location</th>
              <th>Type</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="savedFilesBody"></tbody>
        </table>
      </div>
    </section>
   </div>

   <script>
     "use strict";

     const ENGINE_VERSION = "0.1";

    // Fixed UI/runtime defaults intentionally replacing removed Setup options:
    // 1) EPSA margin threshold is deterministic at 20%.
    // 2) Secondary results table remains visible by default.
    // If changing these values, update:
    // - `buildSetupPayload()` persisted metadata fields
    // - `runEPSA()` threshold source
    // - `applyFixedUiDefaults()` display behavior
    const FIXED_EPSA_MARGIN_THRESHOLD_PERCENT = 20;
    const FIXED_SHOW_SECONDARY_TABLE = true;

    const state = {
      files: {},
      netlist: null,
      testPlan: null,
      partsLibrary: null,
      toleranceLibrary: null,
      stressRules: null,
      inputsValid: false,
      lastAnalysisType: null,
      lastOutput: null,
      lastMarkdown: "",
      outputsExported: false,
      fmeaDirHandle: null,
      fmeaAssumptionLookup: null,
      fmeaAssumptionOverrides: {},
      fmeaKnowledgeOverrides: {}
    };

    const DEFAULT_FAILURE_MODES_BY_CLASS = Object.freeze({
      resistor: Object.freeze(["open", "short", "oot_high", "oot_low", "drift_high", "drift_low", "noise_excess"]),
      capacitor: Object.freeze(["open", "short", "capacitance_low", "capacitance_high", "esr_high", "leakage_high"]),
      transistor: Object.freeze(["gain_low", "gain_high", "be_short", "ce_short", "open_collector", "open_emitter", "leakage_high"]),
      connector: Object.freeze(["open_contact", "intermittent_contact", "high_contact_resistance", "miswire"]),
      test_point: Object.freeze(["measurement_error", "probe_slip", "open_test_node"]),
      diode: Object.freeze(["open", "short", "leakage_high", "vf_shift"]),
      inductor: Object.freeze(["open", "short", "inductance_low", "inductance_high", "core_saturation"]),
      integrated_circuit: Object.freeze(["pin_open", "pin_short", "latchup", "timing_shift", "output_stuck_high", "output_stuck_low"]),
      switch: Object.freeze(["stuck_open", "stuck_closed", "intermittent_contact", "high_contact_resistance"]),
      fuse: Object.freeze(["nuisance_open", "fail_to_open", "high_resistance"]),
      relay: Object.freeze(["coil_open", "contact_welded", "contact_bounce_excess", "contact_open"]),
      transformer: Object.freeze(["primary_open", "secondary_open", "interwinding_short", "turns_ratio_shift"]),
      crystal: Object.freeze(["start_fail", "freq_shift_high", "freq_shift_low", "high_esr"]),
      sensor: Object.freeze(["offset_shift", "gain_shift", "stuck_output", "open_signal"]),
      other: Object.freeze(["open", "short"])
    });

    const DEFAULT_FAILURE_MODE_KNOWLEDGE = Object.freeze({
      resistor: Object.freeze({
        open: Object.freeze({ description: "Conduction path opens and current flow drops to near zero.", l1: "Direct branch current collapses and node bias shifts.", l2: "Downstream gain/margin can collapse; detection often visible as static offset." }),
        short: Object.freeze({ description: "Terminals effectively short and branch resistance drops strongly.", l1: "Branch current rises and neighboring node voltage compresses.", l2: "Upstream supply loading rises; thermal stress can propagate to adjacent parts." }),
        oot_high: Object.freeze({ description: "Resistance drifts above nominal tolerance band.", l1: "Current reduces and divider/bias point moves low.", l2: "Stage gain and headroom reduce, increasing clipping or under-drive risk." }),
        oot_low: Object.freeze({ description: "Resistance drifts below nominal tolerance band.", l1: "Current increases and divider/bias point moves high.", l2: "Power dissipation rises and later-stage bias can overdrive." })
      }),
      capacitor: Object.freeze({
        open: Object.freeze({ description: "Capacitive coupling/decoupling is lost.", l1: "AC path opens or local filtering is removed.", l2: "Noise and ripple propagation increase into dependent nodes." }),
        short: Object.freeze({ description: "Capacitor behaves like a low-impedance fault.", l1: "Connected nets are forced together at low impedance.", l2: "Bias collapse or supply loading may trigger multi-node failure signatures." }),
        capacitance_low: Object.freeze({ description: "Capacitance drops below expected value.", l1: "Time constants shorten and filtering weakens.", l2: "Dynamic stability margins degrade under transient loading." }),
        esr_high: Object.freeze({ description: "Equivalent series resistance rises beyond expected.", l1: "Ripple attenuation and pulse-current support degrade.", l2: "Thermal self-heating and cross-stage noise coupling increase." })
      }),
      transistor: Object.freeze({
        gain_low: Object.freeze({ description: "Effective beta/transconductance is reduced.", l1: "Stage gain drops and bias point may move off center.", l2: "Signal chain compression/under-drive propagates to downstream nodes." }),
        be_short: Object.freeze({ description: "Base-emitter junction is effectively shorted.", l1: "Bias network is heavily loaded and control action is lost.", l2: "Collector/emitter operating point collapses and output behavior saturates." }),
        ce_short: Object.freeze({ description: "Collector-emitter path is shorted or near short.", l1: "Load is forced toward supply/ground path unexpectedly.", l2: "Branch overcurrent and thermal stress can propagate into supply network." }),
        open_collector: Object.freeze({ description: "Collector conduction path opens.", l1: "Expected sink/source path disappears.", l2: "Downstream node floats or rails, causing interface-level functional loss." })
      }),
      connector: Object.freeze({
        open_contact: Object.freeze({ description: "One or more interface contacts are open.", l1: "Signal or supply continuity is interrupted.", l2: "External-system observability/control degrades and appears intermittent/static." }),
        intermittent_contact: Object.freeze({ description: "Contact intermittently opens under vibration or handling.", l1: "Momentary dropouts appear on interface nets.", l2: "Transient faults propagate as sporadic resets, spikes, or communication loss." })
      }),
      test_point: Object.freeze({
        measurement_error: Object.freeze({ description: "Probe setup or instrument coupling introduces error.", l1: "Observed value diverges from actual node condition.", l2: "Diagnostic decisions propagate incorrect fault isolation paths." }),
        probe_slip: Object.freeze({ description: "Probe contact moves to wrong node or loses contact.", l1: "Sampled signal is discontinuous or from unintended net.", l2: "Root-cause localization propagates to false suspects." }),
        open_test_node: Object.freeze({ description: "Test access path is open or inaccessible.", l1: "Required observability point is unavailable.", l2: "Coverage gaps increase and detection score worsens for related failures." })
      }),
      other: Object.freeze({})
    });

    const occurrenceByClass = Object.freeze({
      resistor: 3,
      capacitor: 4,
      transistor: 5,
      connector: 6,
      test_point: 2,
      diode: 4,
      inductor: 4,
      integrated_circuit: 6,
      switch: 5,
      fuse: 3,
      relay: 5,
      transformer: 4,
      crystal: 4,
      sensor: 5,
      other: 4
    });

     const detectionCovered = 3;
     const detectionUncovered = 8;

     const analyzers = Object.freeze({
       fmea: runFMEA,
       epsa: runEPSA,
       wcca: runWCCA,
       coverage: runCoverage
     });

    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    const analysisType = document.getElementById("analysisType");
    const runBtn = document.getElementById("runBtn");
    const saveResultsBtn = document.getElementById("saveResultsBtn");
    const exportBtn = document.getElementById("exportBtn");
    const secondaryWrap = document.getElementById("secondaryWrap");


     const inputStatus = document.getElementById("inputStatus");
     const resultStatus = document.getElementById("resultStatus");
     const inputViewer = document.getElementById("inputViewer");
     const outputViewer = document.getElementById("outputViewer");
     const netGraphViewer = document.getElementById("netGraphViewer");
     const resultsHead = document.getElementById("resultsHead");
     const resultsBody = document.getElementById("resultsBody");
    const secondaryHead = document.getElementById("secondaryHead");
    const secondaryBody = document.getElementById("secondaryBody");
    const summaryGrid = document.getElementById("summaryGrid");
    const tabSetupBtn = document.getElementById("tabSetupBtn");
    const tabInputsBtn = document.getElementById("tabInputsBtn");
    const tabRunBtn = document.getElementById("tabRunBtn");
    const tabResultsBtn = document.getElementById("tabResultsBtn");
    const tabSavedBtn = document.getElementById("tabSavedBtn");
    const tabSetupState = document.getElementById("tabSetupState");
    const tabInputsState = document.getElementById("tabInputsState");
    const tabRunState = document.getElementById("tabRunState");
    const tabResultsState = document.getElementById("tabResultsState");
    const tabSavedState = document.getElementById("tabSavedState");
    const panelSetup = document.getElementById("panelSetup");
    const panelInputs = document.getElementById("panelInputs");
    const panelRun = document.getElementById("panelRun");
    const panelResults = document.getElementById("panelResults");
    const panelSaved = document.getElementById("panelSaved");
    const saveSetupBtn = document.getElementById("saveSetupBtn");
    const setupSaveStatus = document.getElementById("setupSaveStatus");
    const selectFmeaDirBtn = document.getElementById("selectFmeaDirBtn");
    const refreshSavedBtn = document.getElementById("refreshSavedBtn");
    const savedStatus = document.getElementById("savedStatus");
    const savedFilesBody = document.getElementById("savedFilesBody");
    const fmeaAssumptionsSection = document.getElementById("fmeaAssumptionsSection");
    const fmeaAssumptionsStatus = document.getElementById("fmeaAssumptionsStatus");
    const fmeaLookupBody = document.getElementById("fmeaLookupBody");
    const fmeaGeneratedBoard = document.getElementById("fmeaGeneratedBoard");
    const fmeaDetailComponent = document.getElementById("fmeaDetailComponent");
    const fmeaDetailMode = document.getElementById("fmeaDetailMode");
    const fmeaDetailDescription = document.getElementById("fmeaDetailDescription");
    const fmeaDetailL1 = document.getElementById("fmeaDetailL1");
    const fmeaDetailL2 = document.getElementById("fmeaDetailL2");
    const fmeaDetailSaveBtn = document.getElementById("fmeaDetailSaveBtn");
    const fmeaDetailResetBtn = document.getElementById("fmeaDetailResetBtn");


     let sortState = { key: null, direction: 1, table: "primary" };



    uploadBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", handleFileUpload);
    runBtn.addEventListener("click", runSelectedAnalysis);
    saveResultsBtn.addEventListener("click", saveResultsFile);
    exportBtn.addEventListener("click", exportResults);
    analysisType.addEventListener("change", handleAnalysisTypeChange);
    tabSetupBtn.addEventListener("click", () => activateTab("setup"));
    tabInputsBtn.addEventListener("click", () => activateTab("inputs"));
    tabRunBtn.addEventListener("click", () => activateTab("run"));
    tabResultsBtn.addEventListener("click", () => activateTab("results"));
    tabSavedBtn.addEventListener("click", () => activateTab("saved"));
    fmeaDetailComponent.addEventListener("change", refreshFmeaDetailModeOptions);
    fmeaDetailMode.addEventListener("change", populateFmeaDetailEditor);
    fmeaDetailSaveBtn.addEventListener("click", saveFmeaDetailOverride);
    fmeaDetailResetBtn.addEventListener("click", resetFmeaDetailOverride);
    saveSetupBtn.addEventListener("click", saveSetupFile);
    selectFmeaDirBtn.addEventListener("click", selectFmeaDirectory);
    refreshSavedBtn.addEventListener("click", refreshSavedFiles);

    initializeFmeaAssumptions();
    applyFixedUiDefaults();
    updateWorkflowUi();
    refreshSavedFiles();

    function handleAnalysisTypeChange() {
      resetRunState();
      updateWorkflowUi();
      refreshFmeaAssumptionUi();
      if (state.inputsValid) {
        inputStatus.textContent = "Inputs loaded and validated. Ready to run " + analysisType.value.toUpperCase() + ".";
      }
    }

    function applyFixedUiDefaults() {
      secondaryWrap.style.display = FIXED_SHOW_SECONDARY_TABLE ? "block" : "none";
    }

    function setTabState(button, label, mode) {
      button.classList.remove("state-locked", "state-ready", "state-done");
      button.classList.add(mode);
      button.disabled = mode === "state-locked";
      label.textContent = mode === "state-done" ? "Done" : mode === "state-ready" ? "Ready" : "Locked";
    }

    function activateTab(tabName) {
      const tabs = {
        setup: { btn: tabSetupBtn, panel: panelSetup },
        inputs: { btn: tabInputsBtn, panel: panelInputs },
        run: { btn: tabRunBtn, panel: panelRun },
        results: { btn: tabResultsBtn, panel: panelResults },
        saved: { btn: tabSavedBtn, panel: panelSaved }
      };
      const current = tabs[tabName];
      if (!current || current.btn.disabled) return;
      for (const value of Object.values(tabs)) {
        value.btn.classList.remove("active");
        value.panel.classList.add("hidden");
      }
      current.btn.classList.add("active");
      current.panel.classList.remove("hidden");
    }

    function updateWorkflowUi() {
      const analysisReady = !!analysisType.value;
      const inputsReady = analysisReady && !!state.inputsValid;
      const runDone = !!state.lastOutput;
      const outputsReady = runDone;
      const outputsDone = outputsReady && !!state.outputsExported;

      uploadBtn.disabled = !analysisReady;
      runBtn.disabled = !inputsReady;
      saveResultsBtn.disabled = !outputsReady;
      exportBtn.disabled = !outputsReady;

      setTabState(tabSetupBtn, tabSetupState, "state-done");
      setTabState(tabInputsBtn, tabInputsState, inputsReady ? "state-done" : "state-ready");
      setTabState(tabRunBtn, tabRunState, runDone ? "state-done" : (inputsReady ? "state-ready" : "state-locked"));
      setTabState(tabResultsBtn, tabResultsState, outputsDone ? "state-done" : (outputsReady ? "state-ready" : "state-locked"));
      setTabState(tabSavedBtn, tabSavedState, "state-ready");

      if (tabResultsBtn.disabled && tabResultsBtn.classList.contains("active")) {
        if (!tabRunBtn.disabled) activateTab("run");
        else if (!tabInputsBtn.disabled) activateTab("inputs");
        else activateTab("setup");
      }
      if (tabRunBtn.disabled && tabRunBtn.classList.contains("active")) {
        if (!tabInputsBtn.disabled) activateTab("inputs");
        else activateTab("setup");
      }
    }

    function initializeFmeaAssumptions() {
      state.fmeaAssumptionLookup = cloneFailureModeLookup(DEFAULT_FAILURE_MODES_BY_CLASS);
      state.fmeaAssumptionOverrides = {};
      state.fmeaKnowledgeOverrides = {};
      refreshFmeaAssumptionUi();
    }

    function cloneFailureModeLookup(lookup) {
      const clone = {};
      for (const [k, v] of Object.entries(lookup)) clone[k] = Array.isArray(v) ? v.slice() : [];
      return clone;
    }

    function normalizeFailureModeListFromText(text) {
      const values = String(text || "")
        .split(/\r?\n|,/)
        .map((x) => x.trim().toLowerCase().replace(/\s+/g, "_"))
        .filter(Boolean);
      return dedupe(values);
    }

    function getFailureModesForComponent(componentClass, refdes) {
      const buckets = getFailureModeBucketsForComponent(componentClass, refdes);
      return buckets.run.slice();
    }

    function getFailureModeBucketsForComponent(componentClass, refdes) {
      const defaults = state.fmeaAssumptionLookup[componentClass] || state.fmeaAssumptionLookup.other || ["open"];
      const override = state.fmeaAssumptionOverrides[refdes];
      if (!override) return { run: defaults.slice(), skip: [], isOverride: false };

      // Backward compatibility with previous array-based override format.
      if (Array.isArray(override)) {
        const runLegacy = dedupe(override);
        const skipLegacy = defaults.filter((m) => !runLegacy.includes(m));
        return { run: runLegacy, skip: skipLegacy, isOverride: true };
      }

      const run = dedupe(Array.isArray(override.run) ? override.run : defaults);
      const skip = dedupe(Array.isArray(override.skip) ? override.skip : []);
      const merged = dedupe([].concat(run, skip, defaults));
      const resolvedRun = dedupe(run.filter((m) => merged.includes(m)));
      const resolvedSkip = dedupe(skip.filter((m) => merged.includes(m) && !resolvedRun.includes(m)));
      const isOverride = !arraysEqual(resolvedRun, defaults) || resolvedSkip.length > 0;
      return { run: resolvedRun, skip: resolvedSkip, isOverride };
    }

    function setFailureModeBucketsForComponent(componentClass, refdes, run, skip) {
      const defaults = state.fmeaAssumptionLookup[componentClass] || state.fmeaAssumptionLookup.other || ["open"];
      const runNorm = dedupe((run || []).map((x) => String(x).trim()).filter(Boolean));
      const skipNorm = dedupe((skip || []).map((x) => String(x).trim()).filter(Boolean)).filter((m) => !runNorm.includes(m));
      if (arraysEqual(runNorm, defaults) && skipNorm.length === 0) {
        delete state.fmeaAssumptionOverrides[refdes];
        return;
      }
      state.fmeaAssumptionOverrides[refdes] = { run: runNorm, skip: skipNorm };
    }

    function buildKnowledgeKey(componentClass, mode) {
      return componentClass + "::" + mode;
    }

    function buildDefaultFailureKnowledge(componentClass, mode) {
      const modeLabel = String(mode || "unknown").replace(/_/g, " ");
      const typeLabel = String(componentClass || "component").replace(/_/g, " ");
      return {
        description: "Deterministic failure assumption for " + typeLabel + " mode '" + modeLabel + "'.",
        l1: "Primary propagation: directly connected nets and bias points shift based on topology.",
        l2: "Secondary propagation: downstream interfaces, margins, and detection paths are impacted."
      };
    }

    function getFailureModeKnowledge(componentClass, mode) {
      const key = buildKnowledgeKey(componentClass, mode);
      if (state.fmeaKnowledgeOverrides[key]) return Object.assign({}, state.fmeaKnowledgeOverrides[key]);
      const typeDefaults = DEFAULT_FAILURE_MODE_KNOWLEDGE[componentClass] || DEFAULT_FAILURE_MODE_KNOWLEDGE.other || {};
      const knowledge = typeDefaults[mode];
      if (knowledge) return { description: knowledge.description, l1: knowledge.l1, l2: knowledge.l2 };
      return buildDefaultFailureKnowledge(componentClass, mode);
    }

    function renderFmeaLookupTable() {
      if (!fmeaLookupBody) return;
      fmeaLookupBody.innerHTML = "";
      const keys = Object.keys(state.fmeaAssumptionLookup || {}).sort();
      for (const componentType of keys) {
        const tr = document.createElement("tr");
        const tdType = document.createElement("td");
        tdType.textContent = componentType;
        const tdModes = document.createElement("td");
        const textarea = document.createElement("textarea");
        textarea.value = (state.fmeaAssumptionLookup[componentType] || []).join("\n");
        textarea.addEventListener("change", () => {
          const list = normalizeFailureModeListFromText(textarea.value);
          state.fmeaAssumptionLookup[componentType] = list.length ? list : ["open"];
          textarea.value = state.fmeaAssumptionLookup[componentType].join("\n");
          renderGeneratedFmeaAssumptions();
        });
        tdModes.appendChild(textarea);
        tr.appendChild(tdType);
        tr.appendChild(tdModes);
        fmeaLookupBody.appendChild(tr);
      }
    }

    function createModePill(refdes, mode, bucketName) {
      const pill = document.createElement("span");
      pill.className = "mode-pill" + (bucketName === "skip" ? " skip" : "");
      pill.textContent = mode;
      pill.draggable = true;
      pill.dataset.refdes = refdes;
      pill.dataset.mode = mode;
      pill.dataset.bucket = bucketName;
      pill.addEventListener("dragstart", (ev) => {
        ev.dataTransfer.setData("text/plain", JSON.stringify({
          refdes,
          mode,
          fromBucket: bucketName
        }));
      });
      return pill;
    }

    function attachBucketDropHandlers(bucketEl, refdes, targetBucket) {
      bucketEl.addEventListener("dragover", (ev) => {
        ev.preventDefault();
        bucketEl.classList.add("drag-over");
      });
      bucketEl.addEventListener("dragleave", () => bucketEl.classList.remove("drag-over"));
      bucketEl.addEventListener("drop", (ev) => {
        ev.preventDefault();
        bucketEl.classList.remove("drag-over");
        let payload = null;
        try { payload = JSON.parse(ev.dataTransfer.getData("text/plain")); } catch (_err) { return; }
        if (!payload || payload.refdes !== refdes || !payload.mode) return;
        const componentType = classifyComponent(refdes);
        const buckets = getFailureModeBucketsForComponent(componentType, refdes);
        const run = buckets.run.slice();
        const skip = buckets.skip.slice();
        if (payload.fromBucket === targetBucket) return;
        if (targetBucket === "run") {
          if (!run.includes(payload.mode)) run.push(payload.mode);
          const idx = skip.indexOf(payload.mode);
          if (idx >= 0) skip.splice(idx, 1);
        } else {
          if (!skip.includes(payload.mode)) skip.push(payload.mode);
          const idx = run.indexOf(payload.mode);
          if (idx >= 0) run.splice(idx, 1);
        }
        if (!run.length) return; // keep at least one runnable mode
        setFailureModeBucketsForComponent(componentType, refdes, run, skip);
        renderGeneratedFmeaAssumptions();
      });
    }

    function renderGeneratedFmeaAssumptions() {
      if (!fmeaGeneratedBoard) return;
      fmeaGeneratedBoard.innerHTML = "";
      const components = (state.netlist && Array.isArray(state.netlist.components)) ? state.netlist.components.slice() : [];
      components.sort((a, b) => String(a.refdes || "").localeCompare(String(b.refdes || "")));
      if (!components.length) {
        const empty = document.createElement("div");
        empty.className = "assumption-note";
        empty.textContent = "Load a netlist to generate assumptions per component.";
        fmeaGeneratedBoard.appendChild(empty);
        return;
      }

      for (const component of components) {
        const refdes = component.refdes || "UNASSIGNED";
        const componentType = classifyComponent(refdes);
        const buckets = getFailureModeBucketsForComponent(componentType, refdes);
        const card = document.createElement("div");
        card.className = "assumption-card";

        const head = document.createElement("div");
        head.className = "assumption-card-head";
        const chipRef = document.createElement("span");
        chipRef.className = "assumption-chip ref";
        chipRef.textContent = refdes;
        const chipType = document.createElement("span");
        chipType.className = "assumption-chip type";
        chipType.textContent = componentType;
        const chipSrc = document.createElement("span");
        chipSrc.className = "assumption-chip src";
        chipSrc.textContent = buckets.isOverride ? "override" : "lookup";
        head.appendChild(chipRef);
        head.appendChild(chipType);
        head.appendChild(chipSrc);

        const bucketGrid = document.createElement("div");
        bucketGrid.className = "bucket-grid";
        const runBucket = document.createElement("div");
        runBucket.className = "bucket run";
        const skipBucket = document.createElement("div");
        skipBucket.className = "bucket skip";
        const runTitle = document.createElement("h4");
        runTitle.textContent = "Run";
        const skipTitle = document.createElement("h4");
        skipTitle.textContent = "Skip";
        runBucket.appendChild(runTitle);
        skipBucket.appendChild(skipTitle);
        for (const mode of buckets.run) runBucket.appendChild(createModePill(refdes, mode, "run"));
        for (const mode of buckets.skip) skipBucket.appendChild(createModePill(refdes, mode, "skip"));
        attachBucketDropHandlers(runBucket, refdes, "run");
        attachBucketDropHandlers(skipBucket, refdes, "skip");
        bucketGrid.appendChild(runBucket);
        bucketGrid.appendChild(skipBucket);

        card.appendChild(head);
        card.appendChild(bucketGrid);
        fmeaGeneratedBoard.appendChild(card);
      }
      refreshFmeaDetailComponentOptions();
    }

    function refreshFmeaDetailComponentOptions() {
      if (!fmeaDetailComponent) return;
      const prev = fmeaDetailComponent.value;
      fmeaDetailComponent.innerHTML = "";
      const components = (state.netlist && Array.isArray(state.netlist.components)) ? state.netlist.components.slice() : [];
      components.sort((a, b) => String(a.refdes || "").localeCompare(String(b.refdes || "")));
      if (!components.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(no component loaded)";
        fmeaDetailComponent.appendChild(opt);
        refreshFmeaDetailModeOptions();
        return;
      }
      for (const c of components) {
        const ref = c.refdes || "UNASSIGNED";
        const opt = document.createElement("option");
        opt.value = ref;
        opt.textContent = ref + " (" + classifyComponent(ref) + ")";
        fmeaDetailComponent.appendChild(opt);
      }
      if (prev) fmeaDetailComponent.value = prev;
      if (!fmeaDetailComponent.value) fmeaDetailComponent.selectedIndex = 0;
      refreshFmeaDetailModeOptions();
    }

    function refreshFmeaDetailModeOptions() {
      if (!fmeaDetailMode) return;
      const refdes = fmeaDetailComponent.value;
      const prev = fmeaDetailMode.value;
      fmeaDetailMode.innerHTML = "";
      if (!refdes) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(no mode)";
        fmeaDetailMode.appendChild(opt);
        populateFmeaDetailEditor();
        return;
      }
      const componentType = classifyComponent(refdes);
      const buckets = getFailureModeBucketsForComponent(componentType, refdes);
      const modes = dedupe([].concat(buckets.run, buckets.skip));
      for (const mode of modes) {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.textContent = mode;
        fmeaDetailMode.appendChild(opt);
      }
      if (prev && modes.includes(prev)) fmeaDetailMode.value = prev;
      if (!fmeaDetailMode.value && modes.length) fmeaDetailMode.selectedIndex = 0;
      populateFmeaDetailEditor();
    }

    function populateFmeaDetailEditor() {
      const refdes = fmeaDetailComponent.value;
      const mode = fmeaDetailMode.value;
      const disable = !refdes || !mode;
      fmeaDetailDescription.disabled = disable;
      fmeaDetailL1.disabled = disable;
      fmeaDetailL2.disabled = disable;
      fmeaDetailSaveBtn.disabled = disable;
      fmeaDetailResetBtn.disabled = disable;
      if (disable) {
        fmeaDetailDescription.value = "";
        fmeaDetailL1.value = "";
        fmeaDetailL2.value = "";
        return;
      }
      const componentType = classifyComponent(refdes);
      const k = getFailureModeKnowledge(componentType, mode);
      fmeaDetailDescription.value = k.description || "";
      fmeaDetailL1.value = k.l1 || "";
      fmeaDetailL2.value = k.l2 || "";
    }

    function saveFmeaDetailOverride() {
      const refdes = fmeaDetailComponent.value;
      const mode = fmeaDetailMode.value;
      if (!refdes || !mode) return;
      const componentType = classifyComponent(refdes);
      const key = buildKnowledgeKey(componentType, mode);
      state.fmeaKnowledgeOverrides[key] = {
        description: String(fmeaDetailDescription.value || "").trim(),
        l1: String(fmeaDetailL1.value || "").trim(),
        l2: String(fmeaDetailL2.value || "").trim()
      };
      fmeaAssumptionsStatus.textContent = "Saved detail override for " + componentType + " / " + mode + ".";
    }

    function resetFmeaDetailOverride() {
      const refdes = fmeaDetailComponent.value;
      const mode = fmeaDetailMode.value;
      if (!refdes || !mode) return;
      const componentType = classifyComponent(refdes);
      delete state.fmeaKnowledgeOverrides[buildKnowledgeKey(componentType, mode)];
      populateFmeaDetailEditor();
      fmeaAssumptionsStatus.textContent = "Reset detail override to deterministic default for " + componentType + " / " + mode + ".";
    }

    function refreshFmeaAssumptionUi() {
      if (!fmeaAssumptionsSection) return;
      const isFmea = analysisType.value === "fmea";
      fmeaAssumptionsSection.classList.toggle("hidden", !isFmea);
      if (!isFmea) return;
      renderFmeaLookupTable();
      renderGeneratedFmeaAssumptions();
      const componentCount = state.netlist && Array.isArray(state.netlist.components) ? state.netlist.components.length : 0;
      fmeaAssumptionsStatus.textContent = componentCount
        ? "Deterministic assumptions generated for " + componentCount + " components from refdes-derived types."
        : "Load inputs to generate component-level assumptions.";
    }

    function buildAnalysisStem(kind) {
      const boardPn = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_pn"], "unknown_board"));
      const boardRev = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_rev"], "unknown_rev"));
      const when = new Date().toISOString().replace(/[:.]/g, "-");
      return "analysis_" + safeFilePart(kind || analysisType.value || "fmea") + "_" + boardPn + "_" + boardRev + "_" + when;
    }

    function buildStableAnalysisStem() {
      const boardPn = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_pn"], "unknown_board"));
      const boardRev = safeFilePart(safeGet(state.netlist || {}, ["identity", "board_rev"], "unknown_rev"));
      return "analysis_" + boardPn + "_" + boardRev;
    }

    function buildComprehensiveFmeaSetupSnapshot() {
      const netlist = state.netlist || null;
      const files = state.files || {};
      const fileNames = Object.keys(files).sort();
      const components = (netlist && Array.isArray(netlist.components)) ? netlist.components.slice() : [];
      components.sort((a, b) => String(a.refdes || "").localeCompare(String(b.refdes || "")));

      // Deterministic lightweight fingerprints to quickly detect setup changes without diffing large blobs.
      const hashOf = (value) => {
        const text = JSON.stringify(value);
        let h = 2166136261 >>> 0;
        for (let i = 0; i < text.length; i += 1) {
          h ^= text.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return ("00000000" + (h >>> 0).toString(16)).slice(-8);
      };

      const knowledgeCatalog = {};
      const resolvedByComponent = [];
      for (const component of components) {
        const refdes = component.refdes || "UNASSIGNED";
        const componentType = classifyComponent(refdes);
        const buckets = getFailureModeBucketsForComponent(componentType, refdes);
        const allModes = dedupe([].concat(buckets.run, buckets.skip)).sort();

        if (!knowledgeCatalog[componentType]) knowledgeCatalog[componentType] = {};
        for (const mode of allModes) {
          if (!knowledgeCatalog[componentType][mode]) {
            const key = buildKnowledgeKey(componentType, mode);
            knowledgeCatalog[componentType][mode] = Object.assign(
              { source: state.fmeaKnowledgeOverrides[key] ? "override" : "default" },
              getFailureModeKnowledge(componentType, mode)
            );
          }
        }

        resolvedByComponent.push({
          refdes,
          component_type: componentType,
          assumption_source: buckets.isOverride ? "override" : "lookup",
          failure_modes_run: buckets.run.slice(),
          failure_modes_skip: buckets.skip.slice(),
          failure_mode_detail_refs: allModes.map((mode) => componentType + "::" + mode)
        });
      }

      const fileFingerprints = {};
      for (const name of fileNames) fileFingerprints[name] = hashOf(files[name]);

      return {
        schema_style: "normalized_comprehensive_v1",
        summary: {
          component_count: components.length,
          resolved_component_count: resolvedByComponent.length,
          input_file_count: fileNames.length,
          knowledge_entry_count: Object.values(knowledgeCatalog).reduce((acc, byMode) => acc + Object.keys(byMode).length, 0)
        },
        fingerprints: {
          input_files: fileFingerprints,
          fmea_lookup_tables: hashOf(state.fmeaAssumptionLookup || {}),
          fmea_component_overrides: hashOf(state.fmeaAssumptionOverrides || {}),
          fmea_mode_knowledge_overrides: hashOf(state.fmeaKnowledgeOverrides || {}),
          resolved_assumptions: hashOf(resolvedByComponent)
        },
        input_files_loaded: fileNames,
        input_files_raw: files,
        detected_inputs: {
          netlist: !!state.netlist,
          test_plan: !!state.testPlan,
          parts_library: !!state.partsLibrary,
          tolerance_library: !!state.toleranceLibrary,
          stress_rules: !!state.stressRules
        },
        net_adjacency_snapshot: buildNetAdjacencyData(state.netlist),
        fmea_lookup_tables: state.fmeaAssumptionLookup || {},
        fmea_component_overrides_raw: state.fmeaAssumptionOverrides || {},
        fmea_mode_knowledge_overrides_raw: state.fmeaKnowledgeOverrides || {},
        fmea_mode_knowledge_catalog_resolved: knowledgeCatalog,
        fmea_resolved_assumptions_by_component: resolvedByComponent
      };
    }

    function buildSetupPayload() {
      return {
        setup_version: "0.1",
        setup_type: "fmea",
        analysis_engine_version: ENGINE_VERSION,
        generated_on: new Date().toISOString(),
        board_pn: safeGet(state.netlist || {}, ["identity", "board_pn"], "unknown_board"),
        board_rev: safeGet(state.netlist || {}, ["identity", "board_rev"], "unknown_rev"),
        analysis_type: analysisType.value,
        options: {
          // Persist fixed defaults so future tools/agents can infer behavior from setup files.
          margin_threshold_percent: FIXED_EPSA_MARGIN_THRESHOLD_PERCENT,
          show_secondary: FIXED_SHOW_SECONDARY_TABLE
        },
        fmea_failure_mode_lookup: state.fmeaAssumptionLookup || {},
        fmea_component_overrides: state.fmeaAssumptionOverrides || {},
        fmea_mode_knowledge_overrides: state.fmeaKnowledgeOverrides || {},
        // Comprehensive snapshot: includes all loaded inputs + resolved assumptions (run/skip + details).
        // This is intentionally verbose so future agents/tools can reconstruct full setup context.
        comprehensive_snapshot: buildComprehensiveFmeaSetupSnapshot()
      };
    }

    function setSavedStatus(message) {
      if (savedStatus) savedStatus.textContent = message;
      if (setupSaveStatus) setupSaveStatus.textContent = message;
    }

    async function resolveFmeaBaseDirectoryHandle() {
      if (!state.fmeaDirHandle) return null;
      const selected = state.fmeaDirHandle;
      try {
        const jsonDir = await selected.getDirectoryHandle("json");
        const fmeaDir = await jsonDir.getDirectoryHandle("fmea");
        return { handle: fmeaDir, resolvedFrom: "json/fmea" };
      } catch (_err1) {
        // continue
      }
      try {
        const fmeaDir = await selected.getDirectoryHandle("fmea");
        return { handle: fmeaDir, resolvedFrom: "fmea" };
      } catch (_err2) {
        // continue
      }
      return { handle: selected, resolvedFrom: "(selected folder)" };
    }

    async function saveSetupFile() {
      const payload = buildSetupPayload();
      const stableStem = buildStableAnalysisStem();
      const stem = stableStem.replace(/^analysis_/, "analysis_fmea_setup_");
      const filename = stem + ".json";
      try {
        if (await writeJsonToFmeaDirectory("setup", filename, payload)) {
          setSavedStatus("Saved setup file to json/fmea/setup/" + filename + " (overwrites same PN/REV).");
          refreshSavedFiles();
          return;
        }
      } catch (err) {
        setSavedStatus("Direct setup save failed: " + err.message + ". Downloaded instead.");
      }
      setSavedStatus("Directory save unavailable. Downloaded setup file instead.");
      downloadBlob(filename, JSON.stringify(payload, null, 2), "application/json");
    }

    async function autoSaveLatestAnalysisReport() {
      if (!state.lastOutput) return;
      const stem = buildStableAnalysisStem();
      const jsonName = stem + ".json";
      const mdName = stem + ".md";
      try {
        const okJson = await writeJsonToFmeaDirectory("", jsonName, state.lastOutput);
        const okMd = await writeTextToFmeaDirectory("", mdName, state.lastMarkdown || "");
        if (okJson && okMd) {
          setSavedStatus("Auto-saved analysis report to json/fmea/" + jsonName + " (overwrites same PN/REV).");
          state.outputsExported = true;
          updateWorkflowUi();
          refreshSavedFiles();
          return;
        }
      } catch (err) {
        setSavedStatus("Auto-save failed: " + err.message);
        return;
      }
      setSavedStatus("Auto-save not available until a folder is selected in Saved Analysis.");
    }

    async function selectFmeaDirectory() {
      try {
        if (!window.showDirectoryPicker) {
          setSavedStatus("Directory API unavailable in this browser. Use downloads or provide json/fmea/index.json.");
          return;
        }
        const handle = await window.showDirectoryPicker();
        state.fmeaDirHandle = handle;
        const resolved = await resolveFmeaBaseDirectoryHandle();
        setSavedStatus("Directory selected. Save base resolved as " + (resolved ? resolved.resolvedFrom : "(none)") + " under selected folder.");
        await refreshSavedFiles();
      } catch (err) {
        setSavedStatus("Directory selection cancelled or denied.");
      }
    }

    async function writeJsonToFmeaDirectory(subdir, filename, value) {
      const resolved = await resolveFmeaBaseDirectoryHandle();
      if (!resolved || !resolved.handle) return false;
      const base = resolved.handle;
      const targetDir = subdir ? await base.getDirectoryHandle(subdir, { create: true }) : base;
      const fileHandle = await targetDir.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(value, null, 2));
      await writable.close();
      return true;
    }

    async function writeTextToFmeaDirectory(subdir, filename, text) {
      const resolved = await resolveFmeaBaseDirectoryHandle();
      if (!resolved || !resolved.handle) return false;
      const base = resolved.handle;
      const targetDir = subdir ? await base.getDirectoryHandle(subdir, { create: true }) : base;
      const fileHandle = await targetDir.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(String(text));
      await writable.close();
      return true;
    }

    async function refreshSavedFiles() {
      if (state.fmeaDirHandle) {
        await refreshSavedFilesFromDirectory();
        return;
      }
      await refreshSavedFilesFromIndex();
    }

    async function refreshSavedFilesFromDirectory() {
      const rows = [];
      try {
        const resolved = await resolveFmeaBaseDirectoryHandle();
        if (!resolved || !resolved.handle) throw new Error("No directory selected");
        for await (const [name, handle] of resolved.handle.entries()) {
          if (handle.kind === "file") rows.push({ name, location: "json/fmea", type: "file", source: "dir" });
          if (handle.kind === "directory" && name === "setup") {
            for await (const [sname, sh] of handle.entries()) {
              if (sh.kind === "file") rows.push({ name: sname, location: "json/fmea/setup", type: "setup-file", source: "dir", inSetup: true });
            }
          }
        }
        renderSavedFiles(rows);
        setSavedStatus("Loaded " + rows.length + " saved files from resolved json/fmea base.");
      } catch (err) {
        setSavedStatus("Unable to enumerate selected folder: " + err.message);
      }
    }

    async function refreshSavedFilesFromIndex() {
      try {
        const res = await fetch("json/fmea/index.json?v=" + Date.now(), { cache: "no-store" });
        if (!res.ok) throw new Error("index.json not found");
        const data = await res.json();
        const rows = Array.isArray(data.files) ? data.files.map((f) => ({
          name: String(f.name || ""),
          location: String(f.location || "json/fmea"),
          type: String(f.type || "file"),
          source: "index"
        })) : [];
        renderSavedFiles(rows);
        setSavedStatus("Loaded " + rows.length + " saved files from json/fmea/index.json.");
      } catch (_err) {
        renderSavedFiles([]);
        setSavedStatus("No directory selected and no json/fmea/index.json manifest available.");
      }
    }

    function renderSavedFiles(rows) {
      savedFilesBody.innerHTML = "";
      if (!rows.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 4;
        td.textContent = "No saved analysis files found.";
        tr.appendChild(td);
        savedFilesBody.appendChild(tr);
        return;
      }
      rows.sort((a, b) => String(a.location + "/" + a.name).localeCompare(String(b.location + "/" + b.name)));
      for (const row of rows) {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        tdName.textContent = row.name;
        const tdLoc = document.createElement("td");
        tdLoc.textContent = row.location;
        const tdType = document.createElement("td");
        tdType.textContent = row.type;
        const tdAction = document.createElement("td");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = "Load";
        btn.addEventListener("click", () => loadSavedAnalysisRow(row));
        tdAction.appendChild(btn);
        tr.appendChild(tdName);
        tr.appendChild(tdLoc);
        tr.appendChild(tdType);
        tr.appendChild(tdAction);
        savedFilesBody.appendChild(tr);
      }
    }

    async function loadSavedAnalysisRow(row) {
      try {
        if (state.fmeaDirHandle && row.source === "dir") {
          const resolved = await resolveFmeaBaseDirectoryHandle();
          if (!resolved || !resolved.handle) throw new Error("No resolved base directory");
          const dir = row.inSetup ? await resolved.handle.getDirectoryHandle("setup") : resolved.handle;
          const file = await (await dir.getFileHandle(row.name)).getFile();
          const text = await file.text();
          const parsed = JSON.parse(text);
          renderJsonViewer(outputViewer, parsed, "No JSON output yet.");
          activateTab("results");
          return;
        }
        const path = (row.location || "json/fmea").replace(/\/+$/, "") + "/" + row.name;
        const res = await fetch(path + "?v=" + Date.now(), { cache: "no-store" });
        if (!res.ok) throw new Error("Cannot fetch " + path);
        const parsed = await res.json();
        renderJsonViewer(outputViewer, parsed, "No JSON output yet.");
        activateTab("results");
      } catch (err) {
        setSavedStatus("Load failed: " + err.message);
      }
    }


    function handleFileUpload(event) {
      const files = Array.from(event.target.files || []);
      if (!files.length) {
        return;
      }
      state.inputsValid = false;
      resetRunState();
      const reads = files.map(readJsonFile);
       Promise.all(reads)
         .then((loaded) => {
           state.files = {};
           for (const loadedFile of loaded) {
             state.files[loadedFile.name] = loadedFile.data;
           }
           classifyLoadedFiles();
           validateAndRenderInputs();
         })
        .catch((err) => {
          state.inputsValid = false;
          inputStatus.textContent = "Upload failed: " + err.message;
          refreshFmeaAssumptionUi();
          updateWorkflowUi();
        });
    }

     function readJsonFile(file) {
       return new Promise((resolve, reject) => {
         const reader = new FileReader();
         reader.onerror = () => reject(new Error("Unable to read " + file.name));
         reader.onload = () => {
           try {
             const parsed = JSON.parse(String(reader.result));
             resolve({ name: file.name, data: parsed });
           } catch (err) {
             reject(new Error(file.name + " is not valid JSON."));
           }
         };
         reader.readAsText(file);
       });
     }

    function classifyLoadedFiles() {
      state.netlist = null;
      state.testPlan = null;
      state.partsLibrary = null;
      state.toleranceLibrary = null;
       state.stressRules = null;

      for (const [name, data] of Object.entries(state.files)) {
         const lower = name.toLowerCase();
         if (lower.includes("test_plan")) {
           state.testPlan = data;
           continue;
         }
         if (lower.includes("parts_library")) {
           state.partsLibrary = data;
           continue;
         }
         if (lower.includes("tolerance_library")) {
           state.toleranceLibrary = data;
           continue;
         }
         if (lower.includes("stress_rules")) {
           state.stressRules = data;
           continue;
         }
        if (!state.netlist && looksLikeNetlist(data)) {
          state.netlist = data;
        }
      }
      pruneFmeaOverridesToLoadedComponents();
      refreshFmeaAssumptionUi();
    }

    function pruneFmeaOverridesToLoadedComponents() {
      const valid = new Set((state.netlist && Array.isArray(state.netlist.components))
        ? state.netlist.components.map((c) => c.refdes || "UNASSIGNED")
        : []);
      for (const key of Object.keys(state.fmeaAssumptionOverrides || {})) {
        if (!valid.has(key)) delete state.fmeaAssumptionOverrides[key];
      }
      for (const key of Object.keys(state.fmeaAssumptionOverrides || {})) {
        const componentType = classifyComponent(key);
        const buckets = getFailureModeBucketsForComponent(componentType, key);
        setFailureModeBucketsForComponent(componentType, key, buckets.run, buckets.skip);
      }
      const validTypes = new Set((state.netlist && Array.isArray(state.netlist.components))
        ? state.netlist.components.map((c) => classifyComponent(c.refdes || "UNASSIGNED"))
        : []);
      for (const key of Object.keys(state.fmeaKnowledgeOverrides || {})) {
        const type = String(key).split("::")[0];
        if (!validTypes.has(type)) delete state.fmeaKnowledgeOverrides[key];
      }
    }

     function looksLikeNetlist(data) {
       return !!(data && typeof data === "object" && Array.isArray(data.components));
     }

     function validateAndRenderInputs() {
       const errors = [];
       if (!validateNetlist(state.netlist)) {
         errors.push("Missing required netlist schema fields: schema_version, identity, components[].pins[].net");
       }
       if (state.testPlan && !validateTestPlan(state.testPlan)) {
         errors.push("test_plan.json did not match expected structure.");
       }
       if (state.partsLibrary && !validatePartsLibrary(state.partsLibrary)) {
         errors.push("parts_library.json did not match expected structure.");
       }
       if (state.toleranceLibrary && !validateToleranceLibrary(state.toleranceLibrary)) {
         errors.push("tolerance_library.json did not match expected structure.");
       }
       if (state.stressRules && !validateStressRules(state.stressRules)) {
         errors.push("stress_rules.json did not match expected structure.");
       }

      renderJsonViewer(inputViewer, {
        uploaded_files: Object.keys(state.files),
        detected: {
          netlist: !!state.netlist,
          test_plan: !!state.testPlan,
          parts_library: !!state.partsLibrary,
          tolerance_library: !!state.toleranceLibrary,
          stress_rules: !!state.stressRules
        },
        preview: state.netlist || {}
      }, "No JSON loaded.");


      renderJsonViewer(netGraphViewer, buildNetAdjacencyData(state.netlist), "No netlist loaded.");


      if (errors.length) {
        state.inputsValid = false;
        inputStatus.textContent = "Validation errors: " + errors.join(" | ");
        refreshFmeaAssumptionUi();
        updateWorkflowUi();
        return;
      }

      state.inputsValid = !!state.netlist;
      inputStatus.textContent = "Inputs loaded and validated. Ready to run " + analysisType.value.toUpperCase() + ".";
      refreshFmeaAssumptionUi();
      updateWorkflowUi();
      activateTab("run");
    }

     function validateNetlist(netlist) {
       if (!netlist || typeof netlist !== "object") return false;
       if (!netlist.schema_version || !netlist.identity || !Array.isArray(netlist.components)) return false;
       for (const c of netlist.components) {
         if (!Array.isArray(c.pins)) return false;
         for (const pin of c.pins) {
           if (!pin || typeof pin.net !== "string") return false;
         }
       }
       return true;
     }

     function validateTestPlan(plan) {
       if (!plan || typeof plan !== "object") return false;
       return Array.isArray(plan.tests) || Array.isArray(plan.covered_nets) || Array.isArray(plan.nets);
     }

     function validatePartsLibrary(lib) {
       if (!lib || typeof lib !== "object") return false;
       if (Array.isArray(lib.parts)) return true;
       if (typeof lib.by_refdes === "object") return true;
       return false;
     }

    function validateToleranceLibrary(lib) {
      if (!lib || typeof lib !== "object") return false;
      return Array.isArray(lib.tolerances) || typeof lib.default_tolerance === "number" || typeof lib.by_refdes === "object";
    }

     function validateStressRules(rules) {
       if (!rules || typeof rules !== "object") return false;
       return typeof rules.margin_threshold_percent === "number" || typeof rules.thresholds === "object";
     }

    function runSelectedAnalysis() {
      if (!state.netlist || !state.inputsValid) {
        resultStatus.textContent = "Load a valid netlist first.";
        updateWorkflowUi();
        return;
      }
      const type = analysisType.value;
      const analyzer = analyzers[type];
      if (!analyzer) {
        resultStatus.textContent = "Unknown analysis type: " + type;
        updateWorkflowUi();
        return;
      }
      resetRunState();
       const base = {
         analysis_engine_version: ENGINE_VERSION,
         analysis_type: type,
         generated_on: new Date().toISOString(),
         board_pn: safeGet(state.netlist, ["identity", "board_pn"], "unknown_board"),
         board_rev: safeGet(state.netlist, ["identity", "board_rev"], "unknown_rev")
       };
       const coverageResult = runCoverage(state.netlist, state.testPlan).result;
       const analysis = analyzer(state.netlist, state.testPlan, state.partsLibrary, state.toleranceLibrary, state.stressRules, coverageResult);
      state.lastAnalysisType = type;
      state.lastOutput = Object.assign({}, base, analysis.result);
      state.lastMarkdown = analysis.markdown;
      state.outputsExported = false;
      renderJsonViewer(outputViewer, state.lastOutput, "No JSON output yet.");
      renderAnalysis(analysis);
      resultStatus.textContent = "Completed " + type.toUpperCase() + " with deterministic engine v" + ENGINE_VERSION + ".";
      autoSaveLatestAnalysisReport();
      updateWorkflowUi();
      activateTab("results");
    }

     function runFMEA(netlist, testPlan, _partsLibrary, _toleranceLibrary, _stressRules, coverageResult) {
       const netCoverage = (coverageResult && coverageResult.coverage_map) || {};
       const rows = [];
       const netToRefs = buildNetToRefsMap(netlist);
       const components = Array.isArray(netlist.components) ? netlist.components : [];

      for (const component of components) {
        const componentClass = classifyComponent(component.refdes);
        const failures = getFailureModesForComponent(componentClass, component.refdes || "UNASSIGNED");
        const nets = extractComponentNets(component);
         const affectedComponents = dedupe(nets.flatMap((net) => netToRefs[net] || []).filter((ref) => ref !== component.refdes));
         const affectedInterfacePins = nets.filter(isInterfaceNet);


        for (const mode of failures) {
          const severity = computeSeverity(nets);
          const occurrence = occurrenceByClass[componentClass] || occurrenceByClass.other;
          const detection = nets.some((n) => netCoverage[n]) ? detectionCovered : detectionUncovered;
          const rpn = severity * occurrence * detection;
          rows.push({
            component: component.refdes || "UNASSIGNED",
            failure_mode: mode,
            affected_nets: nets,
            affected_components: affectedComponents,
            affected_interface_pins: affectedInterfacePins,
            severity,
             occurrence,
             detection,
             RPN: rpn,
             coverage_status: detection === detectionCovered ? "covered" : "uncovered"
           });
         }
       }

       rows.sort((a, b) => b.RPN - a.RPN || String(a.component).localeCompare(String(b.component)));
       const summary = {
         entries: rows.length,
         high_risk_count: rows.filter((r) => r.RPN >= 200).length,
         average_rpn: rows.length ? Number((rows.reduce((acc, r) => acc + r.RPN, 0) / rows.length).toFixed(2)) : 0
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.slice(0, 20).map((r) => ({
           component: r.component,
           failure_mode: r.failure_mode,
           RPN: r.RPN,
           coverage_status: r.coverage_status
         })),
         summary,
         result: { fmea: rows, summary },
         markdown: buildMarkdown("FMEA", rows, summary, ["component", "failure_mode", "severity", "occurrence", "detection", "RPN", "coverage_status"])
       };
     }

    function runEPSA(netlist, _testPlan, partsLibrary, _toleranceLibrary, stressRules) {
      const partsMap = buildPartsMap(partsLibrary);
      // Fixed deterministic EPSA threshold now that Setup option control was removed.
      // If changed, keep `FIXED_EPSA_MARGIN_THRESHOLD_PERCENT` and setup serialization in sync.
      const threshold = toNumber(FIXED_EPSA_MARGIN_THRESHOLD_PERCENT, safeGet(stressRules, ["margin_threshold_percent"], 20));
       const rows = [];
       const components = Array.isArray(netlist.components) ? netlist.components : [];

       for (const component of components) {
         const info = partsMap[component.refdes] || {};
         const componentClass = classifyComponent(component.refdes);
         const ratingVoltage = toNumber(info.voltage_rating, componentClass === "transistor" ? 40 : 16);
         const ratingCurrent = toNumber(info.current_rating, componentClass === "connector" ? 1 : 0.2);
         const ratingPower = toNumber(info.power_rating, componentClass === "resistor" ? 0.25 : 0.5);
         const nets = extractComponentNets(component);
         const vActual = estimateComponentVoltage(netlist, nets);
         const iActual = estimateComponentCurrent(componentClass, vActual, component.value);
         const pActual = componentClass === "resistor" ? computeResistorPower(vActual, component.value) : vActual * iActual;

         rows.push(buildStressRow(component.refdes, "voltage", vActual, ratingVoltage, threshold));
         rows.push(buildStressRow(component.refdes, "current", iActual, ratingCurrent, threshold));
         rows.push(buildStressRow(component.refdes, "power", pActual, ratingPower, threshold));
       }

       const summary = {
         entries: rows.length,
         pass_count: rows.filter((r) => r.status === "pass").length,
         warn_count: rows.filter((r) => r.status === "warn").length,
         fail_count: rows.filter((r) => r.status === "fail").length
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.filter((r) => r.status !== "pass"),
         summary,
         result: { epsa: rows, summary },
         markdown: buildMarkdown("EPSA", rows, summary, ["component", "parameter", "actual", "rating", "margin_percent", "status"])
       };
     }

     function runWCCA(netlist, _testPlan, _partsLibrary, toleranceLibrary) {
       const tolerances = buildToleranceMap(toleranceLibrary);
       const rows = [];
       const components = Array.isArray(netlist.components) ? netlist.components : [];

       for (const component of components) {
         if (classifyComponent(component.refdes) !== "resistor") continue;
         const nominal = parseResistance(component.value);
         if (!Number.isFinite(nominal) || nominal <= 0) continue;
         const tol = toNumber(tolerances[component.refdes], toNumber(tolerances.default, 0.05));
         const high = nominal * (1 + tol);
         const low = nominal * (1 - tol);
         const deviation = tol * 100;
         rows.push({
           network: component.refdes,
           nominal_value: round4(nominal),
           worst_case_high: round4(high),
           worst_case_low: round4(low),
           deviation_percent: round2(deviation),
           margin_status: deviation <= 5 ? "good" : deviation <= 10 ? "watch" : "critical"
         });
       }

       const summary = {
         entries: rows.length,
         avg_deviation_percent: rows.length ? round2(rows.reduce((a, r) => a + r.deviation_percent, 0) / rows.length) : 0,
         critical_count: rows.filter((r) => r.margin_status === "critical").length
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.filter((r) => r.margin_status !== "good"),
         summary,
         result: { wcca: rows, summary },
         markdown: buildMarkdown("WCCA", rows, summary, ["network", "nominal_value", "worst_case_high", "worst_case_low", "deviation_percent", "margin_status"])
       };
     }

     function runCoverage(netlist, testPlan) {
       const nets = dedupe((netlist.components || []).flatMap((c) => extractComponentNets(c)));
       const covered = extractCoveredNets(testPlan);
       const coverageMap = {};
       for (const net of nets) coverageMap[net] = covered.has(net);
       const total = nets.length;
       const coveredCount = nets.filter((n) => coverageMap[n]).length;
       const criticalNets = nets.filter((n) => isPowerNet(n) || isBiasNet(n) || isInterfaceNet(n));
       const criticalCovered = criticalNets.filter((n) => coverageMap[n]).length;

       const tpByNet = {};
       for (const component of netlist.components || []) {
         if (!isTestPoint(component.refdes)) continue;
         for (const net of extractComponentNets(component)) {
           tpByNet[net] = (tpByNet[net] || 0) + 1;
         }
       }

       const rows = nets.map((net) => ({
         net,
         covered: coverageMap[net],
         critical: criticalNets.includes(net),
         test_points: tpByNet[net] || 0,
         redundancy_status: (tpByNet[net] || 0) <= 1 ? "single-point-risk" : "redundant"
       }));


       const summary = {
         total_nets: total,
         covered_nets: coveredCount,
         net_coverage_percent: total ? round2((coveredCount / total) * 100) : 0,
         critical_net_coverage_percent: criticalNets.length ? round2((criticalCovered / criticalNets.length) * 100) : 0
       };



       return {
         primaryRows: rows,
         secondaryRows: rows.filter((r) => r.redundancy_status !== "redundant"),
         summary,
         result: { coverage: rows, summary, coverage_map: coverageMap },
         markdown: buildMarkdown("Coverage", rows, summary, ["net", "covered", "critical", "test_points", "redundancy_status"])
       };
     }

     function renderAnalysis(analysis) {
       renderTable("primary", analysis.primaryRows || []);
       renderTable("secondary", analysis.secondaryRows || []);
       renderSummary(analysis.summary || {});
     }

     function renderTable(which, rows) {
       const head = which === "primary" ? resultsHead : secondaryHead;
       const body = which === "primary" ? resultsBody : secondaryBody;
       head.innerHTML = "";
       body.innerHTML = "";
       if (!rows.length) {
         const tr = document.createElement("tr");
         const td = document.createElement("td");
         td.textContent = "No rows.";
         tr.appendChild(td);
         body.appendChild(tr);
         return;
       }
       const keys = Object.keys(rows[0]);
       for (const key of keys) {
         const th = document.createElement("th");
         th.textContent = key;
         th.addEventListener("click", () => {
           const direction = sortState.key === key && sortState.table === which ? -sortState.direction : 1;
           sortState = { key, direction, table: which };
           rows.sort((a, b) => compareValues(a[key], b[key]) * direction);
           renderTable(which, rows);
         });
         head.appendChild(th);
       }

       for (const row of rows) {
         const tr = document.createElement("tr");
         for (const key of keys) {
           const td = document.createElement("td");
           const value = row[key];
           td.textContent = Array.isArray(value) ? value.join(", ") : String(value);
           applyCellColor(td, key, value);
           tr.appendChild(td);
         }
         body.appendChild(tr);
       }
     }

     function applyCellColor(td, key, value) {
       const lowerKey = String(key).toLowerCase();
       const lowerValue = String(value).toLowerCase();
       if (lowerKey === "rpn") {
         const n = Number(value);
         if (n >= 250) td.classList.add("status-bad");
         else if (n >= 120) td.classList.add("status-warn");
         else td.classList.add("status-ok");
       }
      if (lowerKey.includes("coverage") || lowerKey === "covered") {
        if (lowerValue === "true" || lowerValue === "covered" || Number(value) >= 80) td.classList.add("status-ok");
        else td.classList.add("status-warn");
      }
       if (lowerKey === "status" || lowerKey.endsWith("status")) {
         if (lowerValue === "pass" || lowerValue === "good" || lowerValue === "redundant") td.classList.add("status-ok");
         else if (lowerValue === "warn" || lowerValue === "watch") td.classList.add("status-warn");
         else td.classList.add("status-bad");
       }
     }

     function renderSummary(summary) {
       summaryGrid.innerHTML = "";
       for (const [k, v] of Object.entries(summary)) {
         const item = document.createElement("div");
         item.className = "metric";
         item.innerHTML = '<span class="k">' + k + '</span><span class="v">' + v + "</span>";
         summaryGrid.appendChild(item);
       }
     }

    function exportResults() {
      if (!state.lastOutput || !state.lastAnalysisType) return;
      const stem = buildStableAnalysisStem();
      const jsonName = stem + ".json";
      const mdName = stem + ".md";
      (async () => {
        let savedDirect = false;
        try {
          const okJson = await writeJsonToFmeaDirectory("", jsonName, state.lastOutput);
          const okMd = await writeTextToFmeaDirectory("", mdName, state.lastMarkdown || "");
          savedDirect = okJson && okMd;
        } catch (_err) {
          savedDirect = false;
        }
        if (!savedDirect) {
          downloadBlob(jsonName, JSON.stringify(state.lastOutput, null, 2), "application/json");
          downloadBlob(mdName, state.lastMarkdown, "text/markdown");
          setSavedStatus("Direct result save unavailable. Downloaded files instead.");
        } else {
          setSavedStatus("Saved result files to json/fmea/" + jsonName + " and .md pair (overwrites same PN/REV).");
          refreshSavedFiles();
        }
        state.outputsExported = true;
        updateWorkflowUi();
      })();
    }

    function saveResultsFile() {
      if (!state.lastOutput || !state.lastAnalysisType) return;
      autoSaveLatestAnalysisReport();
    }

     function downloadBlob(filename, content, mime) {
       const blob = new Blob([content], { type: mime });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       a.download = filename;
       document.body.appendChild(a);
       a.click();
       a.remove();
       URL.revokeObjectURL(url);
     }

     function buildMarkdown(title, rows, summary, columns) {
       const lines = [];
       lines.push("# " + title + " Report");
       lines.push("");
       lines.push("Engine Version: " + ENGINE_VERSION);
       lines.push("Generated On: " + new Date().toISOString());
       lines.push("");
       lines.push("## Summary");
       for (const [k, v] of Object.entries(summary)) {
         lines.push("- " + k + ": " + v);
       }
       lines.push("");
       lines.push("## Results");
       if (!rows.length) {
         lines.push("No rows.");
         return lines.join("\n");
       }
       lines.push("| " + columns.join(" | ") + " |");
       lines.push("| " + columns.map(() => "---").join(" | ") + " |");
       const maxRows = Math.min(rows.length, 500);
       for (let i = 0; i < maxRows; i += 1) {
         const row = rows[i];
         const cells = columns.map((col) => {
           const value = row[col];
           if (Array.isArray(value)) return value.join(", ");
           return String(value);
         });
         lines.push("| " + cells.join(" | ") + " |");
       }
       return lines.join("\n");
     }

     function buildPartsMap(partsLibrary) {
       const map = {};
       if (!partsLibrary || typeof partsLibrary !== "object") return map;
       if (partsLibrary.by_refdes && typeof partsLibrary.by_refdes === "object") {
         return Object.assign({}, partsLibrary.by_refdes);
       }
       if (Array.isArray(partsLibrary.parts)) {
         for (const part of partsLibrary.parts) {
           if (part && part.refdes) map[part.refdes] = part;
         }
       }
       return map;
     }

     function buildToleranceMap(toleranceLibrary) {
       const map = {};
       if (!toleranceLibrary || typeof toleranceLibrary !== "object") {
         map.default = 0.05;
         return map;
       }
       if (typeof toleranceLibrary.default_tolerance === "number") {
         map.default = toleranceLibrary.default_tolerance;
       } else {
         map.default = 0.05;
       }
       if (Array.isArray(toleranceLibrary.tolerances)) {
         for (const t of toleranceLibrary.tolerances) {
           if (t && t.refdes && typeof t.tolerance === "number") map[t.refdes] = t.tolerance;
         }
       }
       if (toleranceLibrary.by_refdes && typeof toleranceLibrary.by_refdes === "object") {
         for (const [k, v] of Object.entries(toleranceLibrary.by_refdes)) {
           map[k] = Number(v);
         }
       }
       return map;
     }

     function buildStressRow(component, parameter, actual, rating, threshold) {
       const margin = rating === 0 ? -100 : ((rating - actual) / rating) * 100;
       const status = margin < 0 ? "fail" : margin < threshold ? "warn" : "pass";
       return {
         component,
         parameter,
         actual: round4(actual),
         rating: round4(rating),
         margin_percent: round2(margin),
         status
       };
     }

     function buildNetToRefsMap(netlist) {
       const map = {};
       for (const component of netlist.components || []) {
         const ref = component.refdes || "UNASSIGNED";
         for (const net of extractComponentNets(component)) {
           if (!map[net]) map[net] = [];
           map[net].push(ref);
         }
       }
       return map;
     }

    function buildNetAdjacencyData(netlist) {
      if (!netlist || !Array.isArray(netlist.components)) return null;
      const netToRefs = buildNetToRefsMap(netlist);
      const nets = Object.keys(netToRefs).sort();
      const adjacency = {};
      for (const net of nets.slice(0, 120)) adjacency[net] = dedupe(netToRefs[net]);
      return {
        net_count: nets.length,
        truncated: nets.length > 120,
        adjacency
      };
    }

    function renderJsonValueTree(value, keyLabel, depth) {
      const entry = document.createElement("div");
      entry.className = "jsonEntry";
      if (keyLabel) {
        const key = document.createElement("span");
        key.className = "jsonBubble jsonKeyBubble";
        key.textContent = keyLabel;
        entry.appendChild(key);
      }

      const appendPrimitive = (primitive, cls) => {
        const bubble = document.createElement("span");
        bubble.className = "jsonBubble jsonValBubble " + cls;
        bubble.textContent = primitive === null ? "null" : String(primitive);
        entry.appendChild(bubble);
      };

      if (depth > 7) {
        appendPrimitive("max depth reached", "type-object");
        return entry;
      }

      if (value === null) {
        appendPrimitive(null, "type-null");
        return entry;
      }
      if (typeof value === "number") {
        appendPrimitive(value, "type-number");
        return entry;
      }
      if (typeof value === "boolean") {
        appendPrimitive(value, "type-boolean");
        return entry;
      }
      if (typeof value !== "object") {
        appendPrimitive(value, "type-string");
        return entry;
      }

      const child = document.createElement("div");
      child.className = "jsonChild";
      if (Array.isArray(value)) {
        if (!value.length) {
          appendPrimitive("empty list", "type-object");
          return entry;
        }
        value.slice(0, 250).forEach((item, idx) => child.appendChild(renderJsonValueTree(item, "item " + (idx + 1), depth + 1)));
        if (value.length > 250) child.appendChild(renderJsonValueTree("truncated", "more", depth + 1));
      } else {
        const keys = Object.keys(value);
        if (!keys.length) {
          appendPrimitive("empty object", "type-object");
          return entry;
        }
        keys.slice(0, 250).forEach((k) => child.appendChild(renderJsonValueTree(value[k], k, depth + 1)));
        if (keys.length > 250) child.appendChild(renderJsonValueTree("truncated", "more", depth + 1));
      }
      entry.appendChild(child);
      return entry;
    }

    function renderJsonViewer(container, value, emptyText) {
      if (!container) return;
      container.innerHTML = "";
      if (value === null || value === undefined) {
        container.classList.add("jsonStatus");
        container.textContent = emptyText || "No JSON loaded.";
        return;
      }
      const tree = document.createElement("div");
      tree.className = "jsonTree";
      tree.appendChild(renderJsonValueTree(value, "root", 0));
      container.classList.remove("jsonStatus");
      container.appendChild(tree);
    }

     function extractCoveredNets(testPlan) {
       const set = new Set();
       if (!testPlan || typeof testPlan !== "object") return set;

       if (Array.isArray(testPlan.covered_nets)) {
         for (const net of testPlan.covered_nets) {
           if (typeof net === "string") set.add(net);
         }
       }

       if (Array.isArray(testPlan.nets)) {
         for (const net of testPlan.nets) {
           if (typeof net === "string") set.add(net);
         }
       }

       if (Array.isArray(testPlan.tests)) {
         for (const test of testPlan.tests) {
           if (!test || typeof test !== "object") continue;
           const candidates = [].concat(test.nets || [], test.covered_nets || [], test.affected_nets || []);
           for (const net of candidates) {
             if (typeof net === "string") set.add(net);
           }
         }
       }
       return set;
     }

     function extractComponentNets(component) {
       const nets = [];
       for (const pin of component.pins || []) {
         if (pin && typeof pin.net === "string") nets.push(pin.net);
       }
       return dedupe(nets);
     }

     function computeSeverity(nets) {
       let max = 4;
       for (const net of nets) {
         if (isInterfaceNet(net)) max = Math.max(max, 9);
         else if (isPowerNet(net)) max = Math.max(max, 8);
         else if (isBiasNet(net)) max = Math.max(max, 7);
         else max = Math.max(max, 5);
       }
       return max;
     }

    function classifyComponent(refdes) {
      const r = String(refdes || "").toUpperCase();
      if (isTestPoint(r)) return "test_point";
      if (r.startsWith("R")) return "resistor";
      if (r.startsWith("C")) return "capacitor";
      if (r.startsWith("Q")) return "transistor";
      if (r.startsWith("D")) return "diode";
      if (r.startsWith("L")) return "inductor";
      if (r.startsWith("U") || r.startsWith("IC")) return "integrated_circuit";
      if (r.startsWith("S")) return "switch";
      if (r.startsWith("F")) return "fuse";
      if (r.startsWith("K")) return "relay";
      if (r.startsWith("T")) return "transformer";
      if (r.startsWith("X")) return "crystal";
      if (r.startsWith("B")) return "sensor";
      if (r.startsWith("J") || r.startsWith("P")) return "connector";
      return "other";
    }

     function isTestPoint(refdes) {
       const r = String(refdes || "").toUpperCase();
       return r.startsWith("TP") || r.includes("TEST");
     }

     function isPowerNet(net) {
       const n = String(net || "").toUpperCase();
       return n === "V+" || n === "VCC" || n === "VBAT" || n === "GND" || n.includes("POWER");
     }

     function isBiasNet(net) {
       const n = String(net || "").toUpperCase();
       return n.includes("BIAS") || n.includes("BASE");
     }

     function isInterfaceNet(net) {
       const n = String(net || "").toUpperCase();
       return n.includes("INPUT") || n.includes("OUTPUT") || n.includes("INTERFACE") || n.startsWith("IO");
     }

     function estimateComponentVoltage(netlist, nets) {
       const levels = nets.map((net) => estimateNetVoltage(netlist, net)).filter((x) => Number.isFinite(x));
       if (!levels.length) return 0;
       if (levels.length === 1) return levels[0];
       const max = Math.max.apply(null, levels);
       const min = Math.min.apply(null, levels);
       return Math.abs(max - min);
     }

     function estimateNetVoltage(netlist, net) {
       const n = String(net || "").toUpperCase();
       if (n === "GND") return 0;
       if (n === "V+" || n === "VCC") return 12;
       if (isInterfaceNet(n)) return 5;
       const byMeta = safeGet(netlist, ["net_metadata", net, "nominal_voltage"], null);
       if (typeof byMeta === "number") return byMeta;
       return 1;
     }

     function estimateComponentCurrent(componentClass, voltage, value) {
       if (componentClass === "resistor") {
         const r = parseResistance(value);
         if (r > 0) return voltage / r;
       }
       if (componentClass === "connector") return Math.max(0.01, voltage / 100);
       if (componentClass === "transistor") return Math.max(0.002, voltage / 1000);
       return Math.max(0.001, voltage / 2000);
     }

     function computeResistorPower(voltage, value) {
       const r = parseResistance(value);
       if (!Number.isFinite(r) || r <= 0) return 0;
       return (voltage * voltage) / r;
     }

     function parseResistance(raw) {
       if (typeof raw === "number") return raw;
       const v = String(raw || "").trim().toLowerCase();
       if (!v) return NaN;
       if (/^\d+(\.\d+)?$/.test(v)) return Number(v);
       const normalized = v.replace(",", ".");
       const match = normalized.match(/^(\d+(\.\d+)?)([kmun]?)(\d+)?$/);
       if (!match) return NaN;
       const lead = Number(match[1] || "0");
       const suffix = match[3] || "";
       const tail = match[4] || "";
       let value = lead;
       if (tail) value = Number(String(lead) + "." + tail);
       const scale = suffix === "m" ? 1e6 : suffix === "k" ? 1e3 : suffix === "u" ? 1e-6 : suffix === "n" ? 1e-9 : 1;
       return value * scale;
     }

     function compareValues(a, b) {
       const na = Number(a);
       const nb = Number(b);
       if (Number.isFinite(na) && Number.isFinite(nb)) return na - nb;
       return String(a).localeCompare(String(b));
     }

     function safeGet(obj, path, fallback) {
       let cur = obj;
       for (const key of path) {
         if (!cur || typeof cur !== "object" || !(key in cur)) return fallback;
         cur = cur[key];
       }
       return cur;
     }

     function safeFilePart(v) {
       return String(v || "unknown").replace(/[^a-z0-9_.-]/gi, "_");
     }

    function dedupe(arr) {
      return Array.from(new Set(arr));
    }

    function arraysEqual(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
      for (let i = 0; i < a.length; i += 1) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

     function toNumber(v, fallback) {
       const n = Number(v);
       return Number.isFinite(n) ? n : fallback;
     }

     function round2(n) {
       return Math.round(Number(n) * 100) / 100;
     }

     function round4(n) {
       return Math.round(Number(n) * 10000) / 10000;
     }

    function resetRunState() {
      state.lastAnalysisType = null;
      state.lastOutput = null;
      state.lastMarkdown = "";
      state.outputsExported = false;
      renderJsonViewer(outputViewer, null, "No JSON output yet.");
      resultsHead.innerHTML = "";
      resultsBody.innerHTML = "";
      secondaryHead.innerHTML = "";
      secondaryBody.innerHTML = "";
      summaryGrid.innerHTML = "";
      applyFixedUiDefaults();
      updateWorkflowUi();
    }
   </script>
</body>
</html>
